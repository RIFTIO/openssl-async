diff -uBbw -Nr ../openssl-async/Configure ./Configure
--- ../openssl-async/Configure	2015-03-05 12:44:09.944305000 +0000
+++ ./Configure	2015-03-05 12:44:09.792302000 +0000
@@ -716,6 +716,7 @@
 		 "gmp"		  => "default",
 		 "jpake"          => "experimental",
 		 "md2"            => "default",
+		 "hw-qat"	  => "default",
 		 "rc5"            => "default",
 		 "rfc3779"	  => "default",
 		 "sctp"       => "default",
@@ -1373,6 +1374,35 @@
 		}
 	}
 
+if (!defined($disabled{"hw-qat"}))
+	{
+		use Cwd 'abs_path';
+		my $here = abs_path($0);
+		$here =~ s|/[^/]*$||;
+        
+		my $icp_api_dir = '$(ICP_ROOT)/quickassist/include';
+		my $icp_eng_qat_dir = ''.$here.'/engines/qat_engine';
+		if ( $ENV{'ICP_API_PATH'} )
+			{
+			$icp_api_dir = '$(ICP_API_PATH)';
+			}
+
+		if ( $ENV{'ICP_QAT_ENGINE_PATH'} )
+			{
+			$icp_eng_qat_dir = '$(ICP_QAT_ENGINE_PATH)';
+			}
+
+		my $icp_lac_api_dir = $icp_api_dir.'/lac';
+
+		if ( $ENV{'ICP_BUILD_OUTPUT'} )
+			{
+			$lflags .= ' -L$(ICP_BUILD_OUTPUT)';
+			}
+		
+		$lflags .= ' -lz -lpthread -lrt';
+		$cflags .= ' -I'.$icp_eng_qat_dir.' -I'.$icp_api_dir.' -I'.$icp_lac_api_dir.' -DOPENSSL_QAT_ASYNCH -DOPENSSL_DISABLE_QAT_DIGEST_ASYNCH -DOPENSSL_DISABLE_QAT_DIGEST_SYNCH -DOPENSSL_DISABLE_QAT_OFFLOAD_RAND -DOPENSSL_DISABLE_QAT_PRF_SYNCH -DOPENSSL_DISABLE_QAT_PRF_ASYNCH -DDISABLE_ASYNCH_BULK_PERF';
+	}
+
 # You will find shlib_mark1 and shlib_mark2 explained in Makefile.org
 my $shared_mark = "";
 if ($shared_target eq "")
@@ -1588,6 +1618,18 @@
 unlink("$Makefile.new") || die "unable to remove old $Makefile.new:$!\n" if -e "$Makefile.new";
 open(OUT,">$Makefile.new") || die "unable to create $Makefile.new:$!\n";
 print OUT "### Generated automatically from Makefile.org by Configure.\n\n";
+    if ( !$disabled{"hw-qat"} )
+    {
+        if ( !$ENV{'ICP_ROOT'} )
+        {
+            die "ICP_ROOT is not defined. This must be set to support QAT acceleration. \nPlease set ICP_ROOT and rerun this script.\n";
+        }
+        print OUT "ICP_ROOT?=$ENV{'ICP_ROOT'}\n\n";
+        if ( $ENV{'ICP_BUILD_OUTPUT'} )
+        {
+            print OUT "ICP_BUILD_OUTPUT?=$ENV{'ICP_BUILD_OUTPUT'}\n\n";
+        }
+    }
 my $sdirs=0;
 while (<IN>)
 	{
@@ -1603,6 +1645,7 @@
 	$sdirs = 0 unless /\\$/;
         s/engines // if (/^DIRS=/ && $disabled{"engine"});
 	s/ccgost// if (/^ENGDIRS=/ && $disabled{"gost"});
+	$_ .= " qat_engine" if (/^ENGDIRS=/ && !$disabled{"hw-qat"});
 	s/^VERSION=.*/VERSION=$version/;
 	s/^MAJOR=.*/MAJOR=$major/;
 	s/^MINOR=.*/MINOR=$minor/;
diff -uBbw -Nr ../openssl-async/apps/Makefile ./apps/Makefile
--- ../openssl-async/apps/Makefile	2015-03-05 12:43:36.154847000 +0000
+++ ./apps/Makefile	2015-03-05 12:44:09.830308000 +0000
@@ -32,6 +32,48 @@
 LIBPTHREAD=-lpthread
 LIBRARIES=$(LIBSSL) $(LIBKRB5) $(LIBCRYPTO) $(LIBPTHREAD) 
 
+ifndef CMN_ROOT
+CRYPTO_MEMORY_DRIVER=qat_mem
+else
+CRYPTO_MEMORY_DRIVER=qae_mem
+endif
+
+ifeq ($(CRYPTO_MEMORY_DRIVER),qat_mem)
+CFLAGS+=-D USE_QAT_MEM -I$(OPENSSL_ROOT)/engines/qat_engine/
+DLIB_QAE_MEM= -L../engines/qat_engine -lqae_mem_utils
+LIB_QAE_MEM= 
+endif
+ifeq ($(CRYPTO_MEMORY_DRIVER),qae_mem)
+CFLAGS+=-D USE_QAE_MEM -I$(OPENSSL_ROOT)/engines/qat_engine/
+DLIB_QAE_MEM = -Wl,-rpath,$(CMN_ROOT) -L$(CMN_ROOT) -lqae_mem_s
+DLIB_QAE_MEM += -L$(OPENSSL_ROOT)/engines/qat_engine/ -lqat_mem_drv_inf
+LIB_QAE_MEM+= $(CMN_ROOT)/libqae_mem.a
+endif
+
+LIBQATDL=-ldl
+LIBRARIES += $(LIBQATDL)
+LIBQATZ=-lz
+LIBQATRT=-lrt
+DRIVER=icp_qa_al
+ifdef WITH_CPA_MUX
+DRIVER=qat_mux
+BUILD_PATH=-L$(ICP_ROOT)/../cpa_mux/src/build/linux_2.6/user_space
+endif
+
+ifdef ICP_BUILD_OUTPUT
+LIBQATDRIVER= 
+DLIBQATDRIVER= -L$(ICP_BUILD_OUTPUT) $(BUILD_PATH) -l$(DRIVER) -ladf_proxy -losal
+else
+LIBQATDRIVER=
+DLIBQATDRIVER= -l$(DRIVER) -ladf_proxy -losal
+endif
+
+ifneq ($(shell test -n "$(SHARED_LIBS)" && echo 1),1) #STATIC
+LIBRARIES += $(LIB_QAE_MEM) $(DLIBQATDRIVER) 
+else #SHARED
+LIBRARIES += $(DLIB_QAE_MEM)
+endif 
+LIBRARIES += $(LIBQATZ) $(LIBQATRT)
 
 PROGRAM= openssl
 
diff -uBbw -Nr ../openssl-async/apps/openssl.c ./apps/openssl.c
--- ../openssl-async/apps/openssl.c	2015-03-05 12:44:09.958307000 +0000
+++ ./apps/openssl.c	2015-03-05 12:43:44.061957000 +0000
@@ -133,6 +133,16 @@
 #include <openssl/fips.h>
 #endif
 
+#ifndef OPENSSL_NO_HW_QAT
+#ifdef USE_QAT_MEM
+#include "qae_mem_utils.h"
+#define QAT_DEV "/dev/qat_mem"
+#endif
+#ifdef USE_QAE_MEM
+#include "qat_mem_drv_inf.h"
+#define QAT_DEV "/dev/qae_mem"
+#endif
+#endif
 /* The LHASH callbacks ("hash" & "cmp") have been replaced by functions with the
  * base prototypes (we cast each variable inside the function to the required
  * type of "FUNCTION*"). This removes the necessity for macro-generated wrapper
@@ -284,6 +294,23 @@
 		}
 #endif /* defined( OPENSSL_SYS_VMS) && (__INITIAL_POINTER_SIZE == 64) */
 
+#ifndef OPENSSL_NO_HW_QAT
+	for (i=0; i < Argc; i++)
+	{
+		if (!strcmp("-zero_copy",Argv[i])){
+			if (access(QAT_DEV, F_OK) == 0)
+			{
+				if (CRYPTO_set_mem_ex_functions(qaeCryptoMemAlloc, qaeCryptoMemRealloc, qaeCryptoMemFree))
+			           printf("%s: CRYPTO_set_mem_functions succeeded\n", __func__);
+			}
+			else
+			{
+				perror("access");
+			}
+		}
+	}
+#endif
+
 	arg.data=NULL;
 	arg.count=0;
 
diff -uBbw -Nr ../openssl-async/apps/s_server.c ./apps/s_server.c
--- ../openssl-async/apps/s_server.c	2015-03-05 12:44:09.964306000 +0000
+++ ./apps/s_server.c	2015-03-05 12:43:44.067958000 +0000
@@ -191,6 +191,14 @@
 #endif
 #include "s_apps.h"
 #include "timeouts.h"
+#ifndef OPENSSL_NO_HW_QAT
+#ifdef USE_QAT_MEM
+#include "qae_mem_utils.h"
+#endif
+#ifdef USE_QAE_MEM
+#include "qat_mem_drv_inf.h"
+#endif
+#endif
 
 #if (defined(OPENSSL_SYS_VMS) && __VMS_VER < 70000000)
 /* FIONBIO used as a switch to enable ioctl, and that isn't in VMS < 7.0 */
@@ -566,6 +574,9 @@
 # endif
 #endif
 	BIO_printf(bio_err," -keymatexport label   - Export keying material using label\n");
+#ifndef OPENSSL_NO_HW_QAT
+	BIO_printf(bio_err," -zero_copy    - Run in zero copy mode ");
+#endif
 	BIO_printf(bio_err," -keymatexportlen len  - Export len bytes of keying material (default 20)\n");
 	BIO_printf(bio_err," -status           - respond to certificate status requests\n");
 	BIO_printf(bio_err," -status_verbose   - enable status request verbose printout\n");
@@ -966,6 +977,9 @@
 	X509 *s_cert = NULL, *s_dcert = NULL;
 	EVP_PKEY *s_key = NULL, *s_dkey = NULL;
 	int no_cache = 0;
+#ifndef OPENSSL_NO_HW_QAT
+	int zero_copy = 0;
+#endif
 #ifndef OPENSSL_NO_TLSEXT
 	EVP_PKEY *s_key2 = NULL;
 	X509 *s_cert2 = NULL;
@@ -1356,6 +1370,12 @@
 			{
 			ssl_mode = SSL_MODE_ASYNCHRONOUS;
 			}
+#ifndef OPENSSL_NO_HW_QAT
+		else if (strcmp(*argv,"-zero_copy") == 0)
+			{
+			zero_copy = 1;
+			}
+#endif
 		else
 			{
 			BIO_printf(bio_err,"unknown option %s\n",*argv);
@@ -1404,7 +1424,34 @@
 	OpenSSL_add_ssl_algorithms();
 
 #ifndef OPENSSL_NO_ENGINE
+#ifndef OPENSSL_NO_HW_QAT
+	if (engine_id != NULL)
+		e = ENGINE_by_id(engine_id);
+	if (e != NULL)
+		{
+		if (zero_copy)
+			{
+			if(!ENGINE_ctrl_cmd(e,"SET_V2P", (long) qaeCryptoMemV2P, NULL, NULL, 0))
+				{
+				printf("Cannot set V2P function\n");
+				ENGINE_free(e);
+				goto end;
+				}
+			if (!ENGINE_ctrl_cmd(e, "ENABLE_ZERO_COPY_MODE", 0, NULL, NULL, 0))
+				{
+				printf("Unable to enable zero copy mode on engine\n");
+				ENGINE_free(e);
+				goto end;
+				}
+			}
+		}
+#endif
         e = setup_engine(bio_err, engine_id, 1);
+
+#ifndef OPENSSL_NO_HW_QAT
+	if ((e == NULL) && (zero_copy))
+		goto end;
+#endif
 #endif
 
 	if (!app_passwd(bio_err, passarg, dpassarg, &pass, &dpass))
diff -uBbw -Nr ../openssl-async/apps/speed.c ./apps/speed.c
--- ../openssl-async/apps/speed.c	2015-03-05 12:44:09.970307000 +0000
+++ ./apps/speed.c	2015-03-05 12:43:44.071958000 +0000
@@ -110,6 +110,15 @@
 #include <signal.h>
 #endif
 
+#ifndef OPENSSL_NO_HW_QAT
+#ifdef USE_QAT_MEM
+#include "qae_mem_utils.h"
+#endif
+#ifdef USE_QAE_MEM
+#include "qat_mem_drv_inf.h"
+#endif
+#endif 
+
 #if defined(_WIN32) || defined(__CYGWIN__)
 #include <windows.h>
 # if defined(__CYGWIN__) && !defined(_WIN32)
@@ -359,6 +368,19 @@
 		cbData->stats->resp++;
 }
 
+#ifndef OPENSSL_NO_HW_QAT
+static void digest_async_num_ctx_cb(unsigned char *out, unsigned int outl, void *vparams, int status)
+	{
+	CallbackData_t *cbData = (CallbackData_t *)vparams;
+
+	if (status && outl != 0 && cbData)
+		{
+		cbData->stats->resp++;
+		EVP_MD_CTX_destroy(cbData->ctx.digest);
+		OPENSSL_free(cbData);
+		}
+	}
+#endif
 
 static int async_cb_ex(unsigned char *out, size_t outl, void *vparams, int status)
 {
@@ -530,6 +551,10 @@
 	if((retry == RETRY) && (ERR_R_RETRY == ERR_GET_REASON(error)))
 		{
 		stats->submission_retries++;
+#ifndef OPENSSL_NO_HW_QAT
+		if(*k != -1)
+			(*k)--;
+#endif
 		}
 	else
 		{
@@ -845,10 +870,15 @@
 	int decrypt=0;
         int async=0;
 	int batch=1;
+#ifndef OPENSSL_NO_HW_QAT
+	int num_ctx=1;
+#endif
 #ifndef NO_FORK
 	int multi=0;
 #endif
-
+#ifndef OPENSSL_NO_HW_QAT
+	int zero_copy=0;
+#endif
 #ifndef TIMES
 	usertime=-1;
 #endif
@@ -1010,6 +1040,26 @@
 			j--;	/* Otherwise, -elapsed gets confused with
 				   an algorithm. */
 			}
+#ifndef OPENSSL_NO_HW_QAT
+		else if ((argc > 0) && (strcmp(*argv,"-num_ctx") == 0))
+			{
+			argc--;
+			argv++;
+			if(argc == 0)
+				{
+				BIO_printf(bio_err,"no num_ctx value given\n");
+				goto end;
+				}
+			num_ctx=atoi(argv[0]);
+			if(num_ctx <= 0)
+				{
+				BIO_printf(bio_err,"bad num_ctx value\n");
+				goto end;
+				}
+			j--;    /* Otherwise, -num_ctx gets confused with
+				an algorithm. */
+			}
+#endif
 #ifndef NO_FORK
 		else if	((argc > 0) && (strcmp(*argv,"-multi") == 0))
 			{
@@ -1030,6 +1080,13 @@
 				   an algorithm. */
 			}
 #endif
+#ifndef OPENSSL_NO_HW_QAT
+		else if ((argc > 0) && (strcmp(*argv,"-zero_copy") == 0))
+			{
+			zero_copy=1;
+			j--;
+			}
+#endif
 		else if (argc > 0 && !strcmp(*argv,"-mr"))
 			{
 			mr=1;
@@ -1417,6 +1474,14 @@
 			BIO_printf(bio_err,"-engine e       use engine e, possibly a hardware device.\n");
 			BIO_printf(bio_err,"-asynch         use asynchronous processing in the engine.\n");
 			BIO_printf(bio_err,"-batch n        submit n requests back to back to the engine (only applicable in asynch mode).\n");
+#ifndef OPENSSL_NO_HW_QAT
+			BIO_printf(bio_err,"-num_ctx n      submit requests across n ctxs (only applicable in asynch mode).\n");
+			BIO_printf(bio_err,"                For digests only any value of num_ctx > 1 will result in a unique.\n");
+			BIO_printf(bio_err,"                ctx being created for each request. This will result in better\n");
+			BIO_printf(bio_err,"                performance as the requests will be spread across all logical\n");
+			BIO_printf(bio_err,"                instances within the engine at the expense of needing to alloc\n");
+			BIO_printf(bio_err,"                and free each ctx.\n");
+#endif
 #endif
 			BIO_printf(bio_err,"-evp e          use EVP e.\n");
 			BIO_printf(bio_err,"-decrypt        time decryption instead of encryption (only EVP).\n");
@@ -1424,6 +1489,9 @@
 #ifndef NO_FORK
 			BIO_printf(bio_err,"-multi n        run n benchmarks in parallel.\n");
 #endif
+#ifndef OPENSSL_NO_HW_QAT
+			BIO_printf(bio_err,"-zero_copy      run in zero copy mode\n");
+#endif
 			goto end;
 			}
 		argc--;
@@ -1435,6 +1503,10 @@
 	if(multi && do_multi(multi))
 		goto show_res;
 #endif
+#ifndef OPENSSL_NO_HW_QAT
+	if (multi)
+		qaeCryptoAtFork();
+#endif
 #ifndef OPENSSL_NO_ENGINE
 	/*Now that we are after the fork, each child can init the engine.*/
 	if (engine_id != NULL)
@@ -1442,6 +1514,23 @@
 	if (engine != NULL)
 		{
 
+#ifndef OPENSSL_NO_HW_QAT
+		if (zero_copy)
+			{
+			if(!ENGINE_ctrl_cmd(engine,"SET_V2P", (long) qaeCryptoMemV2P, NULL, NULL, 0))
+				{
+				printf("Cannot set V2P function\n");
+				ENGINE_free(engine);
+				goto end;
+				}
+			if (!ENGINE_ctrl_cmd(engine, "ENABLE_ZERO_COPY_MODE", 0, NULL, NULL, 0))
+				{
+				printf("Unable to enable zero copy mode on engine\n");
+				ENGINE_free(engine);
+				goto end;
+				}
+			}
+#endif
         if(async)
 	{
 		if (!ENGINE_ctrl_cmd(engine, "ENABLE_POLLING", 0, NULL, NULL, 0))
@@ -1455,6 +1544,10 @@
 		}
 	engine = setup_engine(bio_err, engine_id, 0);
 
+#ifndef OPENSSL_NO_HW_QAT
+	if ((NULL == engine) && (zero_copy))
+		goto end;
+#endif
 	if ((NULL == engine) && (async))
 		goto end;
 #endif
@@ -2301,6 +2394,10 @@
 				print_message(names[D_EVP],save_count,lengths[j]);
 				if(async)
 					{
+#ifndef OPENSSL_NO_HW_QAT
+					EVP_CIPHER_CTX * ctxs;
+					int k=0;
+#endif
 					EVP_CIPHER_CTX * ctx;
 					int outl;
 					int retval = 0;
@@ -2312,6 +2409,21 @@
 						ERR_print_errors(bio_err);
 						exit(EXIT_FAILURE);
 						}
+#ifndef OPENSSL_NO_HW_QAT
+					if (ctx)
+						OPENSSL_free(ctx);
+					ctxs=(EVP_CIPHER_CTX *)OPENSSL_malloc((num_ctx)*(sizeof(EVP_CIPHER_CTX)));
+					if(NULL==ctxs)
+						{
+						BIO_printf(bio_err, "[%s] --- Failed to allocate ctx\n", __func__);
+						ERR_print_errors(bio_err);
+						exit(EXIT_FAILURE);
+						}
+
+					for(k=0; k<num_ctx; k++)
+						{
+						ctx=ctxs+k;
+#endif
 					EVP_CIPHER_CTX_init(ctx);
 
 					if (!EVP_CIPHER_CTX_ctrl_ex(ctx, EVP_CTRL_SETUP_ASYNCH_CALLBACK,
@@ -2339,6 +2451,9 @@
     					}
 					EVP_CIPHER_CTX_set_padding(ctx, 0);
 					EVP_CIPHER_CTX_set_flags(ctx, EVP_CIPH_CTX_FLAG_CAN_IGNORE_IV);
+#ifndef OPENSSL_NO_HW_QAT
+						}
+#endif
 					/* Polling mode for speed measurements
  					 * 1) Submit a 'batch' number of requests to the engine or until ERR_R_RETRY
  					 *    status is encountered
@@ -2350,6 +2465,9 @@
 						{
 						for (count=0,run=1; COND(save_count*4*lengths[0]/lengths[j]); count++)
 							{
+#ifndef OPENSSL_NO_HW_QAT
+							ctx=ctxs+(count%num_ctx);
+#endif
 							retval = EVP_DecryptUpdate(ctx,buf,&outl,buf,lengths[j]);
 							if(retval == 0)
 								{ /*Assume this is a retry error and poll to free up TX space */
@@ -2364,13 +2482,24 @@
 								poll_engine(engine, &cb_stats, 0);
 							}
                                         	/* No padding is set so the final request will not produce a callback */
+#ifndef OPENSSL_NO_HW_QAT
+						for(k=0; k<num_ctx; k++)
+							{
+							ctx=ctxs+k;
+#endif
 							EVP_DecryptFinal_ex(ctx,buf,&outl);
+#ifndef OPENSSL_NO_HW_QAT
+							}
+#endif
 						poll_engine(engine, &cb_stats, EMPTY_ENGINE);
 						}
 					else
 						{
 						for (count=0,run=1; COND(save_count*4*lengths[0]/lengths[j]); count++)
 							{
+#ifndef OPENSSL_NO_HW_QAT
+							ctx=ctxs+(count%num_ctx);
+#endif
 							retval = EVP_EncryptUpdate(ctx,buf,&outl,buf,lengths[j]);
 							if(retval == 0)
 								{ /*Assume this is a retry error and poll to free up TX space */
@@ -2384,18 +2513,37 @@
 								poll_engine(engine, &cb_stats, 0);
 							}
                                         	/* No padding is set so the final request will not produce a callback */
+#ifndef OPENSSL_NO_HW_QAT
+						for (k=0; k<num_ctx; k++)
+							{
+							ctx=ctxs+k;
+#endif
 						retval = EVP_EncryptFinal_ex(ctx,buf,&outl);
 						if(retval == 0)
 							{
 							dumpError_ex("Error reported by EVP interface", cb_data.stats,RETRY,&k);
 								poll_engine(engine, &cb_stats, 0);
 								}
+#ifndef OPENSSL_NO_HW_QAT
+							}
+#endif
 							poll_engine(engine, &cb_stats, EMPTY_ENGINE);
 						}
 
 					d=Time_F(STOP);
 					 
+#ifndef OPENSSL_NO_HW_QAT
+					for (k=0; k<num_ctx; k++)
+						{
+						ctx=ctxs+k;
+#endif
 					EVP_CIPHER_CTX_cleanup(ctx);
+#ifndef OPENSSL_NO_HW_QAT
+						}
+					if(ctxs)
+						OPENSSL_free(ctxs);
+					ctx=NULL;
+#endif
 					if(ctx)
 						OPENSSL_free(ctx);
 					} 
@@ -2444,9 +2592,12 @@
 				names[D_EVP]=OBJ_nid2ln(evp_md->type);
 				print_message(names[D_EVP],save_count,
 					lengths[j]);
-
 				if(async)
 					{
+#ifndef OPENSSL_NO_HW_QAT
+				if (1 == num_ctx)
+					{
+#endif
 					CallbackData_t cb_data;
 					EVP_MD_CTX ctx;
 				     	EVP_MD_CTX_init(&ctx);
@@ -2473,6 +2624,61 @@
 					    	}
 				     	d=Time_F(STOP);
 				     	EVP_MD_CTX_cleanup(&ctx);
+#ifndef OPENSSL_NO_HW_QAT
+					}
+				else
+					{
+					int retval = 1;
+					EVP_MD_CTX* pctx;
+					CallbackData_t* pcb_data;
+					Time_F(START);
+					for (count=0,run=1; COND(save_count*4*lengths[0]/lengths[j]); count++)
+						{
+						pcb_data=(CallbackData_t *)OPENSSL_malloc(sizeof(CallbackData_t));
+						pctx=EVP_MD_CTX_create();
+						if(NULL==pctx || NULL==pcb_data)
+							{
+							BIO_printf(bio_err, "[%s] --- Failed to allocate ctx or cb data\n", __func__);
+							ERR_print_errors(bio_err);
+							exit(EXIT_FAILURE);
+							}
+						EVP_MD_CTX_set_flags(pctx,EVP_MD_CTX_FLAG_ONESHOT);
+
+						pcb_data->ctx.digest = pctx;
+						pcb_data->stats = &cb_stats;
+						if (!EVP_MD_CTX_ctrl_ex(pctx, EVP_MD_CTRL_SETUP_ASYNCH_CALLBACK,
+								0, pcb_data, (void (*)(void))digest_async_num_ctx_cb))
+							{
+							BIO_printf(bio_err, "[%s] --- Failed to Enable async/polling"
+								"with EVP_MD_CTX_ctrl_ex\n", __func__);
+							ERR_print_errors(bio_err);
+							exit(EXIT_FAILURE);
+							}
+
+						EVP_DigestInit_ex(pctx, evp_md, engine);
+						EVP_DigestUpdate(pctx, buf, lengths[j]);
+						retval = EVP_DigestFinal_ex(pctx, &(md[0]), NULL);
+						if(retval == 0)
+							{
+							dumpError("Error reported by EVP interface", pcb_data->stats,RETRY);
+							poll_engine(engine, &cb_stats, 0);
+							EVP_MD_CTX_destroy(pcb_data->ctx.digest);
+							OPENSSL_free(pcb_data);
+							count--;
+							/* Decrement count as the request was not submitted */
+
+							}
+						else
+							{
+							cb_stats.req++;
+							if (count != 0 && (count % batch) == 0)
+								poll_engine(engine, &cb_stats, 0);
+							}
+						}
+					poll_engine(engine, &cb_stats, EMPTY_ENGINE);
+					d=Time_F(STOP);
+					}
+#endif
 				     	}
 				else
 				     	{
diff -uBbw -Nr ../openssl-async/crypto/engine/eng_all.c ./crypto/engine/eng_all.c
--- ../openssl-async/crypto/engine/eng_all.c	2015-03-05 12:43:36.593853000 +0000
+++ ./crypto/engine/eng_all.c	2015-03-05 12:43:44.142953000 +0000
@@ -109,6 +109,9 @@
 #ifndef OPENSSL_NO_HW_PADLOCK
 	ENGINE_load_padlock();
 #endif
+#ifndef OPENSSL_NO_HW_QAT     
+	ENGINE_load_qat();
+#endif
 #endif
 #ifndef OPENSSL_NO_GOST
 	ENGINE_load_gost();
@@ -120,6 +123,9 @@
 	ENGINE_load_capi();
 #endif
 #endif
+#ifndef OPENSSL_NO_HW_QAT 
+        return;
+#endif    
 	ENGINE_register_all_complete();
 	}
 
diff -uBbw -Nr ../openssl-async/crypto/engine/engine.h ./crypto/engine/engine.h
--- ../openssl-async/crypto/engine/engine.h	2015-03-05 12:43:36.606852000 +0000
+++ ./crypto/engine/engine.h	2015-03-05 12:43:44.145955000 +0000
@@ -343,6 +343,9 @@
 void ENGINE_load_ubsec(void);
 void ENGINE_load_padlock(void);
 void ENGINE_load_capi(void);
+#ifndef OPENSSL_NO_HW_QAT
+void ENGINE_load_qat(void);
+#endif
 #ifndef OPENSSL_NO_GMP
 void ENGINE_load_gmp(void);
 #endif
Files ../openssl-async/crypto/pkcs7/p7/cert.p7c and ./crypto/pkcs7/p7/cert.p7c differ
Files ../openssl-async/crypto/pkcs7/p7/smime.p7m and ./crypto/pkcs7/p7/smime.p7m differ
Files ../openssl-async/crypto/pkcs7/p7/smime.p7s and ./crypto/pkcs7/p7/smime.p7s differ
diff -uBbw -Nr ../openssl-async/engines/Makefile ./engines/Makefile
--- ../openssl-async/engines/Makefile	2015-03-05 12:43:37.312865000 +0000
+++ ./engines/Makefile	2015-03-05 12:44:09.846301000 +0000
@@ -10,6 +10,7 @@
 MAKEFILE=	Makefile
 AR=		ar r
 ENGDIRS= ccgost
+ENGDIRS+= qat_engine
 
 RECURSIVE_MAKE=	[ -z "$(ENGDIRS)" ] || for i in $(ENGDIRS) ; do \
 		    (cd $$i && echo "making $$target in $(DIR)/$$i..." && \
@@ -139,6 +140,7 @@
 			-nostatic -staticloader -write e_$$l.c; \
 	done
 	(cd ccgost; $(MAKE) PERL=$(PERL) errors)
+	(cd qat_engine; $(MAKE) PERL=$(PERL) errors)
 
 tests:
 
diff -uBbw -Nr ../openssl-async/engines/qat_engine/Makefile ./engines/qat_engine/Makefile
--- ../openssl-async/engines/qat_engine/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/Makefile	2015-03-05 12:43:44.227956000 +0000
@@ -0,0 +1,406 @@
+ifndef CMN_ROOT
+CRYPTO_MEMORY_DRIVER=qat_mem
+else
+CRYPTO_MEMORY_DRIVER=qae_mem
+endif
+
+DIR=qat_engine
+TOP=../..
+CC=cc
+INCLUDES= -I../../include 
+CFLAG=-g
+ifeq ($(MAKEFILE),)
+MAKEFILE:= Makefile
+endif
+AR= ar r
+CFLAGS+= $(INCLUDES) $(CFLAG)
+
+ifeq ($(CRYPTO_MEMORY_DRIVER),qat_mem)
+CFLAGS+=-D USE_QAT_MEM -Iqat_mem
+endif
+ifeq ($(CRYPTO_MEMORY_DRIVER),qae_mem)
+CFLAGS+=-D USE_QAE_MEM
+INCLUDES+= -I./
+INCLUDES+= -I$(CMN_ROOT)
+endif
+
+# Include path for Intel QAT API
+ICP_API_DIR = ${ICP_ROOT}/quickassist/include
+ICP_SAL_API_DIR = $(ICP_ROOT)/quickassist/lookaside/access_layer/include
+
+ifdef ICP_API_PATH
+ICP_API_DIR = $(ICP_API_PATH)
+endif
+
+ifdef ICP_SAL_API_PATH 
+ICP_SAL_API_DIR = $(ICP_SAL_API_PATH)
+endif
+ICP_LAC_API_DIR = $(ICP_API_DIR)/lac
+
+INCLUDES += -I$(ICP_API_DIR) -I$(ICP_LAC_API_DIR) -I$(ICP_SAL_API_DIR) -I$(TOP)/crypto/ecdh -I$(TOP)/crypto/ecdsa -I$(TOP)/crypto/evp
+DRIVER=icp_qa_al
+ifdef WITH_CPA_MUX
+ICP_MUX_DIR=$(ICP_ROOT)/../QAT1.5/quickassist/include
+ICP_DC_DIR=$(ICP_API_DIR)/dc
+CFLAGS += -DWITH_CPA_MUX
+INCLUDES += -I$(ICP_MUX_DIR) -I$(ICP_DC_DIR)
+DRIVER=qat_mux
+endif
+
+QATLIBSRC_SHARED = e_qat.c\
+	 qat_utils.c\
+	 qat_ciphers.c\
+	 qat_chain.c\
+	 qat_digests.c\
+	 qat_rsa.c\
+	 qat_dsa.c\
+	 qat_dh.c\
+         qat_ecdh.c\
+         qat_ecdsa.c\
+	 qat_asym_common.c\
+	 qat_sym_common.c\
+	 e_qat_err.c\
+	 qat_parseconf.c\
+	 qat_rand.c\
+	 qat_prf.c
+
+QATLIBOBJ_SHARED = e_qat.o \
+qat_utils.o \
+qat_ciphers.o \
+qat_chain.o \
+qat_digests.o \
+qat_rsa.o \
+qat_dsa.o \
+qat_dh.o \
+qat_ecdh.o \
+qat_ecdsa.o \
+qat_asym_common.o \
+qat_sym_common.o \
+e_qat_err.o \
+qat_parseconf.o \
+qat_rand.o \
+qat_prf.o
+
+ifeq ($(CRYPTO_MEMORY_DRIVER),qat_mem)
+QATLIBSRC = $(QATLIBSRC_SHARED)  qae_mem_utils.c 
+QATLIBOBJ = $(QATLIBOBJ_SHARED)  qae_mem_utils.o 
+QATLIBMEMOBJ = qae_mem_utils.o 
+QATLIBMEM =qae_mem_utils
+QATLIBMEMDEPS=
+endif
+ifeq ($(CRYPTO_MEMORY_DRIVER),qae_mem)
+QATLIBSRC = $(QATLIBSRC_SHARED) qat_mem_drv_inf.c 
+QATLIBOBJ = $(QATLIBOBJ_SHARED) qat_mem_drv_inf.o 
+QATLIBMEMOBJ = qat_mem_drv_inf.o 
+QATLIBMEM = qat_mem_drv_inf
+QATLIBMEMDEPS=
+endif
+
+SRC=$(QATLIBSRC)
+QATLIBTARGET=$(TOP)/libcrypto.a
+ifdef ICP_BUILD_OUTPUT
+QATSHAREDLIBDEPS=-Wl,-rpath,$(ICP_BUILD_OUTPUT) -L$(ICP_BUILD_OUTPUT) -l$(DRIVER)_s
+else
+QATSHAREDLIBDEPS=-l$(DRIVER)_s
+endif
+
+ifeq ($(CRYPTO_MEMORY_DRIVER),qat_mem)
+QATSHAREDLIBDEPS += -L$(OPENSSL_ROOT)/engines/qat_engine/ -lqae_mem_utils
+endif
+ifeq ($(CRYPTO_MEMORY_DRIVER),qae_mem)
+QATSHAREDLIBDEPS += -Wl,-rpath,$(CMN_ROOT) -L$(CMN_ROOT) -lqae_mem_s
+QATSHAREDLIBDEPS += -L$(OPENSSL_ROOT)/engines/qat_engine/ -lqat_mem_drv_inf
+endif
+QATLIBNAME=qat
+
+.PHONEY: all lib 
+
+top: 
+	(cd $(TOP); $(MAKE) DIRS=engines EDIRS=$(DIR) sub_all)
+
+all: errors lib
+
+tags:
+	ctags $(SRC)
+
+errors:
+	perl ../../util/mkerr.pl -conf e_qat.ec -nostatic -write $(SRC)
+
+lib: $(QATLIBOBJ) $(QATLIBMEMOBJ)
+	@if [ -n "$(SHARED_LIBS)" ]; then \
+		$(MAKE) -f $(TOP)/Makefile.shared -e \
+			LIBNAME=$(QATLIBMEM) \
+			LIBEXTRAS='$(QATLIBMEMOBJ)' \
+			LIBDEPS='$(QATLIBMEMDEPS)' \
+			link_o.$(SHLIB_TARGET); \
+		$(MAKE) -f $(TOP)/Makefile.shared -e \
+                        LIBNAME=$(QATLIBNAME) \
+                        LIBEXTRAS='$(QATLIBOBJ_SHARED)' \
+                        LIBDEPS='$(QATSHAREDLIBDEPS)' \
+                        link_o.$(SHLIB_TARGET); \
+	else \
+		$(AR) $(QATLIBTARGET) $(QATLIBOBJ); \
+	fi
+
+
+install:
+	[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
+	@if [ -n "$(SHARED_LIBS)" ]; then \
+		set -e; \
+		echo installing $(QATLIBNAME); \
+		pfx=lib; \
+		if [ "$(PLATFORM)" != "Cygwin" ]; then \
+			case "$(CFLAGS)" in \
+			*DSO_BEOS*) sfx=".so";; \
+			*DSO_DLFCN*) sfx=".so";; \
+			*DSO_DL*) sfx=".sl";; \
+			*DSO_WIN32*) sfx="eay32.dll"; pfx=;; \
+			*) sfx=".bad";; \
+			esac; \
+			cp $${pfx}$(QATLIBNAME)$$sfx $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/engines/$${pfx}$(QATLIBNAME)$$sfx.new; \
+			cp $${pfx}$(QATLIBMEM)$$sfx $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$${pfx}$(QATLIBMEM)$$sfx.new; \
+		else \
+			sfx=".so"; \
+			cp cyg$(QATLIBNAME).dll $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/engines/$${pfx}$(QATLIBNAME)$$sfx.new; \
+			cp cyg$(QATLIBMEM).dll $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$${pfx}$(QATLIBMEM)$$sfx.new; \
+		fi; \
+		chmod 555 $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/engines/$${pfx}$(QATLIBNAME)$$sfx.new; \
+		mv -f $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/engines/$${pfx}$(QATLIBNAME)$$sfx.new $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/engines/$${pfx}$(QATLIBNAME)$$sfx; \
+		chmod 555 $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$${pfx}$(QATLIBMEM)$$sfx.new; \
+                mv -f $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$${pfx}$(QATLIBMEM)$$sfx.new $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$${pfx}$(QATLIBMEM)$$sfx; \
+	fi
+
+qae_mem_utils.o: qae_mem_utils.c
+	$(CC) $(CFLAGS) -c -o qae_mem_utils.o qae_mem_utils.c
+
+qat_mem_drv_inf.o: qat_mem_drv_inf.c
+	$(CC) $(CFLAGS) -c -o qat_mem_drv_inf.o qat_mem_drv_inf.c
+
+links:
+
+tests:
+
+depend: errors
+	@if [ -z "$(THIS)" ]; then \
+	    $(MAKE) -f $(TOP)/Makefile reflect THIS=$@; \
+	else \
+	    $(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(QATLIBSRC); \
+	fi
+
+files:
+
+
+
+lint:
+	lint -DLINT $(INCLUDES) $(SRC)>fluff
+
+dclean:
+	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) >Makefile.new
+	mv -f Makefile.new $(MAKEFILE)
+
+clean:
+	rm -f *.o *.obj lib tags core .pure .nfs* *.old *.bak fluff *.so *.sl *.dll e_qat_err.*
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+e_qat.o: ../../include/openssl/aes.h ../../include/openssl/asn1.h
+e_qat.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
+e_qat.o: ../../include/openssl/crypto.h ../../include/openssl/dh.h
+e_qat.o: ../../include/openssl/dsa.h ../../include/openssl/e_os2.h
+e_qat.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+e_qat.o: ../../include/openssl/ecdsa.h ../../include/openssl/engine.h
+e_qat.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+e_qat.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+e_qat.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
+e_qat.o: ../../include/openssl/ossl_typ.h ../../include/openssl/pkcs7.h
+e_qat.o: ../../include/openssl/rand.h ../../include/openssl/rsa.h
+e_qat.o: ../../include/openssl/safestack.h ../../include/openssl/sha.h
+e_qat.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+e_qat.o: ../../include/openssl/x509.h ../../include/openssl/x509_vfy.h e_qat.c
+e_qat.o: e_qat.h e_qat_err.h qae_mem_utils.h qat_ciphers.h qat_dh.h
+e_qat.o: qat_digests.h qat_dsa.h qat_ecdh.h qat_ecdsa.h qat_parseconf.h
+e_qat.o: qat_rand.h qat_rsa.h qat_sym_common.h qat_utils.h
+e_qat_err.o: ../../include/openssl/bio.h ../../include/openssl/crypto.h
+e_qat_err.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
+e_qat_err.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
+e_qat_err.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+e_qat_err.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+e_qat_err.o: ../../include/openssl/symhacks.h e_qat_err.c e_qat_err.h
+qae_mem_utils.o: qae_mem_utils.c qae_mem_utils.h
+qat_asym_common.o: ../../include/openssl/aes.h ../../include/openssl/asn1.h
+qat_asym_common.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
+qat_asym_common.o: ../../include/openssl/buffer.h
+qat_asym_common.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+qat_asym_common.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+qat_asym_common.o: ../../include/openssl/ecdsa.h ../../include/openssl/engine.h
+qat_asym_common.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+qat_asym_common.o: ../../include/openssl/obj_mac.h
+qat_asym_common.o: ../../include/openssl/objects.h
+qat_asym_common.o: ../../include/openssl/opensslconf.h
+qat_asym_common.o: ../../include/openssl/opensslv.h
+qat_asym_common.o: ../../include/openssl/ossl_typ.h
+qat_asym_common.o: ../../include/openssl/pkcs7.h
+qat_asym_common.o: ../../include/openssl/safestack.h
+qat_asym_common.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+qat_asym_common.o: ../../include/openssl/symhacks.h
+qat_asym_common.o: ../../include/openssl/x509.h
+qat_asym_common.o: ../../include/openssl/x509_vfy.h e_qat.h qae_mem_utils.h
+qat_asym_common.o: qat_asym_common.c qat_asym_common.h qat_ciphers.h
+qat_asym_common.o: qat_digests.h qat_sym_common.h qat_utils.h
+qat_chain.o: ../../include/openssl/aes.h ../../include/openssl/asn1.h
+qat_chain.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
+qat_chain.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+qat_chain.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+qat_chain.o: ../../include/openssl/ecdsa.h ../../include/openssl/engine.h
+qat_chain.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+qat_chain.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+qat_chain.o: ../../include/openssl/objects.h
+qat_chain.o: ../../include/openssl/opensslconf.h
+qat_chain.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+qat_chain.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
+qat_chain.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+qat_chain.o: ../../include/openssl/symhacks.h ../../include/openssl/tls1.h
+qat_chain.o: ../../include/openssl/x509.h ../../include/openssl/x509_vfy.h
+qat_chain.o: e_qat.h e_qat_err.h qae_mem_utils.h qat_chain.c qat_chain.h
+qat_chain.o: qat_ciphers.h qat_digests.h qat_sym_common.h qat_utils.h
+qat_ciphers.o: ../../include/openssl/aes.h ../../include/openssl/asn1.h
+qat_ciphers.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
+qat_ciphers.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+qat_ciphers.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+qat_ciphers.o: ../../include/openssl/ecdsa.h ../../include/openssl/engine.h
+qat_ciphers.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+qat_ciphers.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+qat_ciphers.o: ../../include/openssl/objects.h
+qat_ciphers.o: ../../include/openssl/opensslconf.h
+qat_ciphers.o: ../../include/openssl/opensslv.h
+qat_ciphers.o: ../../include/openssl/ossl_typ.h ../../include/openssl/pkcs7.h
+qat_ciphers.o: ../../include/openssl/safestack.h ../../include/openssl/sha.h
+qat_ciphers.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+qat_ciphers.o: ../../include/openssl/tls1.h ../../include/openssl/x509.h
+qat_ciphers.o: ../../include/openssl/x509_vfy.h e_qat.h e_qat_err.h
+qat_ciphers.o: qae_mem_utils.h qat_chain.h qat_ciphers.c qat_ciphers.h
+qat_ciphers.o: qat_digests.h qat_sym_common.h qat_utils.h
+qat_dh.o: ../../include/openssl/bio.h ../../include/openssl/crypto.h
+qat_dh.o: ../../include/openssl/dh.h ../../include/openssl/e_os2.h
+qat_dh.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
+qat_dh.o: ../../include/openssl/ossl_typ.h ../../include/openssl/safestack.h
+qat_dh.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+qat_dh.o: qae_mem_utils.h qat_asym_common.h qat_dh.c qat_dh.h qat_utils.h
+qat_digests.o: ../../include/openssl/aes.h ../../include/openssl/asn1.h
+qat_digests.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
+qat_digests.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+qat_digests.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+qat_digests.o: ../../include/openssl/ecdsa.h ../../include/openssl/engine.h
+qat_digests.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+qat_digests.o: ../../include/openssl/md5.h ../../include/openssl/obj_mac.h
+qat_digests.o: ../../include/openssl/objects.h
+qat_digests.o: ../../include/openssl/opensslconf.h
+qat_digests.o: ../../include/openssl/opensslv.h
+qat_digests.o: ../../include/openssl/ossl_typ.h ../../include/openssl/pkcs7.h
+qat_digests.o: ../../include/openssl/safestack.h ../../include/openssl/sha.h
+qat_digests.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+qat_digests.o: ../../include/openssl/x509.h ../../include/openssl/x509_vfy.h
+qat_digests.o: e_qat.h e_qat_err.h qae_mem_utils.h qat_ciphers.h qat_digests.c
+qat_digests.o: qat_digests.h qat_sym_common.h qat_utils.h
+qat_dsa.o: ../../include/openssl/bio.h ../../include/openssl/crypto.h
+qat_dsa.o: ../../include/openssl/dsa.h ../../include/openssl/e_os2.h
+qat_dsa.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
+qat_dsa.o: ../../include/openssl/ossl_typ.h ../../include/openssl/safestack.h
+qat_dsa.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+qat_dsa.o: qat_asym_common.h qat_dsa.c qat_dsa.h qat_utils.h
+qat_ecdh.o: ../../crypto/ecdh/ech_locl.h ../../include/openssl/aes.h
+qat_ecdh.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+qat_ecdh.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
+qat_ecdh.o: ../../include/openssl/e_os2.h ../../include/openssl/ec.h
+qat_ecdh.o: ../../include/openssl/ecdh.h ../../include/openssl/ecdsa.h
+qat_ecdh.o: ../../include/openssl/engine.h ../../include/openssl/err.h
+qat_ecdh.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+qat_ecdh.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+qat_ecdh.o: ../../include/openssl/opensslconf.h
+qat_ecdh.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+qat_ecdh.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
+qat_ecdh.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+qat_ecdh.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
+qat_ecdh.o: ../../include/openssl/x509_vfy.h e_qat.h e_qat_err.h
+qat_ecdh.o: qae_mem_utils.h qat_asym_common.h qat_ciphers.h qat_digests.h
+qat_ecdh.o: qat_ecdh.c qat_ecdh.h qat_sym_common.h qat_utils.h
+qat_ecdsa.o: ../../crypto/ecdsa/ecs_locl.h ../../include/openssl/aes.h
+qat_ecdsa.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+qat_ecdsa.o: ../../include/openssl/bn.h ../../include/openssl/buffer.h
+qat_ecdsa.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+qat_ecdsa.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+qat_ecdsa.o: ../../include/openssl/ecdsa.h ../../include/openssl/engine.h
+qat_ecdsa.o: ../../include/openssl/err.h ../../include/openssl/evp.h
+qat_ecdsa.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
+qat_ecdsa.o: ../../include/openssl/objects.h
+qat_ecdsa.o: ../../include/openssl/opensslconf.h
+qat_ecdsa.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+qat_ecdsa.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
+qat_ecdsa.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+qat_ecdsa.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
+qat_ecdsa.o: ../../include/openssl/x509_vfy.h e_qat.h e_qat_err.h
+qat_ecdsa.o: qae_mem_utils.h qat_asym_common.h qat_ciphers.h qat_digests.h
+qat_ecdsa.o: qat_ecdsa.c qat_ecdsa.h qat_sym_common.h qat_utils.h
+qat_parseconf.o: qat_parseconf.c qat_parseconf.h qat_utils.h
+qat_rand.o: ../../include/openssl/aes.h ../../include/openssl/asn1.h
+qat_rand.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
+qat_rand.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+qat_rand.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+qat_rand.o: ../../include/openssl/ecdsa.h ../../include/openssl/engine.h
+qat_rand.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+qat_rand.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+qat_rand.o: ../../include/openssl/opensslconf.h
+qat_rand.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+qat_rand.o: ../../include/openssl/pkcs7.h ../../include/openssl/rand.h
+qat_rand.o: ../../include/openssl/safestack.h ../../include/openssl/sha.h
+qat_rand.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+qat_rand.o: ../../include/openssl/x509.h ../../include/openssl/x509_vfy.h
+qat_rand.o: e_qat.h qae_mem_utils.h qat_ciphers.h qat_digests.h qat_rand.c
+qat_rand.o: qat_rand.h qat_sym_common.h qat_utils.h
+qat_rsa.o: ../../include/openssl/aes.h ../../include/openssl/asn1.h
+qat_rsa.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
+qat_rsa.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+qat_rsa.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+qat_rsa.o: ../../include/openssl/ecdsa.h ../../include/openssl/engine.h
+qat_rsa.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+qat_rsa.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+qat_rsa.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
+qat_rsa.o: ../../include/openssl/ossl_typ.h ../../include/openssl/pkcs7.h
+qat_rsa.o: ../../include/openssl/rsa.h ../../include/openssl/safestack.h
+qat_rsa.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+qat_rsa.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
+qat_rsa.o: ../../include/openssl/x509_vfy.h e_qat.h e_qat_err.h qae_mem_utils.h
+qat_rsa.o: qat_asym_common.h qat_ciphers.h qat_digests.h qat_rsa.c qat_rsa.h
+qat_rsa.o: qat_sym_common.h qat_utils.h
+qat_sym_common.o: ../../include/openssl/aes.h ../../include/openssl/asn1.h
+qat_sym_common.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
+qat_sym_common.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+qat_sym_common.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+qat_sym_common.o: ../../include/openssl/ecdsa.h ../../include/openssl/engine.h
+qat_sym_common.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+qat_sym_common.o: ../../include/openssl/obj_mac.h
+qat_sym_common.o: ../../include/openssl/objects.h
+qat_sym_common.o: ../../include/openssl/opensslconf.h
+qat_sym_common.o: ../../include/openssl/opensslv.h
+qat_sym_common.o: ../../include/openssl/ossl_typ.h
+qat_sym_common.o: ../../include/openssl/pkcs7.h
+qat_sym_common.o: ../../include/openssl/safestack.h ../../include/openssl/sha.h
+qat_sym_common.o: ../../include/openssl/stack.h
+qat_sym_common.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
+qat_sym_common.o: ../../include/openssl/x509_vfy.h e_qat.h qae_mem_utils.h
+qat_sym_common.o: qat_ciphers.h qat_digests.h qat_sym_common.c qat_sym_common.h
+qat_sym_common.o: qat_utils.h
+qat_utils.o: ../../include/openssl/aes.h ../../include/openssl/asn1.h
+qat_utils.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
+qat_utils.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+qat_utils.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+qat_utils.o: ../../include/openssl/ecdsa.h ../../include/openssl/engine.h
+qat_utils.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+qat_utils.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
+qat_utils.o: ../../include/openssl/opensslconf.h
+qat_utils.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+qat_utils.o: ../../include/openssl/pkcs7.h ../../include/openssl/safestack.h
+qat_utils.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
+qat_utils.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
+qat_utils.o: ../../include/openssl/x509_vfy.h e_qat.h qat_ciphers.h
+qat_utils.o: qat_digests.h qat_sym_common.h qat_utils.c qat_utils.h
diff -uBbw -Nr ../openssl-async/engines/qat_engine/e_qat.c ./engines/qat_engine/e_qat.c
--- ../openssl-async/engines/qat_engine/e_qat.c	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/e_qat.c	2015-03-05 12:43:44.228959000 +0000
@@ -0,0 +1,1319 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file e_qat.c
+ *
+ * This file provides a OpenSSL engine for the  quick assist API
+ *
+ *****************************************************************************/
+
+/* macros defined to allow use of the cpu get and set affinity functions */
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+
+#ifndef __USE_GNU
+#define __USE_GNU
+#endif
+
+/* Defines */
+#ifdef USE_QAT_MEM
+#define QAT_DEV "/dev/qat_mem"
+#endif
+#ifdef USE_QAE_MEM
+#define QAT_DEV "/dev/qae_mem"
+#endif
+
+#define POLL_PERIOD_IN_NS 10000
+/* The number of retries of the nanosleep if it gets interrupted
+   during waiting between polling. */
+#define QAT_CRYPTO_NUM_POLLING_RETRIES (5)
+
+/* The number of seconds to wait for a response back after
+   submitting a request before raising an error. */
+#define QAT_CRYPTO_RESPONSE_TIMEOUT (5)
+
+/* Algorithm registration options*/
+
+/* Standard Includes */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <pthread.h>
+#include <unistd.h>
+#include <ctype.h>
+
+/* Local Includes */
+#include "qat_ciphers.h"
+#include "qat_digests.h"
+#include "qat_rsa.h"
+#include "qat_dsa.h"
+#include "qat_dh.h"
+#include "qat_ecdh.h"
+#include "qat_ecdsa.h"
+#include "e_qat.h"
+#include "qat_utils.h"
+#include "e_qat_err.h"
+#include "qat_rand.h"
+#ifdef OPENSSL_QAT_ASYNCH
+#include "qat_prf.h"
+#endif
+
+/* OpenSSL Includes */
+
+/* QAT includes */
+#ifdef USE_QAT_MEM
+#include "qae_mem_utils.h"
+#endif
+#ifdef USE_QAE_MEM
+#include "qat_mem_drv_inf.h"
+#endif
+#include "cpa.h"
+#include "cpa_cy_im.h"
+#include "cpa_types.h"
+#include "icp_sal_user.h"
+#include "icp_sal_poll.h"
+#include "qat_parseconf.h"
+
+#define likely(x)   __builtin_expect (!!(x), 1)
+#define unlikely(x) __builtin_expect (!!(x), 0)
+
+/* Forward Declarations */
+static CpaPhysicalAddr realVirtualToPhysical(void *virtualAddr);
+
+/* Use the pthread yield version of sendpoll */
+/*#define USE_PTHREAD_YIELD*/
+
+#ifndef USE_PTHREAD_YIELD
+int ns_handler(struct timespec* reqTime);
+#endif
+
+static int qat_engine_finish(ENGINE * e);
+
+/* Qat engine id declaration */
+static const char *engine_qat_id = "qat";
+static const char *engine_qat_name =
+    "Reference implementation of QAT crypto engine";
+
+/* Globals */
+CpaInstanceHandle *qatInstanceHandles = NULL;
+static pthread_key_t qatInstanceForThread;
+pthread_t *icp_polling_threads;
+static int keep_polling = 1;
+static int enable_external_polling = 0;
+Cpa16U numInstances = 0;
+int qatPerformOpRetries = 0;
+static int currInst = 0;
+static pthread_mutex_t qat_instance_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+char *ICPConfigSectionName_libcrypto = "SHIM";
+
+static CpaVirtualToPhysical myVirtualToPhysical = realVirtualToPhysical;
+static int zero_copy_memory_mode = 0;
+static int qat_inited = 0;
+static useconds_t qat_poll_interval = POLL_PERIOD_IN_NS;
+static int qat_msg_retry_count = QAT_CRYPTO_NUM_POLLING_RETRIES;
+
+/*Invoked by Client. Used to set the number of retry libcrypto should poll QAT untill it receives success*/
+void setQatMsgRetryCount(int iRetryCount)
+{
+    if ((iRetryCount >= -1) && (iRetryCount <= 100000))
+    {
+        qat_msg_retry_count = iRetryCount;
+    }
+    else
+    {
+        fprintf(stderr, "The Message retry count value is out of range, using default value %d\n", qat_msg_retry_count);
+    }
+
+}
+int getQatMsgRetryCount()
+{
+    return qat_msg_retry_count;
+}
+
+/*Invoked by Client. Used to set the interval between each poll retry*/
+void setQatPollInterval(unsigned long int ulPollInterval)
+{
+    if ((ulPollInterval >= 1) && (ulPollInterval <= 1000000))
+    {
+        qat_poll_interval = (useconds_t) ulPollInterval;
+    }
+    else
+    {
+        fprintf(stderr, "The polling interval value is out of range, using default value %d\n", qat_poll_interval);
+    }
+
+}
+useconds_t getQatPollInterval()
+{
+    return qat_poll_interval;
+}
+
+int isZeroCopy()
+{
+    return (zero_copy_memory_mode);
+}
+
+void enableZeroCopy(){
+    CpaStatus status;
+
+    status = CRYPTO_set_mem_ex_functions(qaeCryptoMemAlloc, qaeCryptoMemRealloc, qaeCryptoMemFree);
+    if (CPA_FALSE == status)
+    {
+        DEBUG("%s: CRYPTO_set_mem_functions failed\n", __func__);
+        /* Don't abort. This may be tried from a few places and will only
+           succeed the first time. */
+    }
+    else
+    {
+        DEBUG("%s: CRYPTO_set_mem_functions succeeded\n", __func__);
+    }
+
+    /*  If over-riding OPENSSL_malloc then buffers
+     *  passed will already be pinned memory
+     *  so we switch to zero copy mode
+     */
+    zero_copy_memory_mode = 1;
+}
+
+/******************************************************************************
+* function:
+*         incr_curr_inst(void)
+*
+* description:
+*   Increment the logical Cy instance number to use for the next operation.
+*
+******************************************************************************/
+static inline void incr_curr_inst(void)
+{
+    pthread_mutex_lock(&qat_instance_mutex);
+    currInst = (currInst + 1) % numInstances;
+    pthread_mutex_unlock(&qat_instance_mutex);
+}
+
+/******************************************************************************
+* function:
+*         get_next_inst(void)
+*
+* description:
+*   Return the next instance handle to use for an operation.
+*
+******************************************************************************/
+CpaInstanceHandle get_next_inst(void)
+{
+    CpaInstanceHandle instanceHandle;
+
+    if (1 == enable_external_polling ||
+	(instanceHandle = pthread_getspecific(qatInstanceForThread)) == NULL)
+    {
+
+        if (qatInstanceHandles)
+        {
+            instanceHandle = qatInstanceHandles[currInst];
+            incr_curr_inst();
+        }
+        else
+        {
+             instanceHandle = NULL;
+        }
+    }
+    return instanceHandle;
+}
+
+/******************************************************************************
+* function:
+*         qat_set_instance_for_thread(long instanceNum)
+*
+* @param instanceNum [IN] - logical instance number
+*
+* description:
+*   Bind the current thread to a particular logical Cy instance. Note that if
+*   instanceNum is greater than the number of configured instances, the
+*   modulus operation is used.
+*
+******************************************************************************/
+void qat_set_instance_for_thread(long instanceNum)
+{
+    int rc;
+
+    if ((rc =
+         pthread_setspecific(qatInstanceForThread,
+                             qatInstanceHandles[instanceNum %
+                                                numInstances])) != 0)
+    {
+        fprintf(stderr, "pthread_setspecific: %s\n", strerror(rc));
+        return;
+    }
+}
+
+/******************************************************************************
+* function:
+*         initOpDone(struct op_done *opDone)
+*
+* @param opDone [IN] - pointer to op done callback structure
+*
+* description:
+*   Initialise the QAT operation "done" callback structure.
+*
+******************************************************************************/
+void initOpDone(struct op_done *opDone)
+{
+    int sts = 1;
+
+    if (!opDone) {
+         return;
+    }
+
+    sts = pthread_mutex_init(&(opDone->mutex), NULL);
+    if (sts != 0) {
+        fprintf(stderr, "pthread_mutex_init failed - sts = %d. Continuing anyway.\n", sts);
+    }
+    sts = pthread_cond_init(&(opDone->cond), NULL);
+    if (sts != 0) {
+        fprintf(stderr, "pthread_cond_init failed - sts = %d. Continuing anyway.\n", sts);
+    }
+    opDone->flag = 0;
+    opDone->verifyResult = CPA_FALSE;
+}
+
+/******************************************************************************
+* function:
+*         cleanupOpDone(struct op_done *opDone)
+*
+* @param opDone [IN] - pointer to op done callback structure
+*
+* description:
+*   Cleanup the thread and mutex used in the QAT operation "done" callback.
+*
+******************************************************************************/
+void cleanupOpDone(struct op_done *opDone)
+{
+    int sts = 1;
+
+    if (!opDone) {
+         return;
+    }
+
+    sts = pthread_mutex_destroy(&(opDone->mutex));
+    if (sts != 0) {
+        fprintf(stderr, "pthread_mutex_destroy failed - sts = %d. Continuing anyway.\n", sts);
+    }
+    sts = pthread_cond_destroy(&(opDone->cond));
+    if (sts != 0) {
+        fprintf(stderr, "pthread_cond_destroy failed - sts = %d. Continuing anyway.\n", sts);
+    }
+}
+
+/******************************************************************************
+* function:
+*         waitForOpToComplete(struct op_done *opDone)
+*
+* @param opdone [IN] - pointer to op done callback structure
+*
+* description:
+*   Wait on a mutex lock with a timeout for cpaCySymPerformOp to complete.
+*
+* @retval int - 0 for success, 1 if error or timed out
+*
+******************************************************************************/
+int waitForOpToComplete(struct op_done *opDone)
+{
+	struct timespec ts;
+	int rc=1;
+	int timer_rc = 0;
+
+	if (!opDone) {
+		return rc;
+	}
+
+    rc = pthread_mutex_lock(&(opDone->mutex));
+    if (rc != 0) {
+        fprintf(stderr, "pthread_mutex_lock failed - rc = %d.\n", rc);
+		QATerr(QAT_F_WAITFOROPTOCOMPLETE, ERR_R_INTERNAL_ERROR);
+		return 1;
+    }
+
+    clock_gettime(CLOCK_REALTIME, &ts);
+    ts.tv_sec += QAT_CRYPTO_RESPONSE_TIMEOUT;
+    while (!opDone->flag)
+    {
+		timer_rc = pthread_cond_timedwait(&(opDone->cond), &(opDone->mutex), &ts);
+		if (timer_rc != 0)
+		{
+			WARN("pthread_cond_timedwait: %s\n", strerror(timer_rc));
+			QATerr(QAT_F_WAITFOROPTOCOMPLETE, QAT_R_PTHREAD_COND_TIMEDWAIT);
+			break;
+		}
+    }
+    rc = pthread_mutex_unlock(&(opDone->mutex));
+    if (rc != 0) {
+		fprintf(stderr, "pthread_mutex_unlock failed - rc = %d\n", rc);
+		QATerr(QAT_F_WAITFOROPTOCOMPLETE, ERR_R_INTERNAL_ERROR);
+    }
+	if (rc || timer_rc)
+		return 1;
+	return 0;
+}
+
+#if 0
+/******************************************************************************
+* function:
+*         qatGetNUMANodeId(CpaInstanceHandle* handle)
+*
+* @param handle [IN] - pointer to an instance handle
+*
+* description:
+*   Function that maps an Instance Handle to a NUMA Node Id.
+*
+* @retval Cpa32U - the NUME nodeId the instance is attached to
+*
+******************************************************************************/
+static Cpa32U qatGetNUMANodeId(CpaInstanceHandle handle)
+{
+    CpaStatus status = CPA_STATUS_FAIL;
+    CpaInstanceInfo2 pInstanceInfo2;
+
+	if (NULL == handle)
+    {
+	    WARN("Invalid Instance Handle\n");
+		return 0;
+    }
+
+    status = cpaCyInstanceGetInfo2(handle, &pInstanceInfo2);
+    if(unlikely(CPA_STATUS_SUCCESS != status))
+    {
+        WARN("Unable to get Node affinity\n");
+        return 0;
+    }
+
+    return pInstanceInfo2.nodeAffinity;
+}
+#endif
+
+/******************************************************************************
+* function:
+*         qat_crypto_callbackFn(void *callbackTag, CpaStatus status,
+*                        const CpaCySymOp operationType, void *pOpData,
+*                        CpaBufferList * pDstBuffer, CpaBoolean verifyResult)
+*
+
+* @param pCallbackTag  [IN] -  Opaque value provided by user while making
+*                              individual function call. Cast to op_done.
+* @param status        [IN] -  Status of the operation.
+* @param operationType [IN] -  Identifies the operation type requested.
+* @param pOpData       [IN] -  Pointer to structure with input parameters.
+* @param pDstBuffer    [IN] -  Destination buffer to hold the data output.
+* @param verifyResult  [IN] -  Used to verify digest result.
+*
+* description:
+*   Callback function used by cpaCySymPerformOp to indicate completion.
+*
+******************************************************************************/
+void qat_crypto_callbackFn(void *callbackTag, CpaStatus status,
+                    const CpaCySymOp operationType, void *pOpData,
+                    CpaBufferList * pDstBuffer, CpaBoolean verifyResult)
+{
+    struct op_done *opDone = (struct op_done *)callbackTag;
+    int sts = 1;
+
+    if (!opDone) {
+         return;
+    }
+
+    DEBUG("e_qat.%s: status %d verifyResult %d\n", __func__, status,
+          verifyResult);
+    sts = pthread_mutex_lock(&(opDone->mutex));
+    if (sts != 0) {
+        fprintf(stderr, "pthread_mutex_lock failed - sts = %d. Continuing anyway.\n", sts);
+    }
+    opDone->flag = 1;
+    opDone->verifyResult = verifyResult;
+    sts = pthread_cond_signal(&(opDone->cond));
+    if (sts != 0) {
+        fprintf(stderr, "pthread_cond_signal failed - sts = %d. Continuing anyway.\n", sts);
+    }
+    sts = pthread_mutex_unlock(&(opDone->mutex));
+    if (sts != 0) {
+        fprintf(stderr, "pthread_mutex_unlock failed - sts = %d. Continuing anyway.\n", sts);
+    }
+}
+
+/******************************************************************************
+* function:
+*         CpaStatus myPerformOp(const CpaInstanceHandle  instanceHandle,
+*                     void *                     pCallbackTag,
+*                     const CpaCySymOpData      *pOpData,
+*                     const CpaBufferList       *pSrcBuffer,
+*                     CpaBufferList             *pDstBuffer,
+*                     CpaBoolean                *pVerifyResult)
+*
+* @param ih [IN] - Instance handle
+* @param instanceHandle [IN]  - Instance handle
+* @param pCallbackTag   [IN]  - Pointer to op_done struct
+* @param pOpData        [IN]  - Operation parameters
+* @param pSrcBuffer     [IN]  - Source buffer list
+* @param pDstBuffer     [OUT] - Destination buffer list
+* @param pVerifyResult  [OUT] - Whether hash verified or not
+*
+* description:
+*   Wrapper around cpaCySymPerformOp which handles retries for us.
+*
+******************************************************************************/
+CpaStatus myPerformOp(const CpaInstanceHandle instanceHandle,
+                      void *pCallbackTag,
+                      const CpaCySymOpData * pOpData,
+                      const CpaBufferList * pSrcBuffer,
+                      CpaBufferList * pDstBuffer, CpaBoolean * pVerifyResult)
+{
+    CpaStatus status;
+    useconds_t ulPollInterval = getQatPollInterval();
+    int iMsgRetry = getQatMsgRetryCount();
+    unsigned int uiRetry = 0;
+    do
+    {
+        status = cpaCySymPerformOp(instanceHandle,
+                                   pCallbackTag,
+                                   pOpData,
+                                   pSrcBuffer, pDstBuffer, pVerifyResult);
+        if (status == CPA_STATUS_RETRY)
+        {
+            qatPerformOpRetries++;
+            pthread_yield();
+            if( uiRetry >= iMsgRetry && iMsgRetry != QAT_INFINITE_MAX_NUM_RETRIES)
+            {
+                break;
+            }
+            uiRetry++;
+            usleep(ulPollInterval + (uiRetry % QAT_RETRY_BACKOFF_MODULO_DIVISOR));
+        }
+    }
+    while (status == CPA_STATUS_RETRY);
+    return status;
+}
+
+#ifdef USE_PTHREAD_YIELD
+/******************************************************************************
+* function:
+*         void *sendPoll(void *ih)
+*
+* @param ih [IN] - Instance handle
+*
+* description:
+*   Poll the QAT instances every 2 microseconds.
+*
+******************************************************************************/
+static void *sendPoll(void *ih)
+{
+    CpaStatus status = 0;
+    CpaInstanceHandle instanceHandle;
+
+    instanceHandle = (CpaInstanceHandle) ih;
+    if (NULL == instanceHandle)
+    {
+        WARN("WARNING sendPoll - instanceHandle is NULL\n");
+        return NULL;
+    }
+
+    while (keep_polling)
+    {
+        /* Poll for 0 means process all packets on the instance */
+        status = icp_sal_CyPollInstance(instanceHandle, 0);
+
+        if (likely(CPA_STATUS_SUCCESS == status))
+        {
+            /* Do nothing */
+        }
+        else if (CPA_STATUS_RETRY == status)
+        {
+            pthread_yield();
+        }
+        else
+        {
+            WARN("WARNING icp_sal_CyPollInstance returned status %d\n", status);
+        }
+    }
+
+    return NULL;
+}
+#else
+/******************************************************************************
+* function:
+*         void *sendPoll_ns(void *ih)
+*
+* @param ih [IN] - Instance handle
+*
+* description:
+*   Poll the QAT instances (nanosleep version)
+*       NB: Delay in this function is set by default at runtime by pulling a value
+*       in nsecs from /etc/send_poll_interval. If no such file is available,
+*       default falls through to POLL_PERIOD_IN_NS.
+*
+******************************************************************************/
+static void *sendPoll_ns(void *ih)
+{
+    CpaStatus status = 0;
+    CpaInstanceHandle instanceHandle;
+    struct timespec reqTime = {0};
+    struct timespec remTime = {0};
+    unsigned int retry_count = 0; /*to prevent too much time drift*/
+
+    instanceHandle = (CpaInstanceHandle) ih;
+    if (NULL == instanceHandle)
+    {
+        WARN("WARNING sendPoll_ns - instanceHandle is NULL\n");
+        return NULL;
+    }
+
+    while (keep_polling)
+    {
+        reqTime.tv_nsec = getQatPollInterval();
+        /* Poll for 0 means process all packets on the instance */
+        status = icp_sal_CyPollInstance(instanceHandle, 0);
+
+        if (likely(CPA_STATUS_SUCCESS == status || CPA_STATUS_RETRY == status))
+        {
+            /* Do nothing */
+        }
+        else
+        {
+            WARN("WARNING icp_sal_CyPollInstance returned status %d\n", status);
+        }
+
+        retry_count = 0;
+        do {
+            retry_count++;
+            nanosleep(&reqTime, &remTime);
+			reqTime.tv_sec = remTime.tv_sec;
+            reqTime.tv_nsec = remTime.tv_nsec;
+            if(unlikely((errno < 0) && (EINTR != errno)))
+            {
+                WARN("WARNING nanosleep system call failed: errno %i\n", errno);
+                break;
+            }
+        }
+        while ((retry_count <= QAT_CRYPTO_NUM_POLLING_RETRIES) && (EINTR == errno));
+    }
+
+    return NULL;
+}
+
+#endif
+
+static CpaStatus poll_instances(void)
+{
+    unsigned int poll_loop;
+    CpaStatus internal_status = CPA_STATUS_SUCCESS,
+              ret_status = CPA_STATUS_SUCCESS;
+
+    if (qatInstanceHandles != NULL)
+    {
+        for(poll_loop = 0; poll_loop < numInstances; poll_loop++)
+        {
+            if (qatInstanceHandles[poll_loop] != NULL)
+            {
+                internal_status = icp_sal_CyPollInstance(qatInstanceHandles[poll_loop], 0);
+                if (CPA_STATUS_SUCCESS == internal_status)
+                {
+                    /* Do nothing */
+                }
+                else if (CPA_STATUS_RETRY == internal_status)
+                {
+                     ret_status = internal_status;
+                }
+                else
+                {
+                    WARN("WARNING icp_sal_CyPollInstance returned status %d\n", internal_status);
+	            ret_status = internal_status;
+                    break;
+                }
+            }
+        }
+    }
+    else
+    {
+       WARN("WARNING qatInstanceHandles == NULL\n");
+       ret_status = CPA_STATUS_FAIL;
+    }
+
+    return ret_status;
+}
+
+/******************************************************************************
+* function:
+*         realVirtualToPhysical(void *virtualAddr)
+*
+* @param virtualAddr [IN] - Virtual address.
+*
+* description:
+*   Translates virtual address to hardware physical address. See the qae_mem
+*   module for more details. The virtual to physical translator is required
+*   by the QAT hardware to map from virtual addresses to physical locations
+*   in pinned memory.
+*
+*   This function is designed to work with the allocator defined in
+*   qae_mem_utils.c and qat_mem/qat_mem.c
+*
+******************************************************************************/
+static CpaPhysicalAddr realVirtualToPhysical(void *virtualAddr)
+{
+    return qaeCryptoMemV2P(virtualAddr);
+}
+
+/******************************************************************************
+* function:
+*         setMyVirtualToPhysical(CpaVirtualToPhysical fp)
+*
+* @param CpaVirtualToPhysical [IN] - Function pointer to translation function
+*
+* description:
+*   External API to allow users to specify their own virtual to physical
+*   address translation function.
+*
+******************************************************************************/
+void setMyVirtualToPhysical(CpaVirtualToPhysical fp)
+{
+    /*  If user specifies a V2P function then
+     *  the user is taking responsibility for
+     *  allocating and freeing pinned memory
+     *  so we switch to zero_copy_memory mode
+     */
+    if (!qat_inited)
+    {
+        myVirtualToPhysical = fp;
+        zero_copy_memory_mode = 1;
+    }
+    else
+        WARN("%s: can't set virtual to physical translation function after initialisation\n", __func__);
+}
+
+
+/******************************************************************************
+* function:
+*         qat_engine_init(ENGINE *e)
+*
+* @param e [IN] - OpenSSL engine pointer
+*
+* description:
+*   Qat engine init function, associated with Crypto memory setup
+*   and cpaStartInstance setups.
+******************************************************************************/
+static int qat_engine_init(ENGINE * e)
+{
+    int instNum, err, checkLimitStatus;
+    CpaStatus status = CPA_STATUS_SUCCESS;
+    CpaBoolean limitDevAccess = CPA_FALSE;
+
+    DEBUG("[%s] ---- Engine Initing\n\n", __func__);
+	CRYPTO_INIT_QAT_LOG();
+
+    if (0 == enable_external_polling &&
+	   (err = pthread_key_create(&qatInstanceForThread, NULL)) != 0)
+    {
+        fprintf(stderr, "pthread_key_create: %s\n", strerror(err));
+        return 0;
+    }
+
+    checkLimitStatus = checkLimitDevAccessValue((int *)&limitDevAccess, ICPConfigSectionName_libcrypto);
+    if (!checkLimitStatus){
+        WARN("Assuming LimitDevAccess = 0\n");
+    }
+
+    /* Initialise the QAT hardware */
+    if (CPA_STATUS_SUCCESS != icp_sal_userStartMultiProcess(ICPConfigSectionName_libcrypto,limitDevAccess))
+    {
+       WARN("icp_sal_userStart failed\n");
+       return 0;
+    }
+
+    /* Get the number of available instances */
+    status = cpaCyGetNumInstances(&numInstances);
+    if (CPA_STATUS_SUCCESS != status)
+    {
+        WARN("cpaCyGetNumInstances failed, status=%d\n", status);
+		qat_engine_finish(e);
+        return 0;
+    }
+    if (!numInstances)
+    {
+        WARN("No crypto instances found\n");
+		qat_engine_finish(e);
+        return 0;
+    }
+
+    DEBUG("%s: %d Cy instances got\n", __func__, numInstances);
+
+    /* Allocate memory for the instance handle array */
+    qatInstanceHandles =
+        (CpaInstanceHandle *) OPENSSL_malloc(((int) numInstances) *
+                                             sizeof(CpaInstanceHandle));
+    if (NULL == qatInstanceHandles)
+    {
+        WARN("OPENSSL_malloc() failed for instance handles.\n");
+		qat_engine_finish(e);
+        return 0;
+    }
+
+    /* Allocate memory for the polling threads */
+    if (0 == enable_external_polling)
+    {
+        icp_polling_threads =
+            (pthread_t *) OPENSSL_malloc(((int) numInstances) * sizeof(pthread_t));
+        if (NULL == icp_polling_threads)
+        {
+            WARN("OPENSSL_malloc() failed for icp_polling_threads.\n");
+		    qat_engine_finish(e);
+            return 0;
+        }
+    }
+
+    /* Get the Cy instances */
+    status = cpaCyGetInstances(numInstances, qatInstanceHandles);
+    if (CPA_STATUS_SUCCESS != status)
+    {
+        WARN("cpaCyGetInstances failed, status=%d\n", status);
+		qat_engine_finish(e);
+        return 0;
+    }
+
+    /* Set translation function and start each instance */
+    for (instNum = 0; instNum < numInstances; instNum++)
+    {
+        /* Set the address translation function */
+        status = cpaCySetAddressTranslation(qatInstanceHandles[instNum],
+                                            myVirtualToPhysical);
+        if (CPA_STATUS_SUCCESS != status)
+        {
+            WARN("cpaCySetAddressTranslation failed, status=%d\n", status);
+			qat_engine_finish(e);
+            return 0;
+        }
+
+        /* Start the instances */
+        status = cpaCyStartInstance(qatInstanceHandles[instNum]);
+        if (CPA_STATUS_SUCCESS != status)
+        {
+            WARN("cpaCyStartInstance failed, status=%d\n", status);
+			qat_engine_finish(e);
+            return 0;
+        }
+
+        if (0 == enable_external_polling)
+        {
+            /* Create the polling threads */
+#ifdef USE_PTHREAD_YIELD
+            pthread_create(&icp_polling_threads[instNum], NULL, sendPoll,
+                       qatInstanceHandles[instNum]);
+#else
+            pthread_create(&icp_polling_threads[instNum], NULL, sendPoll_ns,
+                       qatInstanceHandles[instNum]);
+#endif
+#ifdef QAT_POLL_CORE_AFFINITY
+            {
+                int coreID = 0;
+                int sts = 1;
+                cpu_set_t cpuset;
+
+                CPU_ZERO(&cpuset);
+
+                CPU_SET(coreID, &cpuset);
+
+                sts =
+                      pthread_setaffinity_np(icp_polling_threads[instNum],
+                                             sizeof(cpu_set_t), &cpuset);
+                if (sts != 0)
+                {
+                    DEBUG("pthread_setaffinity_np error, status = %d \n", sts);
+					qat_engine_finish(e);
+					return 0;
+                }
+                sts =
+                      pthread_getaffinity_np(icp_polling_threads[instNum],
+                                             sizeof(cpu_set_t), &cpuset);
+                if (sts != 0)
+                {
+                    DEBUG("pthread_getaffinity_np error, status = %d \n", sts);
+                    qat_engine_finish(e);
+					return 0;
+                }
+
+                if (CPU_ISSET(coreID, &cpuset))
+                    DEBUG("Polling thread assigned on CPU core %d\n", coreID);
+            }
+#endif
+        }
+    }
+
+    status = qat_rand_initialise();
+    if (status != 1)
+    {
+        WARN("QAT RAND failed to initialise\n");
+        qat_engine_finish(e);
+        return 0;
+    }
+
+    /* Reset currInst */
+    currInst = 0;
+    qat_inited = 1;
+
+    return 1;
+}
+
+#define QAT_CMD_ENABLE_POLLING ENGINE_CMD_BASE
+#define QAT_CMD_POLL (ENGINE_CMD_BASE + 1)
+#define QAT_CMD_SET_INSTANCE_FOR_THREAD (ENGINE_CMD_BASE + 2)
+#define QAT_CMD_GET_OP_RETRIES (ENGINE_CMD_BASE + 3)
+#define QAT_CMD_SET_V2P (ENGINE_CMD_BASE + 4)
+#define QAT_CMD_ENABLE_ZERO_COPY_MODE (ENGINE_CMD_BASE + 5)
+#define QAT_CMD_SET_MSG_RETRY_COUNTER (ENGINE_CMD_BASE + 6)
+#define QAT_CMD_SET_POLL_INTERVAL (ENGINE_CMD_BASE + 7)
+
+static const ENGINE_CMD_DEFN qat_cmd_defns[] = {
+    {
+        QAT_CMD_ENABLE_POLLING,
+        "ENABLE_POLLING",
+        "Enables the polling interface to the engine.",
+        ENGINE_CMD_FLAG_NO_INPUT
+    },
+    {
+        QAT_CMD_POLL,
+        "POLL",
+        "Polls the engine for any completed requests",
+        ENGINE_CMD_FLAG_NO_INPUT
+    },
+    {
+        QAT_CMD_SET_INSTANCE_FOR_THREAD,
+        "SET_INSTANCE_FOR_THREAD",
+        "Set instance to be used by this thread",
+        ENGINE_CMD_FLAG_NUMERIC
+    },
+    {
+        QAT_CMD_GET_OP_RETRIES,
+        "GET_OP_RETRIES",
+        "Get number of retries",
+        ENGINE_CMD_FLAG_NO_INPUT
+    },
+    {
+        QAT_CMD_SET_V2P,
+        "SET_V2P",
+        "Set function to be used for V2P translation",
+        ENGINE_CMD_FLAG_NUMERIC
+    },
+    {
+        QAT_CMD_ENABLE_ZERO_COPY_MODE,
+        "ENABLE_ZERO_COPY_MODE",
+        "Set zero copy mode",
+        ENGINE_CMD_FLAG_NO_INPUT
+    },
+    {
+        QAT_CMD_SET_MSG_RETRY_COUNTER,
+        "SET_MSG_RETRY_COUNT",
+        "Set Message retry count",
+        ENGINE_CMD_FLAG_NUMERIC
+    },
+    {
+        QAT_CMD_SET_POLL_INTERVAL,
+        "SET_POLL_INTERVAL",
+        "Set Poll Interval",
+        ENGINE_CMD_FLAG_NUMERIC
+    },
+    {0, NULL, NULL, 0}
+};
+
+/******************************************************************************
+* function:
+*         qat_engine_ctrl(ENGINE *e, int cmd, long i,
+*                         void *p, void (*f)(void))
+*
+* @param e   [IN] - OpenSSL engine pointer
+* @param cmd [IN] - Control Command
+* @param i   [IN] - Unused
+* @param p   [IN] - Parameters for the command
+* @param f   [IN] - Callback function
+*
+* description:
+*   Qat engine control functions.
+*   Note: QAT_CMD_ENABLE_POLLING should be called at the following point
+*         during startup:
+*         ENGINE_load_qat
+*         ENGINE_by_id
+*    ---> ENGINE_ctrl_cmd(QAT_CMD_ENABLE_POLLING)
+*         ENGINE_init
+******************************************************************************/
+
+static int
+qat_engine_ctrl(ENGINE *e, int cmd, long i,
+                void *p, void (*f)(void))
+{
+    unsigned int retVal = 1;
+    CpaStatus* pollRet = (CpaStatus*)p;
+
+    switch(cmd)
+    {
+        case QAT_CMD_POLL:
+        {
+            if (enable_external_polling)
+            {
+                if (NULL != p)
+                    *pollRet = poll_instances();
+                else
+		{
+		    WARN("No poll return status passed to engine\n");
+                    retVal = 0;
+		}
+            }
+	    else
+            {
+                WARN("Polling not enabled on the engine\n");
+                retVal = 0;
+            }
+            break;
+        }
+        case QAT_CMD_ENABLE_POLLING:
+        {
+            enable_external_polling = 1;
+            break;
+        }
+        case QAT_CMD_SET_INSTANCE_FOR_THREAD:
+            qat_set_instance_for_thread(i);
+            break;
+        case QAT_CMD_GET_OP_RETRIES:
+            *(int *)p = qatPerformOpRetries;
+            break;
+        case QAT_CMD_SET_V2P:
+            setMyVirtualToPhysical((CpaVirtualToPhysical)i);
+            break;
+        case QAT_CMD_ENABLE_ZERO_COPY_MODE:
+            enableZeroCopy();
+            break;
+        case QAT_CMD_SET_MSG_RETRY_COUNTER:
+            setQatMsgRetryCount((int) i);
+            break;
+        case QAT_CMD_SET_POLL_INTERVAL:
+            setQatPollInterval((unsigned long int)i);
+            break;
+        default:
+        {
+            WARN("CTRL command not implemented\n");
+            retVal = 0;
+            break;
+        }
+    }
+    return retVal;
+}
+
+/******************************************************************************
+* function:
+*         qat_engine_finish(ENGINE *e)
+*
+* @param e [IN] - OpenSSL engine pointer
+*
+* description:
+*   Qat engine finish function.
+******************************************************************************/
+
+static int qat_engine_finish(ENGINE * e)
+{
+
+    int i;
+    CpaStatus status = CPA_STATUS_SUCCESS;
+
+    DEBUG("[%s] ---- Engine Finishing...\n\n", __func__);
+
+    keep_polling = 0;
+
+    for ( i = 0; i < numInstances; i++)
+    {
+        status = cpaCyStopInstance(qatInstanceHandles[i]);
+
+        if (CPA_STATUS_SUCCESS != status)
+        {
+            WARN("cpaCyStopInstance failed, status=%d\n", status);
+            return 0;
+        }
+
+        if (0 == enable_external_polling)
+            pthread_join(icp_polling_threads[i], NULL);
+
+    }
+
+    if (qatInstanceHandles)
+        OPENSSL_free(qatInstanceHandles);
+
+    if (0 == enable_external_polling)
+    {
+	    if (icp_polling_threads)
+            OPENSSL_free(icp_polling_threads);
+    }
+
+    icp_sal_userStop();
+
+    CRYPTO_CLOSE_QAT_LOG();
+
+    return 1;
+}
+
+/******************************************************************************
+* function:
+*         qat_engine_destroy(ENGINE *e)
+*
+* @param e [IN] - OpenSSL engine pointer
+*
+* description:
+*   Qat engine destroy function, required by Openssl engine API.
+*   all the clean up are implemented in qat_engine_finish(), thus we just do
+*   nothing here but return 1.
+*
+******************************************************************************/
+static int qat_engine_destroy(ENGINE * e)
+{
+    DEBUG("[%s] ---- Destroying Engine...\n\n", __func__);
+#ifdef OPENSSL_QAT_ASYNCH
+    qat_prf_cleanup();
+#endif
+    return 1;
+}
+
+/******************************************************************************
+* function:
+*         bind_qat(ENGINE *e,
+*                  const char *id)
+*
+* @param e  [IN] - OpenSSL engine pointer
+* @param id [IN] - engine id
+*
+* description:
+*    Connect Qat engine to OpenSSL engine library
+******************************************************************************/
+static int bind_qat(ENGINE * e, const char *id)
+{
+    int ret = 0;
+
+    DEBUG("[%s] id=%s\n", __func__, id);
+
+    if (id && (strcmp(id, engine_qat_id) != 0))
+    {
+        WARN("ENGINE_id defined already!\n");
+        goto end;
+    }
+
+    if (!ENGINE_set_id(e, engine_qat_id))
+    {
+        WARN("ENGINE_set_id failed\n");
+        goto end;
+    }
+
+    if (!ENGINE_set_name(e, engine_qat_name))
+    {
+        WARN("ENGINE_set_name failed\n");
+        goto end;
+    }
+
+    /* Ensure the QAT error handling is set up */
+    ERR_load_QAT_strings();
+
+    DEBUG("%s: About to set mem functions\n", __func__);
+
+    if (!ENGINE_set_RSA(e, get_RSA_methods()))
+    {
+        WARN("ENGINE_set_RSA failed\n");
+        goto end;
+    }
+
+    if (!ENGINE_set_DSA(e, get_DSA_methods()))
+    {
+        WARN("ENGINE_set_DSA failed\n");
+        goto end;
+    }
+
+    if (!ENGINE_set_DH(e, get_DH_methods()))
+    {
+        WARN("ENGINE_set_DH failed\n");
+        goto end;
+    }
+
+    if (!ENGINE_set_ECDH(e, get_ECDH_methods()))
+    {
+        WARN("ENGINE_set_ECDH failed\n");
+        goto end;
+    }
+
+    if (!ENGINE_set_ECDSA(e, get_ECDSA_methods()))
+    {
+        WARN("ENGINE_set_ECDSA failed\n");
+        goto end;
+    }
+
+    if (!ENGINE_set_ciphers(e, qat_ciphers_synch))
+    {
+        WARN("ENGINE_set_ciphers failed\n");
+        goto end;
+    }
+
+#ifdef OPENSSL_QAT_ASYNCH
+    if (!ENGINE_set_ciphers_asynch(e, qat_ciphers_asynch))
+    {
+        WARN("ENGINE_set_ciphers_asynch failed\n");
+        goto end;
+    }
+#endif
+
+    if (!ENGINE_set_digests(e, qat_digests_synch))
+    {
+        WARN("ENGINE_set_digests failed\n");
+        goto end;
+    }
+#ifdef OPENSSL_QAT_ASYNCH
+    if (!ENGINE_set_digests_asynch(e, qat_digests_asynch))
+    {
+        WARN("ENGINE_set_digests failed\n");
+        goto end;
+    }
+#endif
+
+    if (!ENGINE_set_RAND(e, get_RAND_methods()))
+    {
+        WARN("ENGINE_set_RAND failed\n");
+        goto end;
+    }
+
+#ifdef OPENSSL_QAT_ASYNCH
+    if (! ENGINE_set_pkey_meths(e, qat_prf_pkey_meths))
+    {
+        WARN("ENGINE_set_pkey_meths failed\n");
+        goto end;
+    }
+#endif
+
+    if (!ENGINE_set_destroy_function(e, qat_engine_destroy)
+        || !ENGINE_set_init_function(e, qat_engine_init)
+        || !ENGINE_set_finish_function(e, qat_engine_finish)
+        || !ENGINE_set_ctrl_function(e, qat_engine_ctrl)
+        || !ENGINE_set_cmd_defns(e, qat_cmd_defns))
+    {
+        WARN("[%s] failed reg destroy, init or finish\n", __func__);
+
+        goto end;
+    }
+
+    ret = 1;
+
+  end:
+
+    return ret;
+
+}
+#ifndef OPENSSL_NO_DYNAMIC_ENGINE
+IMPLEMENT_DYNAMIC_BIND_FN(bind_qat)
+IMPLEMENT_DYNAMIC_CHECK_FN()
+#endif  /* ndef OPENSSL_NO_DYNAMIC_ENGINE */
+
+/* initialize Qat Engine if OPENSSL_NO_DYNAMIC_ENGINE*/
+#ifdef OPENSSL_NO_DYNAMIC_ENGINE
+static ENGINE *engine_qat(void)
+{
+    ENGINE *ret = NULL;
+    unsigned int devmasks[] = {0, 0, 0};
+    DEBUG("[%s] engine_qat\n", __func__);
+
+    if (access(QAT_DEV, F_OK) != 0)
+    {
+        QATerr(QAT_F_ENGINE_QAT, QAT_R_MEM_DRV_NOT_PRESENT);
+        return ret;
+    }
+
+    if(!getDevices(devmasks))
+    {
+        QATerr(QAT_F_ENGINE_QAT, QAT_R_QAT_DEV_NOT_PRESENT);
+        return ret;
+    }
+
+#ifdef QAT_ZERO_COPY_MODE
+    enableZeroCopy();
+#endif
+
+    ret = ENGINE_new();
+
+    if (!ret)
+        return NULL;
+
+    if (!bind_qat(ret, engine_qat_id))
+    {
+        WARN("qat engine bind failed!\n");
+        ENGINE_free(ret);
+        return NULL;
+    }
+
+    return ret;
+}
+
+void ENGINE_load_qat(void)
+{
+    ENGINE *toadd = engine_qat();
+    int error = 0;
+    char error_string[120] = {0};
+
+    DEBUG("[%s] engine_load_qat\n", __func__);
+
+    if (!toadd)
+    {
+        error = ERR_get_error();
+        ERR_error_string(error, error_string);
+        fprintf(stderr, "Error reported by engine load: %s\n", error_string);
+        return;
+    }
+
+    DEBUG("[%s] engine_load_qat adding\n", __func__);
+    ENGINE_add(toadd);
+    ENGINE_free(toadd);
+    ERR_clear_error();
+}
+#endif
+
diff -uBbw -Nr ../openssl-async/engines/qat_engine/e_qat.ec ./engines/qat_engine/e_qat.ec
--- ../openssl-async/engines/qat_engine/e_qat.ec	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/e_qat.ec	2015-03-05 12:43:44.229964000 +0000
@@ -0,0 +1 @@
+L QAT	e_qat_err.h			e_qat_err.c
diff -uBbw -Nr ../openssl-async/engines/qat_engine/e_qat.h ./engines/qat_engine/e_qat.h
--- ../openssl-async/engines/qat_engine/e_qat.h	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/e_qat.h	2015-03-05 12:43:44.231956000 +0000
@@ -0,0 +1,232 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file e_qat.h
+ *
+ * This file provides and interface for an OpenSSL QAT engine implemenation
+ *
+ *****************************************************************************/
+
+#ifndef E_QAT_H
+#define E_QAT_H
+
+#include <openssl/sha.h>
+#include <openssl/aes.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include "cpa.h"
+#include "cpa_types.h"
+#include "cpa_cy_sym.h"
+#include "cpa_cy_drbg.h"
+
+
+#include "qat_sym_common.h"
+#include "qat_digests.h"
+#include "qat_ciphers.h"
+
+#define QAT_RETRY_BACKOFF_MODULO_DIVISOR 8
+#define QAT_INFINITE_MAX_NUM_RETRIES -1
+
+#ifndef ERR_R_RETRY
+#define ERR_R_RETRY 57
+#endif
+
+typedef struct qat_chained_ctx_t
+{
+    /*While decryption is done in SW the first elements
+     *of this structure need to be the elements present
+     *in EVP_AES_HMAC_SHA1 defined in
+     * crypto/evp/e_aes_cbc_hmac_sha1.c
+     */
+    AES_KEY             ks;
+    SHA_CTX             head,tail,md;
+    size_t              payload_length; /* AAD length in decrypt case */
+    union {
+        unsigned int    tls_ver;
+        unsigned char   tls_aad[16];    /* 13 used */
+    } aux;
+
+    /* QAT Session Params */
+    CpaInstanceHandle instanceHandle;
+    CpaCySymSessionSetupData* session_data;
+    CpaCySymSessionCtx qat_ctx;
+    int initParamsSet;
+    int initHmacKeySet;
+    int init;
+
+    /* QAT Op Params */
+    CpaCySymOpData    OpData;
+    CpaBufferList     srcBufferList;
+    CpaBufferList     dstBufferList;
+    CpaFlatBuffer     srcFlatBuffer[2];
+    CpaFlatBuffer     dstFlatBuffer[2];
+
+    /* Crypto */
+    unsigned char *hmac_key;
+    Cpa8U*   pIv;
+    SHA_CTX  key_wrap;
+
+    /* TLS SSL proto */
+    /*  Reintroduce when QAT decryption added size_t
+     * payload_length;
+     */
+    Cpa8U*	 tls_virt_hdr;
+    Cpa8U        tls_hdr[TLS_VIRT_HDR_SIZE];
+    unsigned int tls_version;
+
+    int (*cipher_cb)(unsigned char *out, int outl, void *cb_data, int status);
+
+    /* Request tracking stats */
+    Cpa64U noRequests;
+    Cpa64U noResponses;
+
+    unsigned int meta_size;
+
+} qat_chained_ctx;
+
+/* qat_buffer structure for partial hash */
+typedef struct qat_buffer_t
+{
+    struct qat_buffer_t *next;  /* next buffer in the list */
+    void *data;                 /* point to data buffer    */
+    int len;                    /* length of data          */
+} qat_buffer;
+
+/* Qat ctx structure declaration */
+typedef struct qat_ctx_t
+{
+    int paramNID;               /* algorithm nid */
+    CpaCySymSessionCtx ctx;     /* session context */
+    unsigned char hashResult[SHA512_DIGEST_LENGTH];
+                                /* hash digest result */
+    int enc;                    /* encryption flag */
+    int init;                   /* has been initialised */
+    int copiedCtx;              /* whether this is a copied context for initialisation purposes */
+    CpaInstanceHandle instanceHandle;
+	Cpa32U nodeId;
+
+    /* the memory for the private meta data must be allocated as contiguous
+     * memory. The cpaCyBufferListGetMetaSize() will return the size (in
+     * bytes) for memory allocation routine to allocate the private meta data
+     * memory
+     */
+    void *srcPrivateMetaData;   /* meta data pointer */
+    void *dstPrivateMetaData;   /* meta data pointer */
+
+    /*  For partial operations, we maintain a linked list of buffers
+     *  to be processed in the final function.
+     */
+
+    qat_buffer *first;          /* first buffer pointer for partial op */
+    qat_buffer *last;           /* last buffer pointe for partial op */
+    int buff_count;             /* buffer count */
+    int buff_total_bytes;       /* total number of bytes in buffer */
+    int failed_submission;      /* flag as a failed submission to aid cleanup */
+
+    /* Request tracking stats */
+    Cpa64U noRequests;
+    Cpa64U noResponses;
+
+    int (*cipher_cb)(unsigned char *out, int outl, void *cb_data, int status);
+    int (*md_cb)(unsigned char *md, unsigned int size, void *cb_data, int status);
+
+    CpaCySymSessionSetupData *session_data;
+    Cpa32U meta_size;
+
+} qat_ctx;
+
+/* Struct for tracking threaded QAT operation completion. */
+struct op_done
+{
+    pthread_mutex_t mutex;
+    pthread_cond_t cond;
+    int flag;
+    CpaBoolean verifyResult;
+};
+
+struct op_done_asynch
+{
+    EVP_CIPHER_CTX* cipher_ctx;
+    EVP_MD_CTX*     md_ctx;
+    unsigned char*  orig_out;
+    unsigned int    orig_len;
+    unsigned char*  cur_out;
+    unsigned int    cur_len;
+    CpaBufferList*  srcBufferList;
+    CpaFlatBuffer*  srcFlatBuffer;
+    CpaBufferList*  dstBufferList;
+    CpaFlatBuffer*  dstFlatBuffer;
+    CpaBoolean      verifyResult;
+    void *cb_data;
+    union
+    {
+        qat_ctx *single;
+	qat_chained_ctx *chain;
+    } qat_ctx;
+    AGG_REQ *agg_req;
+};
+
+CpaInstanceHandle get_next_inst(void);
+void initOpDone(struct op_done *opDone);
+void cleanupOpDone(struct op_done *opDone);
+int waitForOpToComplete(struct op_done *opDone);
+void qat_crypto_callbackFn(void *callbackTag, CpaStatus status,
+                    const CpaCySymOp operationType, void *pOpData,
+                    CpaBufferList * pDstBuffer, CpaBoolean verifyResult);
+CpaStatus myPerformOp(const CpaInstanceHandle instanceHandle,
+                      void *pCallbackTag,
+                      const CpaCySymOpData * pOpData,
+                      const CpaBufferList * pSrcBuffer,
+                      CpaBufferList * pDstBuffer, CpaBoolean * pVerifyResult);
+int isZeroCopy();
+useconds_t getQatPollInterval();
+int getQatMsgRetryCount();
+#endif //E_QAT_H
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qae_mem_utils.c ./engines/qat_engine/qae_mem_utils.c
--- ../openssl-async/engines/qat_engine/qae_mem_utils.c	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qae_mem_utils.c	2015-03-05 12:43:44.232957000 +0000
@@ -0,0 +1,822 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qae_mem_utils.c
+ *
+ * This file provides linux kernel memory allocation for quick assist API
+ *
+ *****************************************************************************/
+#define _GNU_SOURCE
+#include "qae_mem_utils.h"
+#ifdef USE_QAT_MEM
+#include "qat_mem.h"
+#endif
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <assert.h>
+#include <string.h>
+#include <limits.h>
+#include <pthread.h>
+#include <dirent.h>
+#include <unistd.h>
+#include <errno.h>
+
+#ifdef QAT_DEBUG
+#define DEBUG(...) fprintf(stderr, __VA_ARGS__)
+#else
+#define DEBUG(...)
+#endif
+
+#define ERROR(...) fprintf(stderr, __VA_ARGS__)
+
+
+#ifdef QAT_WARN
+#define WARN(...) fprintf (stderr, __VA_ARGS__)
+#else
+#define WARN(...)
+#endif
+
+/*Error from file descriptor operation */
+#define FD_ERROR -1
+
+/* flag for mutex lock */
+static int crypto_inited = 0;
+
+#define PAGE_SHIFT 12
+#define PAGE_SIZE (1UL << PAGE_SHIFT)
+#define PAGE_MASK (~(PAGE_SIZE-1))
+#define MAX_PAGES_SHIFT 5
+#define MAX_PAGES (1UL << MAX_PAGES_SHIFT)
+
+
+#ifdef USE_QAT_MEM
+/* qat_mem ioctl open file descriptor */
+static int crypto_qat_memfd = FD_ERROR;
+#endif
+
+/* Big Slab Allocator Lock */
+static pthread_mutex_t crypto_bsal = PTHREAD_MUTEX_INITIALIZER;   
+
+/*  We allocate memory in slabs consisting of a number of slots
+ *  to avoid fragmentation and also to reduce cost of allocation
+ *
+ *  There are six predefined slot sizes: 256 bytes, 1024 bytes,
+ *  4096 bytes, 8192 bytes, 16384 bytes and 32768 bytes.  
+ *  Slabs are 128KB in size.  
+ *  This implies the most slots that a slab can hold is 128KB/256 = 512.  
+ *  The first slot is used for meta info, so actual is 511.
+ */
+#define SLAB_SIZE 	(0x20000 - sizeof(qat_mem_config))
+
+/* Slot sizes */
+#define NUM_SLOT_POOLS 7
+#define SLOT_256_BYTES  0x0100
+#define SLOT_1_KILOBYTES  0x0400
+#define SLOT_4_KILOBYTES  0x1000
+#define SLOT_8_KILOBYTES  0x2000
+#define SLOT_16_KILOBYTES  0x4000
+#define SLOT_32_KILOBYTES  0x8000
+#define SLOT_DEFAULT_INIT -1
+/* slot free signature */
+#define SIG_FREE        0xF1F2F3F4
+
+/* slot allocate signature */
+#define SIG_ALLOC       0xA1A2A3A4
+
+/* maxmium slot size */
+#define MAX_ALLOC	(SLAB_SIZE - sizeof (qae_slab)-QAE_BYTE_ALIGNMENT)
+
+static int slot_sizes_available[] =
+{
+    SLOT_256_BYTES,
+    SLOT_1_KILOBYTES,
+    SLOT_4_KILOBYTES,
+    SLOT_8_KILOBYTES,
+    SLOT_16_KILOBYTES,
+    SLOT_32_KILOBYTES
+};
+
+typedef struct _qae_slot
+{
+    struct _qae_slot *next;
+    int sig;
+    int pool_index;
+    char *file;
+    int line;
+}
+qae_slot;
+
+typedef struct _qae_slab
+{
+    qat_mem_config memCfg;
+    int slot_size;
+    int sig;
+    struct _qae_slab *next_slab;
+    struct _qae_slot *next_slot;
+}
+qae_slab;
+
+typedef struct _qae_pool
+{
+     int slot_size;
+     struct _qae_slot * next_free_slot;
+}
+qae_pool;
+
+qae_slab *crypto_slab_list=0;
+
+qae_pool crypto_slot_pools[NUM_SLOT_POOLS]=	{{0,NULL},
+					 {0,NULL},
+					 {0,NULL},
+					 {0,NULL},
+					 {0,NULL},
+					 {0,NULL},
+					 {0,NULL}};
+
+static void crypto_init(void);
+
+/******************************************************************************
+* function:
+*         copyAllocPinnedMemory(void *ptr, size_t size, const char *file, int line)
+*
+* @param ptr [IN]  - Pointer to data to be copied
+* @param size [IN] - Size of data to be copied
+*
+* description:
+*   Internal API to allocate a pinned memory
+*   buffer and copy data to it.
+*
+* @retval NULL      failed to allocate memory
+* @retval non-NULL  pointer to allocated memory
+******************************************************************************/
+void *copyAllocPinnedMemory(void *ptr, size_t size, const char *file, int line)
+{
+    void *nptr;
+ 
+    if ((nptr = qaeCryptoMemAlloc(size, file, line)) == NULL)
+    {
+        WARN("%s: pinned memory allocation failure\n", __func__);
+        return NULL;
+    }
+ 
+    memcpy(nptr, ptr, size);
+    return nptr;
+}
+
+/******************************************************************************
+* function:
+*         copyAllocPinnedMemoryClean(void *ptr, size_t size, size_t original_size, const char *file, int line)
+*
+* @param ptr [IN]  - Pointer to data to be copied
+* @param size [IN] - Size of data to be copied
+* @param original_size [IN] - Original size
+*
+* description:
+*   Internal API to allocate a pinned memory
+*   buffer and copy data to it.
+*
+* @retval NULL      failed to allocate memory
+* @retval non-NULL  pointer to allocated memory
+******************************************************************************/
+void *copyAllocPinnedMemoryClean(void *ptr, size_t size, size_t original_size, const char *file, int line)
+{
+    void *nptr;
+ 
+    if ((nptr = qaeCryptoMemAlloc(size, file, line)) == NULL)
+    {
+        WARN("%s: pinned memory allocation failure\n", __func__);
+        return NULL;
+    }
+ 
+    memcpy(nptr, ptr, original_size);
+    return nptr;
+}
+
+/******************************************************************************
+* function:
+*         copyFreePinnedMemory(void *kptr, void *uptr, int size)
+*
+* @param uptr [IN] - Pointer to user data
+* @param kptr [IN] - Pointer to pinned memory to be copied
+* @param size [IN] - Size of data to be copied
+*
+* description:
+*   Internal API to allocate a pinned memory
+*   buffer and copy data to it.
+*
+******************************************************************************/
+void copyFreePinnedMemory(void *uptr, void *kptr, int size)
+{
+    memcpy(uptr, kptr, size);
+    qaeCryptoMemFree (kptr);
+}
+
+/*****************************************************************************
+ * function:
+ *         crypto_create_slab(int size)
+ *
+ * @param[in] size, the size of the slots within the slab. Note that this is
+ *                  not the size of the slab itself
+ * @retval qae_slab*, a pointer to the new slab.
+ *
+ * @description
+ * 	create a new slab and add it to the global linked list
+ * 	retval pointer to the new slab
+ *
+ *****************************************************************************/
+static qae_slab *crypto_create_slab(int size, int pool_index)
+{
+    int i = 0;
+    int nslot = 0;
+    qat_mem_config qmcfg = { 0, (uintptr_t)NULL, 0, (uintptr_t)NULL };
+    qae_slab *result = NULL;
+    qae_slab *slb = NULL;
+    qae_slot *slt = NULL;
+    QAE_UINT alignment;
+
+    qmcfg.length = SLAB_SIZE;
+#ifdef USE_QAT_MEM
+    if (ioctl(crypto_qat_memfd, QAT_MEM_MALLOC, &qmcfg) == -1) {
+        static char errmsg[LINE_MAX];
+
+        snprintf(errmsg, LINE_MAX, "ioctl QAT_MEM_MALLOC(%d)", qmcfg.length);
+        perror(errmsg);
+        goto exit;
+    }
+    if ((slb =
+         mmap(NULL, qmcfg.length, PROT_READ | PROT_WRITE,
+              MAP_SHARED | MAP_LOCKED, crypto_qat_memfd,
+              qmcfg.virtualAddress)) == MAP_FAILED) {
+        static char errmsg[LINE_MAX];
+        snprintf(errmsg, LINE_MAX, "mmap: %d %s", errno, strerror(errno));
+        perror(errmsg);
+        goto exit;
+    }
+#endif
+    DEBUG("%s slot size %d\n", __func__, size);
+    slb->slot_size = size;
+    slb->next_slot = NULL;
+    slb->sig = SIG_ALLOC;
+
+    for (i = sizeof(qae_slab); SLAB_SIZE - i >= size; i += size) {
+        slt = (qae_slot *) ((unsigned char *)slb + i);
+        alignment = QAE_BYTE_ALIGNMENT - (((QAE_UINT) slt + sizeof(qae_slot)) % QAE_BYTE_ALIGNMENT);
+        slt = (qae_slot *)(((QAE_UINT) slt) + alignment);
+        slt->next = slb->next_slot;
+        slt->pool_index = pool_index;
+        slt->sig = SIG_FREE;
+        slt->file = NULL;
+        slt->line = 0;
+        slb->next_slot = slt;
+        nslot++;
+    }
+    slb->next_slab = crypto_slab_list;
+    /* Make sure update of the slab list is the last thing to be done.  This
+       means it is not necessary to lock against anyone iterating the list from 
+       the head */
+    crypto_slab_list = slb;
+    crypto_slot_pools[pool_index].next_free_slot = slb->next_slot;
+
+    result = slb;
+    DEBUG("%s slab %p last slot is %p, count is %d\n", __func__, slb, slt,
+          nslot);
+  exit:
+    return result;
+}
+
+/*****************************************************************************
+ * function:
+ *         crypto_alloc_from_slab(int size, const char *file, int line)
+ *
+ * @param[in] size, the size of the memory block required
+ * @param[in] file, the C source filename of the call site
+ * @param[in] line, the line number withing the C source file of the call site
+ *
+ * @description
+ *      allocate a slot of memory from some slab
+ * 	retval pointer to the allocated block
+ *
+ *****************************************************************************/
+static void *crypto_alloc_from_slab(int size, const char *file, int line)
+{
+    qae_slab *slb=NULL;
+    qae_slot *slt;
+    int slot_size;
+    void *result = NULL;
+    int rc;
+    int i;
+    
+    if (!crypto_inited)
+        crypto_init();
+
+    size += sizeof(qae_slot);
+    size += QAE_BYTE_ALIGNMENT;
+
+    slot_size = SLOT_DEFAULT_INIT;
+    
+    for (i = 0; i < sizeof (slot_sizes_available) / sizeof (int); i++) {
+        if (size < slot_sizes_available[i]) {
+            slot_size = slot_sizes_available[i];
+            break;
+        }
+    }
+
+    if (SLOT_DEFAULT_INIT == slot_size) {
+         if (size <= MAX_ALLOC)
+            slot_size = MAX_ALLOC;
+        else {
+            ERROR("%s Allocation of %d bytes is too big\n", __func__, size);
+            goto exit;
+        }
+    }
+
+    if(crypto_slot_pools[i].slot_size != slot_size)
+    {
+         ERROR("%s Unsupported slot size %d\n", __func__, slot_size);
+         goto exit;
+    }
+ 
+    DEBUG("%s: pthread_mutex_lock\n", __func__);
+    if ((rc = pthread_mutex_lock(&crypto_bsal)) != 0) {
+        ERROR("pthread_mutex_lock: %s\n", strerror(rc));
+        return result;
+    }
+
+    if(crypto_slot_pools[i].next_free_slot == NULL)
+    { 
+        /* no free slots need to allocate new slab */ 
+        slb = crypto_create_slab(slot_size, i);
+
+        if (NULL == slb) {
+            ERROR("%s error, create_slab failed - memory allocation error\n", __func__);
+            if ((rc = pthread_mutex_unlock(&crypto_bsal)) != 0)
+                ERROR("pthread_mutex_unlock: %s\n", strerror(rc));
+            DEBUG("%s: pthread_mutex_unlock\n", __func__);
+            goto exit;
+        }
+    }
+
+    if (NULL == crypto_slot_pools[i].next_free_slot) {
+        ERROR("%s error, no slots\n", __func__);
+        if ((rc = pthread_mutex_unlock(&crypto_bsal)) != 0)
+            ERROR("pthread_mutex_unlock: %s\n", strerror(rc));
+        DEBUG("%s: pthread_mutex_unlock\n", __func__);
+        goto exit;
+    }
+
+    slt = crypto_slot_pools[i].next_free_slot;
+
+    if (slt->sig != SIG_FREE) {
+        ERROR("%s error alloc slot that isn't free %p\n", __func__, slt);
+        exit(1);
+    }
+
+    crypto_slot_pools[i].next_free_slot = slt->next;
+    slt->next = NULL;
+    slt->sig = SIG_ALLOC;
+    slt->file = strdup(file);
+    slt->line = line;
+    result = (void *)((unsigned char *)slt + sizeof(qae_slot));
+
+    if ((rc = pthread_mutex_unlock(&crypto_bsal)) != 0)
+        ERROR("pthread_mutex_unlock: %s\n", strerror(rc));
+    DEBUG("%s: pthread_mutex_unlock\n", __func__);
+
+  exit:
+    return result;
+}
+
+/*****************************************************************************
+ * function:
+ *         crypto_free_to_slab(void *ptr)
+ *
+ * @param[in] ptr, pointer to the memory to be freed
+ *
+ * @description
+ *      free a slot of memory back to its slab
+ *
+ *****************************************************************************/
+static void crypto_free_to_slab(void *ptr)
+{
+    qae_slot *slt = (void *)((unsigned char *)ptr - sizeof(qae_slot));
+    int rc;
+
+    if ((rc = pthread_mutex_lock(&crypto_bsal)) != 0) {
+        ERROR("pthread_mutex_lock: %s\n", strerror(rc));
+        return;
+    }
+
+    DEBUG("%s: pthread_mutex_lock\n", __func__);
+    if (!slt) {
+        ERROR("Error freeing memory - unknown address\n");
+        goto exit;
+    }
+    if (slt->sig != SIG_ALLOC) {
+        ERROR("%s error trying to free slot that hasn't been alloc'd %p\n", __func__, slt);
+        goto exit;
+    }
+
+    free(slt->file);
+    slt->sig = SIG_FREE;
+    slt->file = NULL;
+    slt->line = 0;
+    slt->next = crypto_slot_pools[slt->pool_index].next_free_slot;
+    crypto_slot_pools[slt->pool_index].next_free_slot = slt;
+exit:
+    if ((rc = pthread_mutex_unlock(&crypto_bsal)) != 0)
+        ERROR("pthread_mutex_unlock: %s\n", strerror(rc));
+    DEBUG("%s: pthread_mutex_unlock\n", __func__);
+}
+
+/*****************************************************************************
+ * function:
+ *         crypto_slot_get_size(void *ptr)
+ *
+ * @param[in] ptr, pointer to the slot memory
+ * @retval int, the size of the slot in bytes
+ *
+ * @description
+ *      get the slot memory size in bytes
+ *
+ *****************************************************************************/
+static int crypto_slot_get_size(void *ptr)
+{
+    if (NULL == ptr)
+    {
+        ERROR("%s error can't find %p\n", __func__, ptr);
+        return 0;
+    }
+    qae_slot *slt = (void *)((unsigned char *)ptr - sizeof(qae_slot));
+    if (slt->pool_index == (NUM_SLOT_POOLS - 1))
+    {
+        return MAX_ALLOC;
+    }
+    else if (slt->pool_index >= 0 && slt->pool_index <= NUM_SLOT_POOLS - 2)
+    {
+        return slot_sizes_available[slt->pool_index] - sizeof(qae_slot) - QAE_BYTE_ALIGNMENT;
+    }
+    else
+    {
+        ERROR("%s error invalid pool_index %d\n", __func__, slt->pool_index);
+        return 0;
+    }
+}
+
+/*****************************************************************************
+ * function:
+ *         qaeCryptoAtFork()
+ *
+ * @description
+ *      allocate and remap momory following a fork
+ *
+ *****************************************************************************/
+void qaeCryptoAtFork()
+{
+    int rc = 0;
+    if ((rc = pthread_mutex_lock(&crypto_bsal)) != 0) {
+        ERROR("pthread_mutex_lock: %s\n", strerror(rc));
+        return;
+    }
+    DEBUG("%s: pthread_mutex_lock\n", __func__);
+    qae_slab * old_slb = crypto_slab_list;
+    qae_slab * new_slb = NULL;
+    qat_mem_config qmcfg = { 0, (uintptr_t)NULL, SLAB_SIZE, (uintptr_t)NULL };
+
+    while (old_slb != NULL)
+    {
+#ifdef USE_QAT_MEM
+        if (ioctl(crypto_qat_memfd, QAT_MEM_MALLOC, &qmcfg) == -1)
+        {
+            static char errmsg[LINE_MAX];
+
+            snprintf(errmsg, LINE_MAX, "ioctl QAT_MEM_MALLOC(%d)", qmcfg.length);
+            perror(errmsg);
+            exit(EXIT_FAILURE);
+        }
+
+        if ((new_slb =
+              mmap(NULL, qmcfg.length, PROT_READ | PROT_WRITE,
+              MAP_SHARED | MAP_LOCKED, crypto_qat_memfd,
+              qmcfg.virtualAddress)) == MAP_FAILED)
+        {
+            static char errmsg[LINE_MAX];
+            snprintf(errmsg, LINE_MAX, "mmap: %d %s", errno, strerror(errno));
+            perror(errmsg);
+            exit(EXIT_FAILURE);
+        }
+        memcpy((void *)new_slb + sizeof(qat_mem_config), (void *)old_slb + sizeof(qat_mem_config), SLAB_SIZE );
+
+#endif
+        qae_slab * to_unmap = old_slb;
+        old_slb = old_slb->next_slab;
+        if (munmap(to_unmap, SLAB_SIZE) == -1)
+        {
+            perror("munmap");
+            exit(EXIT_FAILURE);
+        }
+        qae_slab * remap = mremap(new_slb, SLAB_SIZE,SLAB_SIZE,MREMAP_FIXED | MREMAP_MAYMOVE ,to_unmap);
+        if ((remap == MAP_FAILED) || (remap != to_unmap))
+        {
+            perror("mremap");
+            exit(EXIT_FAILURE);
+        }
+    }
+
+    if ((rc = pthread_mutex_unlock(&crypto_bsal)) != 0)
+        ERROR("pthread_mutex_unlock: %s\n", strerror(rc));
+    DEBUG("%s: pthread_mutex_unlock\n", __func__);
+}
+
+
+
+/*****************************************************************************
+ * function:
+ *         crypto_cleanup_slabs(void)
+ *
+ * @description
+ *      Free all memory managed by the slab allocator. This function is
+ *      intended to be registered as an atexit() handler.
+ *
+ *****************************************************************************/
+static void crypto_cleanup_slabs(void)
+{
+    qae_slab *slb, *s_next_slab;
+    int rc;
+    QAE_UINT alignment;
+#ifdef USE_QAT_MEM
+    qat_mem_config qmcfg;
+#endif
+	
+    if ((rc = pthread_mutex_lock(&crypto_bsal)) != 0) {
+        ERROR("pthread_mutex_lock: %s\n", strerror(rc));
+        return;
+    }
+
+    DEBUG("%s: pthread_mutex_lock\n", __func__);
+    for (slb = crypto_slab_list; slb != NULL; slb = s_next_slab) {
+        qae_slot *slt = NULL;
+        int i;
+
+        for (i = sizeof(qae_slab); SLAB_SIZE - i >= slb->slot_size;
+             i += slb->slot_size) {
+            slt = (qae_slot *) ((unsigned char *)slb + i);
+            alignment = QAE_BYTE_ALIGNMENT - (((QAE_UINT) slt + sizeof(qae_slot)) % QAE_BYTE_ALIGNMENT);
+            slt = (qae_slot *)(((QAE_UINT) slt) + alignment);
+
+            if (slt->sig == SIG_ALLOC && slt->file != NULL && slt->line != 0)
+                DEBUG("Leak : %p %s:%d\n", slt, slt->file, slt->line);
+        }
+
+         /* Have to save this off before unmapping. This is why we can't have
+           slb = slb->next_slab in the for loop above. */
+        s_next_slab = slb->next_slab;
+
+#ifdef USE_QAT_MEM
+
+        DEBUG("%s do munmap  of %p\n", __func__, slb);
+        qmcfg = *((qat_mem_config *) slb);
+		
+        if (munmap(slb, SLAB_SIZE) == -1) {
+            perror("munmap");
+            exit(EXIT_FAILURE);
+        }
+        DEBUG("%s ioctl free of %p\n", __func__, slb);
+        if (ioctl(crypto_qat_memfd, QAT_MEM_FREE, &qmcfg) == -1) {
+            perror("ioctl QAT_MEM_FREE");
+            exit(EXIT_FAILURE);
+        }
+#endif
+
+    }
+    DEBUG("%s done\n", __func__);
+
+    if ((rc = pthread_mutex_unlock(&crypto_bsal)) != 0)
+        ERROR("pthread_mutex_unlock: %s\n", strerror(rc));
+    DEBUG("%s: pthread_mutex_unlock\n", __func__);
+}
+
+/******************************************************************************
+* function:
+*         crypto_init(void)
+*
+* @description
+*   Initialise the user-space part of the QAT memory allocator.
+*
+******************************************************************************/
+static void crypto_init(void)
+{
+    int i=0;
+#ifdef USE_QAT_MEM
+    if ((crypto_qat_memfd = open("/dev/qat_mem", O_RDWR)) == FD_ERROR) {
+        perror("open qat_mem");
+        exit(EXIT_FAILURE);
+    }
+#endif
+    for (i = 0; i < sizeof (slot_sizes_available) / sizeof (int); i++) {
+       crypto_slot_pools[i].slot_size = slot_sizes_available[i];
+       crypto_slot_pools[i].next_free_slot = NULL; 
+    }
+    crypto_slot_pools[i].slot_size = MAX_ALLOC;
+    crypto_slot_pools[i].next_free_slot = NULL;
+
+    atexit(crypto_cleanup_slabs);
+    crypto_inited = 1;
+}
+
+/******************************************************************************
+* function:
+*         qaeCryptoMemV2P(void *v)
+*
+* @param[in] v, virtual memory address pointer 
+* @retval CpaPhysicalAddress, the physical memory address pointer, it
+*         returns 0 if not found.
+*
+* description:
+* 	map virtual memory address to physical memory address
+*
+******************************************************************************/
+CpaPhysicalAddr qaeCryptoMemV2P(void *v)
+{
+    qat_mem_config *memCfg = NULL;
+    void *pVirtPageAddress = NULL;
+    ptrdiff_t offset = 0;
+    int pagecount=0;
+    if(v==NULL)
+    {
+        WARN("%s: NULL address passed to function\n", __func__);
+        return (CpaPhysicalAddr) 0;
+    }
+
+    pVirtPageAddress = ((int *)((((ptrdiff_t)v)) & (PAGE_MASK)));
+
+    offset = (char *)v- (char *)pVirtPageAddress;
+
+    do
+    {
+        DEBUG("addr %p, page addr %p, offset %d\n", v, pVirtPageAddress, offset);
+        memCfg = (qat_mem_config *)pVirtPageAddress;
+        if(memCfg->signature == QAT_MEM_ALLOC_SIG)
+        {
+            break;
+        }
+        pVirtPageAddress = (void*)((ptrdiff_t)pVirtPageAddress - PAGE_SIZE);
+
+        offset += PAGE_SIZE;
+        pagecount++;
+    }
+    while ((memCfg->signature != QAT_MEM_ALLOC_SIG) && (pagecount <= MAX_PAGES));
+    if(memCfg->signature != QAT_MEM_ALLOC_SIG)
+    {
+        WARN("%s: unable to find physical address\n", __func__);
+        return (CpaPhysicalAddr) 0;
+    }
+
+    return (CpaPhysicalAddr)(memCfg->physicalAddress + offset);
+}
+
+/**************************************
+ * Memory functions
+ *************************************/
+
+/******************************************************************************
+* function:
+*         qaeCryptoMemAlloc(size_t memsize, , const char *file, int line)
+*
+* @param[in] memsize,  size of usable memory requested
+* @param[in] file,     the C source filename of the call site
+* @param[in] line,     the line number withing the C source file of the call site
+*
+* description:
+*   Allocate a block of pinned memory.
+*
+******************************************************************************/
+void *qaeCryptoMemAlloc(size_t memsize, const char *file, int line)
+{
+    void *pAddress = crypto_alloc_from_slab(memsize, file, line);
+    DEBUG("%s: Address: %p Size: %d File: %s:%d\n", __func__, pAddress, memsize, file, line);
+    return pAddress;
+}
+
+/******************************************************************************
+* function:
+*         qaeCryptoMemFree(void *ptr)
+*
+* @param[in] ptr, address of start of usable memory
+*
+* description:
+*   Free a block of memory previously allocated by this allocator.
+*
+******************************************************************************/
+void qaeCryptoMemFree(void *ptr)
+{
+    DEBUG("%s: Address: %p\n", __func__, ptr); 
+    if(NULL != ptr) 
+        crypto_free_to_slab(ptr);
+}
+
+/******************************************************************************
+* function:
+*         qaeCryptoMemRealloc(void *ptr, size_t memsize, const char *file, int line)
+*
+* @param[in] ptr,     address of start of usable memory for old allocation
+* @param[in] memsize, size of new block required
+* @param[in] file,    the C source filename of the call site
+* @param[in] line,    the line number withing the C source file of the call site
+*
+* description:
+*   Change the size of usable memory in an allocated block. This may allocate
+*   a new block and copy the data to it.
+*
+******************************************************************************/
+void *qaeCryptoMemRealloc(void *ptr, size_t memsize, const char *file, int line)
+{ 
+    int copy = crypto_slot_get_size(ptr);
+    void *n = crypto_alloc_from_slab(memsize, file, line);
+    DEBUG("%s: Alloc Address: %p Size: %d File: %s:%d\n", __func__, n, memsize, file, line);
+
+    if (memsize < copy)
+        copy = memsize;
+    memcpy(n, ptr, copy);
+    DEBUG("%s: Free Address: %p\n", __func__, ptr); 
+    crypto_free_to_slab(ptr);
+    return n;
+}
+
+/*************************************************************************************************************
+* function:
+*         qaeCryptoMemReallocClean(void *ptr, size_t memsize, size_t original_size, const char *file, int line)
+*
+* @param[in] ptr,     		address of start of usable memory for old allocation
+* @param[in] memsize, 		size of new block required
+* @param[in] original_size,	original size	 
+* @param[in] file,    		the C source filename of the call site
+* @param[in] line,    		the line number withing the C source file of the call site
+*
+* description:
+*   Change the size of usable memory in an allocated block. This may allocate
+*   a new block and copy the data to it.
+*
+***************************************************************************************************************/
+void *qaeCryptoMemReallocClean(void *ptr, size_t memsize, size_t original_size, const char *file, int line)
+{ 
+    int copy = crypto_slot_get_size(ptr);
+    void *n = crypto_alloc_from_slab(memsize, file, line);
+    DEBUG("%s: Alloc Address: %p Size: %d File: %s:%d\n", __func__, n, memsize, file, line);
+
+    if (memsize < copy)
+        copy = memsize;
+    memcpy(n, ptr, copy);
+    DEBUG("%s: Free Address: %p\n", __func__, ptr); 
+    crypto_free_to_slab(ptr);
+    return n;
+}
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qae_mem_utils.h ./engines/qat_engine/qae_mem_utils.h
--- ../openssl-async/engines/qat_engine/qae_mem_utils.h	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qae_mem_utils.h	2015-03-05 12:43:44.233958000 +0000
@@ -0,0 +1,171 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qae_mem_utils.h
+ *
+ * This file provides linux kernel memory allocation for quick assist API
+ *
+ *****************************************************************************/
+
+#ifndef __QAE_MEM_UTILS_H
+#define __QAE_MEM_UTILS_H
+
+#include "cpa.h"
+
+/*define types which need to vary between 32 and 64 bit*/
+#ifdef __x86_64__
+#define QAE_UINT  Cpa64U
+#define QAE_INT   Cpa64S
+#else
+#define QAE_UINT  Cpa32U
+#define QAE_INT  Cpa32S
+#endif
+
+#define QAE_BYTE_ALIGNMENT 0x0040 /* 64 bytes */
+
+/*****************************************************************************
+ * function:
+ *         qaeCryptoMemAlloc(size_t memsize, const char *file, int line);
+ *
+ * @description
+ *      allocates memsize bytes of memory
+ *
+ * @param[in] memsize, the amount of memory in bytes to be allocated
+ *
+ * @retval pointer to the allocated memory
+ *
+ *****************************************************************************/
+void *qaeCryptoMemAlloc(size_t memsize, const char *file, int line);
+
+/*****************************************************************************
+ * function:
+ *         qaeCryptoMemRealloc(void *ptr, size_t memsize, const char *file, int line)
+ *
+ * @description
+ *      re-allocates memsize bytes of memory
+ *
+ * @param[in] pointer to existing memory
+ * @param[in] memsize, the amount of memory in bytes to be allocated
+ *
+ * @retval pointer to the allocated memory
+ *
+ *****************************************************************************/
+void *qaeCryptoMemRealloc(void *ptr, size_t memsize, const char *file, int line);
+
+/*****************************************************************************
+ * function:
+ *         qaeCryptoMemReallocClean(void *ptr, size_t memsize, size_t original_size, const char *file, int line)
+ *
+ * @description
+ *      re-allocates memsize bytes of memory
+ *
+ * @param[in] pointer to existing memory
+ * @param[in] memsize, the amount of memory in bytes to be allocated
+ * @param[in] original_size, original size
+ * @param[in] file, the C source filename of the call site
+ * @param[in] line, the line number withing the C source file of the call site
+ *
+ * @retval pointer to the allocated memory
+ *
+ *****************************************************************************/
+void *qaeCryptoMemReallocClean(void *ptr, size_t memsize, size_t original_size, const char *file, int line);
+
+/*****************************************************************************
+ * function:
+ *         qaeCryptoMemFree(void *ptr)
+ *
+ * @description
+ *      frees memory allocated by the qaeCryptoMemAlloc function
+ *
+ *
+ * @param[in] pointer to the memory to be freed
+ *
+ * @retval none
+ *
+ *****************************************************************************/
+void qaeCryptoMemFree(void *ptr);
+
+
+/*****************************************************************************
+ * function:
+ *         qaeCryptoMemV2P(void *v)
+ *
+ * @description
+ * 	find the physical address of a block of memory referred to by virtual
+ * 	address v in the current process's address map
+ *
+ *
+ * @param[in] ptr, virtual pointer to the memory
+ *
+ * @retval the physical address of the memory referred to by ptr
+ *
+ *****************************************************************************/
+CpaPhysicalAddr qaeCryptoMemV2P (void *v);
+
+/******************************************************************************
+* function:
+*         setMyVirtualToPhysical(CpaVirtualToPhysical fp)
+*
+* @param CpaVirtualToPhysical [IN] - Function pointer to translation function
+*
+* description:
+*   External API to allow users to specify their own virtual to physical
+*   address translation function.
+*
+******************************************************************************/
+void setMyVirtualToPhysical(CpaVirtualToPhysical fp);
+
+void *copyAllocPinnedMemory(void *ptr, size_t size, const char *file, int line);
+void *copyAllocPinnedMemoryClean(void *ptr, size_t size, size_t original_size, const char *file, int line);
+void copyFreePinnedMemory(void *uptr, void *kptr, int size);
+
+void qaeCryptoAtFork();
+
+#endif
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_asym_common.c ./engines/qat_engine/qat_asym_common.c
--- ../openssl-async/engines/qat_engine/qat_asym_common.c	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_asym_common.c	2015-03-05 12:43:44.234958000 +0000
@@ -0,0 +1,211 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qat_asym_common.c
+ *
+ * This file contains common functions used for asymmetric operations
+ *
+ *****************************************************************************/
+
+/* macros defined to allow use of the cpu get and set affinity functions */
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+
+#ifndef __USE_GNU
+#define __USE_GNU
+#endif
+
+#include <pthread.h>
+
+#include <openssl/ossl_typ.h>
+#include <openssl/bn.h>
+
+#include "cpa_cy_ln.h"
+
+#include "qat_asym_common.h"
+#ifdef USE_QAT_MEM
+#include "qae_mem_utils.h"
+#endif
+#ifdef USE_QAE_MEM
+#include "qat_mem_drv_inf.h"
+#endif
+#include "qat_utils.h"
+#include "e_qat.h"
+
+#define QAT_PERFORMOP_RETRIES 3
+
+/******************************************************************************
+* function:
+*         qat_BN_to_FB(CpaFlatBuffer *fb,
+*                      BIGNUM *bn)
+*
+* @param fb [OUT] - API flatbuffer structure pointer
+* @param bn [IN] - Big Number pointer
+*
+* description:
+*   This function is used to transform the big number format to the flat buffer
+*   format. The function is used to deliver the RSA Public/Private key structure
+*   from OpenSSL layer to API layer.
+******************************************************************************/
+int qat_BN_to_FB(CpaFlatBuffer * fb, BIGNUM * bn)
+{
+
+    /* Memory allocate for flat buffer */
+    fb->dataLenInBytes = (Cpa32U) BN_num_bytes(bn);
+    if (0 == fb->dataLenInBytes)
+    {
+        fb->dataLenInBytes = 0;
+        fb->pData = NULL;
+        return 1;
+    }
+    fb->pData = qaeCryptoMemAlloc(fb->dataLenInBytes, __FILE__, __LINE__);
+    if (NULL == fb->pData)
+    {
+        WARN("[%s] --- FlatBuffer pData malloc failed.\n", __func__);
+        return 0;
+    }
+    /* BN_bn2in() converts the absolute value of big number into big-endian
+       form and stores it at output buffer. the output buffer must point to
+       BN_num_bytes of memory */
+    BN_bn2bin(bn, fb->pData);
+    return 1;
+}
+
+/******************************************************************************
+* function:
+*         qat_mod_exp(BIGNUM * r, const BIGNUM * a, const BIGNUM * p,
+                      const BIGNUM * m, BN_CTX * ctx)
+*
+* @param res  [IN] - Result bignum of mod_exp
+* @param base [IN] - Base used for mod_exp
+* @param exp  [IN] - Exponent used for mod_exp
+* @param mod  [IN] - Modulus used for mod_exp
+*
+* description:
+*   Bignum modular exponentiation function used in DH and DSA.
+*
+******************************************************************************/
+int qat_mod_exp(BIGNUM * res, const BIGNUM * base, const BIGNUM * exp, 
+                const BIGNUM * mod)
+{
+
+    CpaCyLnModExpOpData opData;
+    CpaFlatBuffer result = { 0, };
+    CpaStatus status = 0;
+    int retval = 1;
+    CpaInstanceHandle instanceHandle;
+    int qatPerformOpRetries = 0;
+
+    DEBUG("%s\n", __func__);
+
+    opData.base.pData=NULL;
+    opData.exponent.pData=NULL;
+    opData.modulus.pData=NULL;
+
+    if (qat_BN_to_FB(&opData.base, (BIGNUM *) base) != 1 ||
+        qat_BN_to_FB(&opData.exponent, (BIGNUM *) exp) != 1 ||
+        qat_BN_to_FB(&opData.modulus, (BIGNUM *) mod) != 1)
+    {
+        WARN("qat_BN_to_FB () failed for base, exponent or modulus.\n");
+        retval = 0;
+        goto exit;
+    }
+
+    result.dataLenInBytes = BN_num_bytes(mod);
+    result.pData = qaeCryptoMemAlloc(result.dataLenInBytes, __FILE__, __LINE__);
+    if (NULL == result.pData)
+    {
+        WARN("qaeCryptoMemAlloc () failed for result.pData.\n");
+        retval = 0;
+        goto exit;
+    }
+
+    if (NULL == (instanceHandle = get_next_inst()))
+    {
+        WARN("instanceHandle is NULL\n");
+        retval = 0;
+        goto exit;
+    }
+
+    do
+    {
+        status = cpaCyLnModExp(instanceHandle, NULL, NULL, &opData, &result);
+        if (status == CPA_STATUS_RETRY)
+        {
+            qatPerformOpRetries++;
+        }
+    }
+    while (status == CPA_STATUS_RETRY && qatPerformOpRetries < QAT_PERFORMOP_RETRIES);
+
+    if (CPA_STATUS_SUCCESS != status)
+    {
+        WARN("cpaCyLnModExp failed, status=%d\n", status);
+        retval = 0;
+        goto exit;
+    }
+
+    /* Convert the flatbuffer results back to a BN */
+    BN_bin2bn(result.pData, result.dataLenInBytes, res);
+
+  exit:
+
+    if (opData.base.pData)
+        qaeCryptoMemFree (opData.base.pData);
+    if (opData.exponent.pData)
+        qaeCryptoMemFree (opData.exponent.pData);
+    if (opData.modulus.pData)
+        qaeCryptoMemFree (opData.modulus.pData);
+    if (result.pData)
+        qaeCryptoMemFree (result.pData);
+
+    return retval;
+}
+
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_asym_common.h ./engines/qat_engine/qat_asym_common.h
--- ../openssl-async/engines/qat_engine/qat_asym_common.h	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_asym_common.h	2015-03-05 12:43:44.235961000 +0000
@@ -0,0 +1,68 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qat_asym_common.h
+ *
+ * This file contains the interface to common asymmetric functions
+ *
+ *****************************************************************************/
+
+#ifndef QAT_ASYM_COMMON_H
+#define QAT_ASYM_COMMON_H
+
+#include <openssl/ossl_typ.h>
+
+#include "cpa.h" 
+
+int qat_BN_to_FB(CpaFlatBuffer * fb, BIGNUM * bn);
+int qat_mod_exp(BIGNUM * r, const BIGNUM * a, const BIGNUM * p,
+                       const BIGNUM * m);
+
+#endif //QAT_ASYM_COMMON_H
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_chain.c ./engines/qat_engine/qat_chain.c
--- ../openssl-async/engines/qat_engine/qat_chain.c	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_chain.c	2015-03-05 12:43:44.237957000 +0000
@@ -0,0 +1,1645 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qat_chain.c
+ *
+ * This file contains the engine implementations for Chain cipher operations
+ *
+ *****************************************************************************/
+
+#ifdef USE_QAT_MEM
+#include "qae_mem_utils.h"
+#endif
+#ifdef USE_QAE_MEM
+#include "qat_mem_drv_inf.h"
+#endif
+#include "qat_utils.h"
+#include "e_qat.h"
+#include "e_qat_err.h"
+
+#include "cpa.h"
+#include "cpa_types.h"
+#include "cpa_cy_sym.h"
+#include "qat_chain.h"
+#include "qat_ciphers.h"
+#include "qat_sym_common.h"
+
+#include <openssl/evp.h>
+#include <openssl/aes.h>
+#include <openssl/err.h>
+#include <openssl/sha.h>
+#include <openssl/tls1.h>
+#include <string.h>
+
+/* Qat cipher AES128-SHA1 function structure declaration */
+EVP_CIPHER qat_aes_128_cbc_hmac_sha1 = {
+    NID_aes_128_cbc_hmac_sha1,  /* nid */
+    AES_BLOCK_SIZE,             /* block_size */
+    AES_KEY_SIZE_128,           /* key_size in Bytes - defined in header */
+    AES_IV_LEN,                 /* iv_len in Bytes - defined in header */
+    qat_common_cbc_flags | EVP_CIPH_FLAG_AEAD_CIPHER,
+#ifdef OPENSSL_QAT_ASYNCH
+    { qat_aes_cbc_hmac_sha1_init_sync },
+    { qat_aes_cbc_hmac_sha1_cipher_sync },
+#else
+    qat_aes_cbc_hmac_sha1_init_sync,
+    qat_aes_cbc_hmac_sha1_cipher_sync,
+#endif
+    qat_aes_cbc_hmac_sha1_cleanup_sync,
+    sizeof(qat_chained_ctx),    /* ctx_size */
+    EVP_CIPH_FLAG_DEFAULT_ASN1?NULL:EVP_CIPHER_set_asn1_iv,
+    EVP_CIPH_FLAG_DEFAULT_ASN1?NULL:EVP_CIPHER_get_asn1_iv,
+    qat_aes_cbc_hmac_sha1_ctrl_sync,
+    NULL
+};
+
+#ifdef OPENSSL_QAT_ASYNCH
+/* Qat cipher AES128-SHA1 function structure declaration */
+EVP_CIPHER qat_aes_128_cbc_hmac_sha1_asynch = {
+    NID_aes_128_cbc_hmac_sha1,  /* nid */
+    AES_BLOCK_SIZE,             /* block_size */
+    AES_KEY_SIZE_128,           /* key_size in Bytes - defined in header */
+    AES_IV_LEN,                 /* iv_len in Bytes - defined in header */
+    qat_common_cbc_flags | EVP_CIPH_FLAG_AEAD_CIPHER | EVP_CIPH_FLAG_ASYNCH,
+    { .asynch = qat_aes_cbc_hmac_sha1_init_asynch },
+    { .asynch = qat_aes_cbc_hmac_sha1_cipher_asynch },
+    qat_aes_cbc_hmac_sha1_cleanup_asynch,
+    sizeof(qat_chained_ctx),    /* ctx_size */
+    EVP_CIPH_FLAG_DEFAULT_ASN1?NULL:EVP_CIPHER_set_asn1_iv,
+    EVP_CIPH_FLAG_DEFAULT_ASN1?NULL:EVP_CIPHER_get_asn1_iv,
+    qat_aes_cbc_hmac_sha1_ctrl_asynch,
+    NULL
+};
+#endif
+
+/* Qat cipher AES256-SHA1 function structure declaration */
+EVP_CIPHER qat_aes_256_cbc_hmac_sha1 = {
+    NID_aes_256_cbc_hmac_sha1,  /* nid */
+    AES_BLOCK_SIZE,             /* block_size */
+    AES_KEY_SIZE_256,           /* key_size in Bytes - defined in header */
+    AES_IV_LEN,                 /* iv_len in Bytes - defined in header */
+    qat_common_cbc_flags | EVP_CIPH_FLAG_AEAD_CIPHER,
+#ifdef OPENSSL_QAT_ASYNCH
+    { qat_aes_cbc_hmac_sha1_init_sync },
+    { qat_aes_cbc_hmac_sha1_cipher_sync },
+#else
+    qat_aes_cbc_hmac_sha1_init_sync,
+    qat_aes_cbc_hmac_sha1_cipher_sync,
+#endif
+    qat_aes_cbc_hmac_sha1_cleanup_sync,
+    sizeof(qat_chained_ctx),    /* ctx_size */
+    EVP_CIPH_FLAG_DEFAULT_ASN1?NULL:EVP_CIPHER_set_asn1_iv,
+    EVP_CIPH_FLAG_DEFAULT_ASN1?NULL:EVP_CIPHER_get_asn1_iv,
+    qat_aes_cbc_hmac_sha1_ctrl_sync,
+    NULL
+};
+
+#ifdef OPENSSL_QAT_ASYNCH
+/* Qat cipher AES256-SHA1 function structure declaration */
+EVP_CIPHER qat_aes_256_cbc_hmac_sha1_asynch = {
+    NID_aes_256_cbc_hmac_sha1,  /* nid */
+    AES_BLOCK_SIZE,             /* block_size */
+    AES_KEY_SIZE_256,           /* key_size in Bytes - defined in header */
+    AES_IV_LEN,                 /* iv_len in Bytes - defined in header */
+    qat_common_cbc_flags | EVP_CIPH_FLAG_AEAD_CIPHER | EVP_CIPH_FLAG_ASYNCH,
+    { .asynch = qat_aes_cbc_hmac_sha1_init_asynch },
+    { .asynch = qat_aes_cbc_hmac_sha1_cipher_asynch },
+    qat_aes_cbc_hmac_sha1_cleanup_asynch,
+    sizeof(qat_chained_ctx),    /* ctx_size */
+    EVP_CIPH_FLAG_DEFAULT_ASN1?NULL:EVP_CIPHER_set_asn1_iv,
+    EVP_CIPH_FLAG_DEFAULT_ASN1?NULL:EVP_CIPHER_get_asn1_iv,
+    qat_aes_cbc_hmac_sha1_ctrl_asynch,
+    NULL
+};
+#endif
+
+
+ /******************************************************************************
+* function:
+*         cipher_int_chained(EVP_CIPHER_CTX *evp_ctx,
+*                            qat_chained_ctx *qat_ctx,
+*                            const unsigned char* key,
+*                            const unsigned char* iv,
+*                            int enc)
+*
+* @param evp_ctx [IN] - pointer to the evp context
+* @param qat_ctx [IN] - pointer to the qat context
+* @param key     [IN] - pointer to the cipher key
+* @param iv      [IN] - pointer to the iv this maybe NULL.
+* @param enc     [IN] - whether we are doing encryption (1) or decryption (0).
+*
+* description:
+*    This function is to create QAT specific session data
+*    It is called from the session init function.
+*    it will return 1 if successful and 0 on failure.
+******************************************************************************/
+static int cipher_init_chained(EVP_CIPHER_CTX *evp_ctx, qat_chained_ctx *qat_ctx,
+                const unsigned char* key, const unsigned char* iv,
+                int enc)
+{
+    if ((!qat_ctx) || (!key) || (!evp_ctx))
+    {
+        WARN("[%s] --- qat_ctx or key or ctx is NULL.\n", __func__);
+        return 0;
+    }
+
+    qat_ctx->session_data = OPENSSL_malloc(sizeof(CpaCySymSessionSetupData));
+    if(NULL == qat_ctx->session_data)
+    {
+        WARN("OPENSSL_malloc() failed for session setup data allocation.\n");
+        return 0;
+    }
+
+    if (NULL != iv)
+        memcpy(evp_ctx->iv, iv, EVP_CIPHER_CTX_iv_length(evp_ctx));
+    else
+        memset(evp_ctx->iv, 0, EVP_CIPHER_CTX_iv_length(evp_ctx));
+
+    DUMPL("iv", iv, EVP_CIPHER_CTX_iv_length(evp_ctx));
+    DUMPL("key", key, EVP_CIPHER_CTX_key_length(evp_ctx));
+
+    /* Priority of this session */
+    qat_ctx->session_data->sessionPriority = CPA_CY_PRIORITY_HIGH;
+    qat_ctx->session_data->symOperation = CPA_CY_SYM_OP_ALGORITHM_CHAINING;
+
+    /* Cipher algorithm and mode */
+    qat_ctx->session_data->cipherSetupData.cipherAlgorithm = CPA_CY_SYM_CIPHER_AES_CBC;
+    /* Cipher key length 256 bits (32 bytes) */
+    qat_ctx->session_data->cipherSetupData.cipherKeyLenInBytes = (Cpa32U)EVP_CIPHER_CTX_key_length(evp_ctx);
+    /* Cipher key */
+    if(NULL == (qat_ctx->session_data->cipherSetupData.pCipherKey = OPENSSL_malloc(EVP_CIPHER_CTX_key_length(evp_ctx))))
+    {
+        WARN("[%s] --- unable to allocate memory for Cipher key.\n", __func__);
+        goto end;
+    }
+
+    memcpy(qat_ctx->session_data->cipherSetupData.pCipherKey, key, EVP_CIPHER_CTX_key_length(evp_ctx));
+
+    /* Operation to perform */
+    if(enc)
+    {
+        qat_ctx->session_data->cipherSetupData.cipherDirection =
+                        CPA_CY_SYM_CIPHER_DIRECTION_ENCRYPT;
+        qat_ctx->session_data->algChainOrder =
+                        CPA_CY_SYM_ALG_CHAIN_ORDER_HASH_THEN_CIPHER;
+    } else
+    {
+        qat_ctx->session_data->cipherSetupData.cipherDirection =
+                        CPA_CY_SYM_CIPHER_DIRECTION_DECRYPT;
+        qat_ctx->session_data->algChainOrder =
+                        CPA_CY_SYM_ALG_CHAIN_ORDER_CIPHER_THEN_HASH;
+    }
+
+    /* Hash Configuration */
+    qat_ctx->session_data->hashSetupData.hashAlgorithm = CPA_CY_SYM_HASH_SHA1;
+    qat_ctx->session_data->hashSetupData.hashMode = CPA_CY_SYM_HASH_MODE_AUTH;
+    qat_ctx->session_data->hashSetupData.digestResultLenInBytes = SHA_DIGEST_LENGTH;
+    qat_ctx->session_data->hashSetupData.authModeSetupData.aadLenInBytes = 0;
+
+    qat_ctx->hmac_key = OPENSSL_malloc(HMAC_KEY_SIZE);
+    if(NULL == qat_ctx->hmac_key)
+    {
+        WARN("[%s] Unable to allocate memory or HMAC Key\n", __func__);
+        goto end;
+    }
+    memset(qat_ctx->hmac_key, 0, HMAC_KEY_SIZE);
+    qat_ctx->session_data->hashSetupData.authModeSetupData.authKey = qat_ctx->hmac_key;
+    qat_ctx->session_data->hashSetupData.authModeSetupData.authKeyLenInBytes = HMAC_KEY_SIZE;
+
+    qat_ctx->initParamsSet = 1;
+    qat_ctx->payload_length = NO_PAYLOAD_LENGTH_SPECIFIED;
+
+    return 1;
+
+    end:
+      if (NULL != qat_ctx->session_data)
+      {
+          if (NULL != qat_ctx->session_data->cipherSetupData.pCipherKey)
+          {
+              OPENSSL_free(qat_ctx->session_data->cipherSetupData.pCipherKey);
+              qat_ctx->session_data->cipherSetupData.pCipherKey = NULL;
+          }
+          OPENSSL_free(qat_ctx->session_data);
+          qat_ctx->session_data = NULL;
+      }
+      return 0;
+}
+
+/******************************************************************************
+* function:
+*         qat_aes_cbc_hmac_sha1_init(EVP_CIPHER_CTX *ctx,
+*                                    const unsigned char *inkey,
+*                                    const unsigned char *iv,
+*                                    int enc)
+*
+* @param ctx    [IN]  - pointer to existing ctx
+* @param inKey  [IN]  - input cipher key
+* @param iv     [IN]  - initialisation vector
+* @param enc    [IN]  - 1 encrypt 0 decrypt
+*
+* @retval 1      function succeeded
+* @retval 0      function failed
+*
+* description:
+*    This function initialises the cipher and hash algorithm parameters for this
+*  EVP context.
+*
+******************************************************************************/
+static int qat_aes_cbc_hmac_sha1_init(EVP_CIPHER_CTX *ctx,
+                        const unsigned char *inkey,
+                        const unsigned char *iv, int enc,
+                        int (*cb)(unsigned char *out, int outl,
+                                  void *cb_data, int status))
+{
+
+    /* Initialise a QAT session  and set the cipher keys*/
+    qat_chained_ctx* qat_ctx = NULL;
+
+    if (!ctx || !inkey)
+    {
+        WARN("[%s] ctx or inkey is NULL.\n", __func__);
+        return 0;
+    }
+
+    qat_ctx = data(ctx);
+    if (!qat_ctx)
+    {
+        WARN("[%s] --- qat_ctx is NULL.\n", __func__);
+        return 0;
+    }
+
+    if(cb) /*Async Mode*/
+    {
+        qat_ctx->cipher_cb = cb;
+    }
+    else /*Sync Mode*/
+    {
+        /* Pre-allocate necessary memory */
+        /* This is a whole block the size of the memory alignment.
+           If the alignment was to become smaller than the header size
+           (TLS_VIRT_HEADER_SIZE) which is unlikely then we would need
+            to add some more logic here to work how many blocks of size
+            QAT_BYTE_ALIGNMENT we need to allocate to fit the header in. */
+        qat_ctx->tls_virt_hdr = qaeCryptoMemAlloc(QAT_BYTE_ALIGNMENT, __FILE__, __LINE__);
+        if(NULL == qat_ctx->tls_virt_hdr)
+        {
+            WARN("[%s] Unable to allcoate memory for MAC preamble\n", __func__);
+            return 0;
+        }
+        memset(qat_ctx->tls_virt_hdr, 0, QAT_BYTE_ALIGNMENT);
+        qat_ctx->srcFlatBuffer[0].pData = qat_ctx->tls_virt_hdr;
+        qat_ctx->srcFlatBuffer[0].dataLenInBytes = QAT_BYTE_ALIGNMENT;
+        qat_ctx->dstFlatBuffer[0].pData = qat_ctx->srcFlatBuffer[0].pData;
+        qat_ctx->dstFlatBuffer[0].dataLenInBytes = QAT_BYTE_ALIGNMENT;
+
+        qat_ctx->pIv = qaeCryptoMemAlloc(EVP_CIPHER_CTX_iv_length(ctx), __FILE__, __LINE__);
+        if(!qat_ctx->pIv)
+        {
+            WARN("[%s] --- pIv is NULL.\n", __func__);
+            goto end;
+        }
+    }
+
+    if(!cipher_init_chained(ctx, qat_ctx, inkey, iv, enc))
+    {
+        WARN("[%s] cipher_init_chained failed.\n", __func__);
+        goto end;
+    }
+
+    return 1;
+
+    end:
+        if(NULL != qat_ctx->tls_virt_hdr)
+        {
+            qaeCryptoMemFree(qat_ctx->tls_virt_hdr);
+            qat_ctx->tls_virt_hdr = NULL;
+        }
+        if(NULL != qat_ctx->pIv)
+        {
+            qaeCryptoMemFree(qat_ctx->pIv);
+            qat_ctx->pIv=NULL;
+        }
+
+        return 0;
+
+}
+
+/******************************************************************************
+* function:
+*    qat_aes_cbc_hmac_sha1_ctrl(EVP_CIPHER_CTX *ctx,
+*                               int type, int arg, void *ptr)
+*
+* @param ctx    [IN]  - pointer to existing ctx
+* @param type   [IN]  - type of request either
+*                       EVP_CTRL_AEAD_SET_MAC_KEY or EVP_CTRL_AEAD_TLS1_AAD
+* @param arg    [IN]  - size of the pointed to by ptr
+* @param ptr    [IN]  - input buffer contain the necessary parameters
+*
+* @retval x      The return value is dependent on the type of request being made
+*       EVP_CTRL_AEAD_SET_MAC_KEY return of 1 is success
+*       EVP_CTRL_AEAD_TLS1_AAD return value indicates the amount fo padding to
+*               be applied to the SSL/TLS record
+* @retval -1     function failed
+*
+* description:
+*    This function is a generic control interface provided by the EVP API. For
+*  chained requests this interface is used fro setting the hmac key value for
+*  authentication of the SSL/TLS record. The second type is used to specify the
+*  TLS virtual header which is used in the authentication calculationa nd to
+*  identify record payload size.
+*
+******************************************************************************/
+static int qat_aes_cbc_hmac_sha1_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr, int enableAsync)
+{
+    qat_chained_ctx *evp_ctx = NULL;
+    int retVal = 0;
+
+    if (!ctx)
+    {
+        WARN("[%s] --- ctx parameter is NULL.\n", __func__);
+        return -1;
+    }
+
+    evp_ctx = data(ctx);
+
+    if (!evp_ctx)
+    {
+        WARN("[%s] --- evp_ctx is NULL.\n", __func__);
+        return -1;
+    }
+
+    switch (type)
+    {
+        case EVP_CTRL_AEAD_SET_MAC_KEY:
+        {
+            unsigned char *hmac_key = evp_ctx->hmac_key;
+            CpaCySymSessionSetupData* sessionSetupData = evp_ctx->session_data;
+
+            if(NULL == hmac_key || NULL == sessionSetupData)
+            {
+                WARN("[%s] --- HMAC Key or sessionSetupData are NULL", __func__);
+                return -1;
+            }
+
+            memset (hmac_key,0,HMAC_KEY_SIZE);
+
+            if (arg > HMAC_KEY_SIZE)
+            {
+                SHA1_Init(&(evp_ctx->key_wrap));
+                SHA1_Update(&(evp_ctx->key_wrap),ptr,arg);
+                SHA1_Final(hmac_key,&(evp_ctx->key_wrap));
+                sessionSetupData->hashSetupData.authModeSetupData.authKeyLenInBytes = HMAC_KEY_SIZE;
+            }
+            else
+            {
+                memcpy(hmac_key,ptr,arg);
+                sessionSetupData->hashSetupData.authModeSetupData.authKeyLenInBytes = arg;
+            }
+
+            DUMPL("hmac_key", hmac_key, arg);
+
+            evp_ctx->initHmacKeySet = 1;
+            retVal = 1;
+            break;
+        }
+        case EVP_CTRL_AEAD_TLS1_AAD:
+        {
+            /* Values to include in the record MAC calculation are included in this type
+               This returns the amount of padding required for the send/encrypt direction */
+            unsigned char *p=ptr;
+            unsigned int   len=(p[arg-QAT_TLS_PAYLOADLENGTH_MSB_OFFSET]<<QAT_BYTE_SHIFT
+                               | p[arg-QAT_TLS_PAYLOADLENGTH_LSB_OFFSET]);
+
+            if (arg < TLS_VIRT_HDR_SIZE)
+            {
+                retVal = -1;
+                break;
+            }
+            evp_ctx->tls_version = (p[arg-QAT_TLS_VERSION_MSB_OFFSET]<<QAT_BYTE_SHIFT
+                    | p[arg-QAT_TLS_VERSION_LSB_OFFSET]);
+            if(enableAsync)
+            {
+                evp_ctx->payload_length = len;
+                memcpy(evp_ctx->tls_hdr,ptr,TLS_VIRT_HDR_SIZE);
+            }
+
+            if (ctx->encrypt)
+            {
+                if(!enableAsync)
+                {
+                    evp_ctx->payload_length = len;
+                    if (evp_ctx->tls_version >= TLS1_1_VERSION)
+                    {
+                        len -= AES_BLOCK_SIZE;
+                        //BWILL: Why does this code reduce the len in the TLS header by the IV for the framework?
+                        p[arg-QAT_TLS_PAYLOADLENGTH_MSB_OFFSET] = len>>QAT_BYTE_SHIFT;
+                        p[arg-QAT_TLS_PAYLOADLENGTH_LSB_OFFSET] = len;
+                    }
+
+                    if(NULL == evp_ctx->tls_virt_hdr)
+                    {
+                        WARN("Unable to allocate memory for mac preamble in qat/n");
+                        return -1;
+                    }
+                    /* Copy the header from p into the QAT_BYTE_ALIGNMENT sized buffer so that
+                       the header is in the final part of the buffer*/
+                    memcpy(evp_ctx->tls_virt_hdr + (QAT_BYTE_ALIGNMENT - TLS_VIRT_HDR_SIZE), p, TLS_VIRT_HDR_SIZE);
+                    DUMPL("tls_virt_hdr", evp_ctx->tls_virt_hdr + (QAT_BYTE_ALIGNMENT - TLS_VIRT_HDR_SIZE), arg);
+                }
+                retVal = (int)(((len+SHA_DIGEST_LENGTH+AES_BLOCK_SIZE)&-AES_BLOCK_SIZE) - len);
+                break;
+            }
+            else
+            {
+                if(!enableAsync)
+                {
+                    /* Copy the header from ptr into the QAT_BYTE_ALIGNMENT sized buffer so that
+                       the header is in the final part of the buffer*/
+                    if (arg> TLS_VIRT_HDR_SIZE) arg =  TLS_VIRT_HDR_SIZE;
+                    memcpy(evp_ctx->tls_virt_hdr + (QAT_BYTE_ALIGNMENT - TLS_VIRT_HDR_SIZE) ,ptr,arg);
+                    evp_ctx->payload_length = arg;
+                }
+                retVal = SHA_DIGEST_LENGTH;
+                break;
+            }
+        }
+        default:
+        {
+            WARN("[%s] --- unknown type parameter.\n", __func__);
+            return -1;
+        }
+    }
+    return retVal;
+}
+
+/******************************************************************************
+* function:
+*    qat_aes_cbc_hmac_sha1_cleanup(EVP_CIPHER_CTX *ctx, unsigned int enableAsync)
+*
+* @param ctx    [IN]  - pointer to existing ctx
+* @param enableAsync    [IN]  - Type of mode(.i.e,) Sync or Async
+*
+* @retval 1      function succeeded
+* @retval 0      function failed
+*
+* description:
+*    This function will cleanup all allocated resources required to perfrom the
+*  cryptographic transform.
+*
+******************************************************************************/
+static int qat_aes_cbc_hmac_sha1_cleanup(EVP_CIPHER_CTX *ctx, unsigned int enableAsync)
+{
+    qat_chained_ctx* evp_ctx = NULL;
+    CpaStatus sts = 0;
+    CpaCySymSessionSetupData* sessSetup = NULL;
+    int retVal = 1;
+#ifdef OPENSSL_QAT_ASYNCH
+    int count = 0;
+    Cpa64U num_inflight = 0;
+    struct timespec reqTime = {0};
+    struct timespec remTime = {0};
+#endif
+
+    if (!ctx)
+    {
+        WARN("[%s] ctx parameter is NULL.\n", __func__);
+        return 0;
+    }
+
+    evp_ctx = data(ctx);
+
+    if (!evp_ctx)
+    {
+        WARN("[%s] evp_ctx parameter is NULL.\n", __func__);
+        return 0;
+    }
+
+    if(!(evp_ctx->init))
+    {
+        /* It is valid to call cleanup even if the context has not been initialised. */
+        return retVal;
+    }
+
+    sessSetup = evp_ctx->session_data;
+    if(sessSetup)
+    {
+        if(evp_ctx->qat_ctx)
+        {
+#ifdef OPENSSL_QAT_ASYNCH
+			if(enableAsync)
+			{
+				/* Check for inflight requests */
+				num_inflight = evp_ctx->noRequests - evp_ctx->noResponses;
+				DEBUG("async chaining clean up %lu inflight\n",(evp_ctx->noRequests-evp_ctx->noResponses));
+				while((0 != num_inflight) && (count < QAT_CIPHER_CLEANUP_RETRY_COUNT))
+				{
+					count++;
+					/* Wait for some time */
+					reqTime.tv_nsec = QAT_CIPHER_CLEANUP_WAIT_TIME_NS;
+					do
+					{
+						nanosleep(&reqTime, &remTime);
+						reqTime.tv_sec = remTime.tv_sec;
+						reqTime.tv_nsec = remTime.tv_nsec;
+						if((errno < 0) && (EINTR != errno))
+						{
+							WARN("nanosleep system call failed: errno %i\n", errno);
+							break;
+						}
+					} while (EINTR == errno);
+
+					num_inflight = evp_ctx->noRequests - evp_ctx->noResponses;
+				}
+
+				if(0 != num_inflight)
+				{
+					WARN("[%s] --- Still %ld chained messages in flight.\n",
+					__func__, num_inflight);
+					return 0;
+				}
+			}
+#endif
+            if((sts = cpaCySymRemoveSession(evp_ctx->instanceHandle, evp_ctx->qat_ctx))
+               != CPA_STATUS_SUCCESS)
+            {
+                WARN("[%s] cpaCySymRemoveSession FAILED, sts = %d.!\n", __func__, sts);
+                retVal = 0;
+                /* Lets not return yet and instead make a best effort to
+                   cleanup the rest to avoid memory leaks*/
+            }
+            qaeCryptoMemFree(evp_ctx->qat_ctx);
+            evp_ctx->qat_ctx = NULL;
+        }
+        if(sessSetup->hashSetupData.authModeSetupData.authKey)
+        {
+            OPENSSL_free(sessSetup->hashSetupData.authModeSetupData.authKey);
+            sessSetup->hashSetupData.authModeSetupData.authKey = NULL;
+        }
+		if(!enableAsync)
+		{
+			if(evp_ctx->tls_virt_hdr)
+			{
+				qaeCryptoMemFree(evp_ctx->tls_virt_hdr);
+				evp_ctx->tls_virt_hdr = NULL;
+			}
+			if(evp_ctx->srcBufferList.pPrivateMetaData)
+			{
+				qaeCryptoMemFree(evp_ctx->srcBufferList.pPrivateMetaData);
+				evp_ctx->srcBufferList.pPrivateMetaData = NULL;
+			}
+			if(evp_ctx->dstBufferList.pPrivateMetaData)
+			{
+				qaeCryptoMemFree(evp_ctx->dstBufferList.pPrivateMetaData);
+				evp_ctx->dstBufferList.pPrivateMetaData = NULL;
+			}
+			if(evp_ctx->pIv)
+			{
+				qaeCryptoMemFree(evp_ctx->pIv);
+				evp_ctx->pIv = NULL;
+
+			}
+		}
+        if(sessSetup->cipherSetupData.pCipherKey)
+        {
+            OPENSSL_free(sessSetup->cipherSetupData.pCipherKey);
+            sessSetup->cipherSetupData.pCipherKey = NULL;
+        }
+        OPENSSL_free(sessSetup);
+    }
+    evp_ctx->init = 0;
+	if(!enableAsync)
+	{
+		evp_ctx->payload_length = NO_PAYLOAD_LENGTH_SPECIFIED;
+	}
+    return retVal;
+}
+
+
+/******************************************************************************
+* function:
+*         qat_aes_sha1_session_init(EVP_CIPHER_CTX *ctx)
+*
+* @param ctx [IN] - pointer to context
+*
+* @retval 1      function succeeded
+* @retval 0      function failed
+*
+* description:
+*    This function synchronises the initialisation of the QAT session and
+*  pre-allocates the necessary buffers for the session.
+******************************************************************************/
+static int qat_aes_sha1_session_init(EVP_CIPHER_CTX *ctx)
+{
+    qat_chained_ctx* evp_ctx = NULL;
+    CpaCySymSessionSetupData *sessionSetupData = NULL;
+    Cpa32U sessionCtxSize = 0;
+    CpaCySymSessionCtx pSessionCtx = NULL;
+    Cpa32U metaSize = 0;
+
+    if(!ctx)
+    {
+        WARN("[%s] --- parameters ctx is NULL.\n", __func__);
+        return 0;
+    }
+
+    evp_ctx = data(ctx);
+
+    if (!evp_ctx)
+    {
+        WARN("[%s] --- evp_ctx is NULL.\n", __func__);
+        return 0;
+    }
+
+    /* All parameters have not been set yet or we have already been initialised. */
+    if((1 != evp_ctx->initParamsSet) ||
+	(1 == evp_ctx->init))
+    {
+	WARN("[%s] --- parameters not set or initialised yet.\n", __func__);
+        return 0;
+    }
+
+    sessionSetupData = evp_ctx->session_data;
+    evp_ctx->instanceHandle = get_next_inst();
+
+    if (!evp_ctx->instanceHandle || !sessionSetupData)
+    {
+        WARN("[%s] --- evp_ctx->instanceHandle or sessionSetupData are NULL.\n", __func__);
+        return 0;
+    }
+
+    if (cpaCySymSessionCtxGetSize(evp_ctx->instanceHandle, sessionSetupData,
+                        &sessionCtxSize) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCySymSessionCtxGetSize failed.\n", __func__);
+        return 0;
+    }
+
+    pSessionCtx = (CpaCySymSessionCtx) qaeCryptoMemAlloc(sessionCtxSize, __FILE__, __LINE__);
+    if (NULL == pSessionCtx)
+    {
+        WARN("[%s] --- pSessionCtx malloc failed !\n", __func__);
+        return 0;
+    }
+
+    if(ctx->encrypt)
+        sessionSetupData->verifyDigest = CPA_FALSE;
+    else
+        sessionSetupData->verifyDigest = CPA_TRUE;
+
+    sessionSetupData->digestIsAppended =  CPA_TRUE;
+
+    if (cpaCySymInitSession(evp_ctx->instanceHandle, qat_crypto_callbackFn, sessionSetupData,
+              pSessionCtx) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCySymInitSession failed.\n", __func__);
+        qaeCryptoMemFree(pSessionCtx);
+        return 0;
+    }
+
+    evp_ctx->qat_ctx = pSessionCtx;
+
+    evp_ctx->srcBufferList.numBuffers = 2;
+    evp_ctx->srcBufferList.pBuffers = (evp_ctx->srcFlatBuffer);
+    evp_ctx->srcBufferList.pUserData = NULL;
+
+    evp_ctx->dstBufferList.numBuffers = 2;
+    evp_ctx->dstBufferList.pBuffers = (evp_ctx->dstFlatBuffer);
+    evp_ctx->dstBufferList.pUserData = NULL;
+
+    /* setup meta data for buffer lists */
+    if (cpaCyBufferListGetMetaSize(evp_ctx->instanceHandle,
+                                   evp_ctx->srcBufferList.numBuffers,
+                                   &metaSize) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCyBufferListGetBufferSize failed.\n",__func__);
+	qaeCryptoMemFree(pSessionCtx);
+        return 0;
+    }
+
+    if (metaSize)
+    {
+        evp_ctx->srcBufferList.pPrivateMetaData = qaeCryptoMemAlloc(metaSize, __FILE__, __LINE__);
+        if (!(evp_ctx->srcBufferList.pPrivateMetaData))
+        {
+            WARN("[%s] --- srcBufferList.pPrivateMetaData is NULL.\n", __func__);
+	    qaeCryptoMemFree(pSessionCtx);
+            return 0;
+        }
+    }
+    else
+    {
+        evp_ctx->srcBufferList.pPrivateMetaData = NULL;
+    }
+    metaSize = 0;
+
+    if (cpaCyBufferListGetMetaSize(evp_ctx->instanceHandle,
+                                   evp_ctx->dstBufferList.numBuffers,
+                                   &metaSize) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCyBufferListGetBufferSize failed.\n",__func__);
+	if (evp_ctx->srcBufferList.pPrivateMetaData)
+	{
+	    qaeCryptoMemFree(evp_ctx->srcBufferList.pPrivateMetaData);
+	    evp_ctx->srcBufferList.pPrivateMetaData=NULL;
+	}
+	qaeCryptoMemFree(pSessionCtx);
+        return 0;
+    }
+
+    if (metaSize)
+    {
+        evp_ctx->dstBufferList.pPrivateMetaData = qaeCryptoMemAlloc(metaSize, __FILE__, __LINE__);
+        if (!(evp_ctx->dstBufferList.pPrivateMetaData))
+        {
+            WARN("[%s] --- dstBufferList.pPrivateMetaData is NULL.\n", __func__);
+	    if (evp_ctx->srcBufferList.pPrivateMetaData)
+            {
+                qaeCryptoMemFree(evp_ctx->srcBufferList.pPrivateMetaData);
+                evp_ctx->srcBufferList.pPrivateMetaData=NULL;
+            }
+            qaeCryptoMemFree(pSessionCtx);
+            return 0;
+        }
+    }
+    else
+    {
+        evp_ctx->dstBufferList.pPrivateMetaData = NULL;
+    }
+
+    /* Create the OpData structure to remove this processing from the data path */
+    evp_ctx->OpData.sessionCtx = evp_ctx->qat_ctx;
+    evp_ctx->OpData.packetType = CPA_CY_SYM_PACKET_TYPE_FULL;
+
+    evp_ctx->OpData.pIv = evp_ctx->pIv;
+    evp_ctx->OpData.ivLenInBytes = (Cpa32U)EVP_CIPHER_CTX_iv_length(ctx);
+    /* We want to ensure the start of crypto data is on a 64 byte, aligned
+       boundary. This is for QAT internal performance reasons. */
+    evp_ctx->OpData.cryptoStartSrcOffsetInBytes = QAT_BYTE_ALIGNMENT;
+    /* We start hashing from the start of the header. Due to needing the crypto
+       data aligned to a 64 byte boundary we need to start the header that comes
+       first at an offset into the 64 byte aligned block so the header will
+       end on a 64 byte alignment. */
+    evp_ctx->OpData.hashStartSrcOffsetInBytes = QAT_BYTE_ALIGNMENT - TLS_VIRT_HDR_SIZE;
+    evp_ctx->OpData.pAdditionalAuthData = NULL;
+
+    evp_ctx->init = 1;
+
+    return 1;
+}
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*         qat_cipherAsynchCallbackFnChained(void *callbackTag,
+*                                           CpaStatus status,
+*                                           const CpaCySymOp operationType,
+*                                           void *pOpData,
+*                                           CpaBufferList * pDstBuffer,
+*                                           CpaBoolean verifyResult)
+*
+* @param callbackTag  [IN] - the op_done_asynch structure
+* @param status       [IN] - whether the operation was successful.
+* @param operationType[IN] - the type of operation.
+* @param pOpData      [IN] - pointer to callback data (not currently used
+*                            in this function apart from debug).
+* @param pDstBuffer   [IN] - buffer containing data that has been
+*                            encrypted/decrypted
+* @param verifyResult [IN] - flag whether to verify the result.
+*
+* description:
+*    Asynch callback function for chained operations.
+******************************************************************************/
+static void qat_cipherAsynchCallbackFnChained(void *callbackTag, CpaStatus status,
+                           const CpaCySymOp operationType, void *pOpData,
+                           CpaBufferList * pDstBuffer, CpaBoolean verifyResult)
+{
+    struct op_done_asynch *op_done = (struct op_done_asynch *)callbackTag;
+    qat_chained_ctx* qat_context;
+
+    if(NULL == op_done)
+    {
+        WARN("[%s] --- Invalid input parameter to callback.\n", __func__);
+        QATerr(QAT_F_QAT_CIPHERASYNCHCALLBACKFNCHAINED, QAT_R_INVALID_INPUT_PARAMETER);
+        return;
+    }
+
+    qat_context = (qat_chained_ctx*)op_done->qat_ctx.chain;
+
+    DEBUG("[%s]: status %d verifyResult %d\n", __func__, status,
+          verifyResult);
+    op_done->verifyResult = verifyResult;
+
+    if(EVP_CIPHER_CTX_flags(op_done->cipher_ctx) & EVP_CIPH_CBC_MODE)
+    {
+        if(op_done->cipher_ctx->encrypt)
+        {
+            memcpy(op_done->cipher_ctx->iv,
+                   (pDstBuffer->pBuffers[1].pData +
+			pDstBuffer->pBuffers[1].dataLenInBytes  -
+			EVP_CIPHER_CTX_iv_length(op_done->cipher_ctx)),
+                   EVP_CIPHER_CTX_iv_length(op_done->cipher_ctx));
+        }
+    }
+
+    DUMPREQ(qat_context->instanceHandle, op_done, (CpaCySymOpData* )pOpData,
+            qat_context->session_data, pDstBuffer, pDstBuffer);
+
+    if (!isZeroCopy())
+    {
+        memcpy(op_done->cur_out, pDstBuffer->pBuffers[1].pData,
+	       pDstBuffer->pBuffers[1].dataLenInBytes);
+    }
+    else
+    {
+        op_done->cur_out = pDstBuffer->pBuffers[1].pData;
+    }
+
+    int cb_status = 0;
+    if (op_done->cipher_ctx->encrypt)
+    {
+        cb_status = (status == CPA_STATUS_SUCCESS);
+    }
+    else
+    {
+        cb_status = (status == CPA_STATUS_SUCCESS && verifyResult);
+    }
+
+    qat_context->cipher_cb(op_done->orig_out, op_done->orig_len,
+			   op_done->cb_data, cb_status);
+
+    /* QAT structure allocations */
+    if(NULL != op_done->agg_req)
+	destroy_request(op_done->agg_req);
+    if(NULL != op_done)
+        OPENSSL_free(op_done);
+
+    /* Update Reception stats */
+    qat_context->noResponses++;
+}
+#endif
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*         qat_aes_sha1_session_init_asynch(EVP_CIPHER_CTX *ctx)
+*
+* @param ctx [IN] - pointer to context
+*
+* @retval 1      function succeeded
+* @retval 0      function failed
+*
+* description:
+*    This function synchronises the initialisation of the QAT session and
+*  pre-allocates the necessary buffers for the session.
+******************************************************************************/
+static int qat_aes_sha1_session_init_asynch(EVP_CIPHER_CTX *ctx)
+{
+    qat_chained_ctx* evp_ctx = NULL;
+    CpaCySymSessionSetupData *sessionSetupData = NULL;
+    Cpa32U sessionCtxSize = 0;
+    CpaCySymSessionCtx pSessionCtx = NULL;
+
+    if (!ctx)
+    {
+        WARN("[%s] --- ctx parameter is NULL.\n", __func__);
+        goto end;
+    }
+
+	evp_ctx = data(ctx);
+
+    if (!evp_ctx)
+    {
+        WARN("[%s] --- evp_ctx is NULL.\n", __func__);
+        goto end;
+    }
+
+    /* All parameters have not been set yet or the CTX has already been initialised */
+    if((1 != evp_ctx->initParamsSet) ||
+	(1 == evp_ctx->init))
+        goto end;
+
+    sessionSetupData = evp_ctx->session_data;
+    evp_ctx->instanceHandle = get_next_inst();
+	if (!evp_ctx->instanceHandle || !sessionSetupData)
+	{
+        WARN("[%s] --- evp_ctx->instanceHandle or sessionSetupData are NULL.\n", __func__);
+        goto end;
+    }
+
+    if (cpaCySymSessionCtxGetSize(evp_ctx->instanceHandle, sessionSetupData,
+                        &sessionCtxSize) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCySymSessionCtxGetSize failed.\n", __func__);
+        goto end;
+    }
+
+    pSessionCtx = (CpaCySymSessionCtx) qaeCryptoMemAlloc(sessionCtxSize, __FILE__, __LINE__);
+
+    if (NULL == pSessionCtx)
+    {
+        WARN("[%s] --- pSessionCtx qaeCryptoMemAlloc failed !\n", __func__);
+        goto end;
+    }
+
+    if(ctx->encrypt)
+       sessionSetupData->verifyDigest = CPA_FALSE;
+    else
+       sessionSetupData->verifyDigest = CPA_TRUE;
+
+    sessionSetupData->digestIsAppended =  CPA_TRUE;
+
+    if (cpaCyBufferListGetMetaSize(evp_ctx->instanceHandle,
+                                   2,
+                                   &(evp_ctx->meta_size)) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCyBufferListGetBufferSize failed.\n",__func__);
+        goto end;
+    }
+
+    if (cpaCySymInitSession(evp_ctx->instanceHandle, qat_cipherAsynchCallbackFnChained,
+                            sessionSetupData, pSessionCtx) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCySymInitSession failed.\n", __func__);
+        goto end;
+    }
+
+    evp_ctx->qat_ctx = pSessionCtx;
+    evp_ctx->init = 1;
+
+    return 1;
+
+    end:
+	if (NULL != pSessionCtx)
+	    qaeCryptoMemFree(pSessionCtx);
+	return 0;
+}
+#endif
+
+
+/******************************************************************************
+* function:
+*         qat_aes_cbc_hmac_sha1_init_sync(EVP_CIPHER_CTX *ctx,
+*                                    const unsigned char *inkey,
+*                                    const unsigned char *iv,
+*                                    int enc)
+*
+* @param ctx    [IN]  - pointer to existing ctx
+* @param inKey  [IN]  - input cipher key
+* @param iv     [IN]  - initialisation vector
+* @param enc    [IN]  - 1 encrypt 0 decrypt
+*
+* @retval 1      function succeeded
+* @retval 0      function failed
+*
+* description:
+*    This function initialises the cipher and hash algorithm parameters for this
+*  EVP context.
+*
+******************************************************************************/
+int qat_aes_cbc_hmac_sha1_init_sync(EVP_CIPHER_CTX *ctx,
+                        const unsigned char *inkey,
+                        const unsigned char *iv, int enc)
+{
+    return qat_aes_cbc_hmac_sha1_init(ctx, inkey,iv,enc,NULL);
+}
+
+/******************************************************************************
+* function:
+*    qat_aes_cbc_hmac_sha1_cipher_sync(EVP_CIPHER_CTX *ctx, unsigned char *out,
+*                                 const unsigned char *in, size_t len)
+*
+* @param ctx    [IN]  - pointer to existing ctx
+* @param out   [OUT]  - output buffer for transform result
+* @param in     [IN]  - input buffer
+* @param len    [IN]  - length of input buffer
+*
+* @retval 0      function failed
+* @retval 1      function succeeded
+*
+* description:
+*    This function performs the cryptographic transform according to the
+*  parameters setup during initialisation.
+*
+******************************************************************************/
+int qat_aes_cbc_hmac_sha1_cipher_sync(EVP_CIPHER_CTX *ctx, unsigned char *out,
+                                        const unsigned char *in, size_t len)
+{
+    CpaStatus sts = 0;
+    unsigned int pad_len = 0;
+    struct op_done opDone;
+    qat_chained_ctx *evp_ctx = NULL;
+    int retVal = 0, rc = 1;
+    size_t plen = 0,
+           iv   = 0; /* explicit IV in TLS 1.1 and later */
+
+    CRYPTO_QAT_LOG("CIPHER - %s\n", __func__);
+
+    if (!ctx || !in || !out)
+    {
+        WARN("[%s] --- ctx, in or out parameters are NULL.\n", __func__);
+        return 0;
+    }
+
+    evp_ctx = data(ctx);
+
+    if (!evp_ctx)
+    {
+        WARN("[%s] --- evp_ctx is NULL.\n", __func__);
+        return 0;
+    }
+
+    if (len%AES_BLOCK_SIZE)
+    {
+    WARN("[%s] --- len is not a multiple of the AES_BLOCK_SIZE.\n", __func__);
+        return 0;
+    }
+
+    if (!(evp_ctx->init))
+    {
+        if(0 == qat_aes_sha1_session_init(ctx))
+        {
+            WARN("[%s] --- Unable to initialise Cipher context.\n", __func__);
+            return 0;
+        }
+    }
+
+    plen = evp_ctx->payload_length;
+    if (NO_PAYLOAD_LENGTH_SPECIFIED == plen)
+        plen = len - SHA_DIGEST_LENGTH;
+    else if (ctx->encrypt && len!=((plen+SHA_DIGEST_LENGTH+AES_BLOCK_SIZE)&-AES_BLOCK_SIZE))
+        return 0;
+    else if (evp_ctx->tls_version >= TLS1_1_VERSION)
+    {
+        iv = AES_BLOCK_SIZE;
+        memcpy(evp_ctx->OpData.pIv, in, EVP_CIPHER_CTX_iv_length(ctx));
+        /* Note: The OpenSSL framework assumes that the IV field will be part of the
+         * encrypted data, yet never looks at the output of the encryption/decryption
+         * process for this field. In order to chain HASH and CIPHER we need to present
+         * contiguous SGL to QAT, thus we need to copy the IV from input to output in
+         * in order to skip this field in encryption */
+        if(in != out)
+            memcpy(out, in, EVP_CIPHER_CTX_iv_length(ctx));
+        in += iv;
+        out += iv;
+        len -= iv;
+        evp_ctx->payload_length -= iv;
+        plen -= iv;
+    }
+    else
+        memcpy(evp_ctx->OpData.pIv, ctx->iv, EVP_CIPHER_CTX_iv_length(ctx));
+
+    /* Build request/response buffers */
+    if (isZeroCopy())
+    {
+        evp_ctx->srcFlatBuffer[1].pData = (Cpa8U*)in;
+        evp_ctx->dstFlatBuffer[1].pData = (Cpa8U*)out;
+    }
+    else
+    {
+        evp_ctx->srcFlatBuffer[1].pData = qaeCryptoMemAlloc(len, __FILE__, __LINE__);
+        if(!(evp_ctx->srcFlatBuffer[1].pData))
+        {
+            WARN("[%s] --- src/dst buffer allocation.\n", __func__);
+            return 0;
+        }
+        evp_ctx->dstFlatBuffer[1].pData = evp_ctx->srcFlatBuffer[1].pData;
+        memcpy(evp_ctx->dstFlatBuffer[1].pData, in, len);
+    }
+    evp_ctx->srcFlatBuffer[1].dataLenInBytes = len;
+    evp_ctx->srcBufferList.pUserData = NULL;
+    evp_ctx->dstFlatBuffer[1].dataLenInBytes = len;
+    evp_ctx->dstBufferList.pUserData = NULL;
+
+    evp_ctx->OpData.messageLenToCipherInBytes = len;
+
+    if(NO_PAYLOAD_LENGTH_SPECIFIED == evp_ctx->payload_length)
+    {
+        evp_ctx->OpData.messageLenToHashInBytes = (TLS_VIRT_HDR_SIZE + len) - SHA_DIGEST_LENGTH;
+    }
+    else if(!(ctx->encrypt))
+    {
+        AES_KEY aes_key;
+        unsigned char in_blk[AES_BLOCK_SIZE] = {0x0};
+        unsigned char *key = evp_ctx->session_data->cipherSetupData.pCipherKey;
+        unsigned int  key_len = EVP_CIPHER_CTX_key_length(ctx);
+        unsigned char ivec[AES_BLOCK_SIZE] = {0x0};
+        unsigned char out_blk[AES_BLOCK_SIZE] = {0x0};
+
+        key_len = key_len * 8; //convert to bits
+        memcpy(in_blk, (in + (len - AES_BLOCK_SIZE)), AES_BLOCK_SIZE);
+        memcpy(ivec, (in + (len - (AES_BLOCK_SIZE + AES_BLOCK_SIZE))), AES_BLOCK_SIZE);
+
+        /* Dump input parameters */
+        DUMPL("Key :", key, EVP_CIPHER_CTX_key_length(ctx));
+        DUMPL("IV :", ivec, AES_BLOCK_SIZE);
+        DUMPL("Input Blk :", in_blk, AES_BLOCK_SIZE);
+
+        AES_set_decrypt_key(key, key_len, &aes_key);
+        AES_cbc_encrypt(in_blk, out_blk, AES_BLOCK_SIZE, &aes_key, ivec, 0);
+
+        DUMPL("Output Blk :", out_blk, AES_BLOCK_SIZE);
+
+        /* Extract pad length */
+        pad_len = out_blk[AES_BLOCK_SIZE - 1];
+
+        /* Calculate and update length */
+        evp_ctx->payload_length = len - (pad_len + 1 + SHA_DIGEST_LENGTH);
+        /* Take into account that the field is part of the header that is
+           offset into a byte aligned buffer. */
+        evp_ctx->tls_virt_hdr[QAT_BYTE_ALIGNMENT-QAT_TLS_PAYLOADLENGTH_MSB_OFFSET] =
+                              evp_ctx->payload_length>>QAT_BYTE_SHIFT;
+         /* Take into account that the field is part of the header that is
+           offset into a byte aligned buffer. */
+        evp_ctx->tls_virt_hdr[QAT_BYTE_ALIGNMENT-QAT_TLS_PAYLOADLENGTH_LSB_OFFSET] =
+                              evp_ctx->payload_length;
+
+        /* HMAC Length */
+        evp_ctx->OpData.messageLenToHashInBytes = TLS_VIRT_HDR_SIZE + evp_ctx->payload_length;
+        /* Only copy the offset header data itself and not the whole block */
+        memcpy(evp_ctx->dstFlatBuffer[0].pData + (QAT_BYTE_ALIGNMENT - TLS_VIRT_HDR_SIZE), evp_ctx->tls_virt_hdr + (QAT_BYTE_ALIGNMENT - TLS_VIRT_HDR_SIZE), TLS_VIRT_HDR_SIZE);
+    }
+    else
+    {
+        evp_ctx->OpData.messageLenToHashInBytes = TLS_VIRT_HDR_SIZE + evp_ctx->payload_length;
+    }
+
+    /* Add record padding */
+    if(ctx->encrypt)
+    {
+        plen += SHA_DIGEST_LENGTH;
+        for (pad_len=len-plen-1;plen<len;plen++) evp_ctx->dstFlatBuffer[1].pData[plen]=pad_len;
+    }
+
+    initOpDone(&opDone);
+
+    if(!(ctx->encrypt) &&
+    (NO_PAYLOAD_LENGTH_SPECIFIED != evp_ctx->payload_length) &&
+    ((evp_ctx->tls_version) < TLS1_1_VERSION))
+        memcpy(ctx->iv, in + len - AES_BLOCK_SIZE, EVP_CIPHER_CTX_iv_length(ctx));
+
+    DEBUG("Pre Perform Op\n");
+    DUMPREQ(evp_ctx->instanceHandle, &opDone, &(evp_ctx->OpData),
+            evp_ctx->session_data, &(evp_ctx->srcBufferList),
+            &(evp_ctx->dstBufferList));
+
+    if (((sts = myPerformOp(evp_ctx->instanceHandle,
+						   &opDone,
+						   &(evp_ctx->OpData),
+						   &(evp_ctx->srcBufferList),
+						   &(evp_ctx->dstBufferList),
+						   &(evp_ctx->session_data->verifyDigest))) != CPA_STATUS_SUCCESS) ||
+		((rc = waitForOpToComplete(&opDone)) != 0))
+    {
+        if (!isZeroCopy())
+        {
+            qaeCryptoMemFree(evp_ctx->srcFlatBuffer[1].pData);
+            evp_ctx->srcFlatBuffer[1].pData = NULL;
+            evp_ctx->dstFlatBuffer[1].pData = NULL;
+        }
+        cleanupOpDone(&opDone);
+        if (sts != CPA_STATUS_SUCCESS)
+        {
+            WARN("[%s] --- cpaCySymPerformOp failed sts=%d.\n", __func__, sts);
+        }
+        else
+        {
+            WARN("[%s] --- cpaCySymPerformOp timed out.\n", __func__);
+        }
+        return 0;
+    }
+
+    if(ctx->encrypt)
+        retVal = 1;
+    else if(CPA_TRUE == opDone.verifyResult)
+        retVal = 1;
+
+    DEBUG("Post Perform Op\n");
+    DUMPREQ(evp_ctx->instanceHandle, &opDone, &(evp_ctx->OpData),
+            evp_ctx->session_data, &(evp_ctx->srcBufferList),
+            &(evp_ctx->dstBufferList));
+
+    cleanupOpDone(&opDone);
+
+    if((ctx->encrypt) && ((evp_ctx->tls_version) < TLS1_1_VERSION))
+        memcpy(ctx->iv,
+            evp_ctx->dstBufferList.pBuffers[1].pData + len - AES_BLOCK_SIZE,
+            EVP_CIPHER_CTX_iv_length(ctx));
+    evp_ctx->payload_length = NO_PAYLOAD_LENGTH_SPECIFIED;
+
+    if (!isZeroCopy())
+    {
+        memcpy(out, evp_ctx->dstFlatBuffer[1].pData, len);
+        qaeCryptoMemFree(evp_ctx->srcFlatBuffer[1].pData);
+        evp_ctx->srcFlatBuffer[1].pData = NULL;
+        evp_ctx->dstFlatBuffer[1].pData = NULL;
+    }
+
+    return retVal;
+}
+
+/******************************************************************************
+* function:
+*    qat_aes_cbc_hmac_sha1_ctrl_sync(EVP_CIPHER_CTX *ctx,
+*                               int type, int arg, void *ptr)
+*
+* @param ctx    [IN]  - pointer to existing ctx
+* @param type   [IN]  - type of request either
+*                       EVP_CTRL_AEAD_SET_MAC_KEY or EVP_CTRL_AEAD_TLS1_AAD
+* @param arg    [IN]  - size of the pointed to by ptr
+* @param ptr    [IN]  - input buffer contain the necessary parameters
+*
+* @retval x      The return value is dependent on the type of request being made
+*       EVP_CTRL_AEAD_SET_MAC_KEY return of 1 is success
+*       EVP_CTRL_AEAD_TLS1_AAD return value indicates the amount fo padding to
+*               be applied to the SSL/TLS record
+* @retval -1     function failed
+*
+* description:
+*    This function is a generic control interface provided by the EVP API. For
+*  chained requests this interface is used fro setting the hmac key value for
+*  authentication of the SSL/TLS record. The second type is used to specify the
+*  TLS virtual header which is used in the authentication calculationa nd to
+*  identify record payload size.
+*
+******************************************************************************/
+int qat_aes_cbc_hmac_sha1_ctrl_sync(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)
+{
+    return qat_aes_cbc_hmac_sha1_ctrl(ctx, type, arg, ptr,0);
+}
+
+/******************************************************************************
+* function:
+*    qat_aes_cbc_hmac_sha1_cleanup_sync(EVP_CIPHER_CTX *ctx)
+*
+* @param ctx    [IN]  - pointer to existing ctx
+*
+* @retval 1      function succeeded
+* @retval 0      function failed
+*
+* description:
+*    This function will cleanup all allocated resources required to perfrom the
+*  cryptographic transform.
+*
+******************************************************************************/
+int qat_aes_cbc_hmac_sha1_cleanup_sync(EVP_CIPHER_CTX *ctx)
+{
+    return qat_aes_cbc_hmac_sha1_cleanup(ctx, 0);
+}
+
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*         qat_aes_cbc_hmac_sha1_init_asynch(EVP_CIPHER_CTX *ctx,
+*                                    const unsigned char *inkey,
+*                                    const unsigned char *iv, int enc,
+*                                    int (*cb)(unsigned char *out, int outl,
+*                                              void *cb_data, int status))
+*
+* @param ctx    [IN]  - pointer to existing ctx
+* @param inKey  [IN]  - input cipher key
+* @param iv     [IN]  - initialisation vector
+* @param enc    [IN]  - 1 encrypt 0 decrypt
+* @param cb     [IN]  - callback function pointer
+*
+* @retval 0      function succeeded
+* @retval 1      function failed
+*
+* description:
+*    This function initialises the cipher and hash algorithm parameters for this
+*  EVP context.
+*
+******************************************************************************/
+int qat_aes_cbc_hmac_sha1_init_asynch(EVP_CIPHER_CTX *ctx,
+                        const unsigned char *inkey,
+                        const unsigned char *iv, int enc,
+                        int (*cb)(unsigned char *out, int outl,
+                                  void *cb_data, int status))
+{
+    if (!cb)
+    {
+        WARN("[%s] --- cb parameters are NULL.\n", __func__);
+        return 0;
+    }
+    return qat_aes_cbc_hmac_sha1_init(ctx, inkey,iv,enc,cb);
+}
+#endif
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*    qat_aes_cbc_hmac_sha1_cipher_asynch(EVP_CIPHER_CTX *ctx,
+*                                        unsigned char *out,
+*                                        const unsigned char *in,
+*                                        size_t len
+*                                        void *cb_data)
+*
+* @param ctx     [IN]  - pointer to existing ctx
+* @param out     [OUT] - output buffer for transform result
+* @param in      [IN]  - input buffer
+* @param len     [IN]  - length of input buffer
+* @param cb_data [IN]  - pointer to the callback data
+*
+* @retval 0      function succeeded
+* @retval 1      function failed
+*
+* description:
+*    This function perfrom the cryptographic transfornm according to the
+*  parameters setup during initialisation.
+*
+******************************************************************************/
+int qat_aes_cbc_hmac_sha1_cipher_asynch(EVP_CIPHER_CTX *ctx, unsigned char *out,
+                                               const unsigned char *in, size_t len,
+                                               void *cb_data)
+{
+    CpaStatus sts = 0;
+    unsigned int pad_len = 0;
+    struct op_done_asynch *op_done = NULL;
+    qat_chained_ctx *qat_context = NULL;
+    int retVal = 0;
+    size_t payload_len = 0;
+    const unsigned char *explicit_iv = NULL;
+    const unsigned char *cur_in = in;
+    AGG_REQ *agg_req = NULL;
+
+    CRYPTO_QAT_LOG("CIPHER - %s\n", __func__);
+
+    if (!ctx || !in || !out || !cb_data)
+    {
+        WARN("[%s] --- ctx, in, out or cb_data parameters are NULL.\n", __func__);
+        goto end;
+    }
+
+    qat_context = data(ctx);
+
+    if (!qat_context)
+    {
+        WARN("[%s] --- qat_context is NULL.\n", __func__);
+        goto end;
+    }
+
+    if(!(qat_context->init))
+    {
+        if(0 == qat_aes_sha1_session_init_asynch(ctx))
+        {
+            WARN("[%s] --- Unable to initialise Cipher context.\n", __func__);
+            goto end;
+        }
+    }
+
+    /* QAT structure allocations */
+    op_done = OPENSSL_malloc(sizeof(struct op_done_asynch));
+    if(!op_done)
+    {
+        WARN("[%s] --- opDone is NULL.\n", __func__);
+        goto end;
+    }
+
+    op_done->cipher_ctx = ctx;
+    op_done->orig_out = op_done->cur_out = out;
+    op_done->orig_len = op_done->cur_len = len;
+    op_done->cb_data = cb_data;
+    op_done->qat_ctx.chain = qat_context;
+
+    if (len%AES_BLOCK_SIZE) goto end;
+
+    payload_len = qat_context->payload_length;
+    if (payload_len == NO_PAYLOAD_LENGTH_SPECIFIED)
+        payload_len = op_done->cur_len - SHA_DIGEST_LENGTH;
+    else if (ctx->encrypt && op_done->cur_len!=
+        ((payload_len+SHA_DIGEST_LENGTH+AES_BLOCK_SIZE)&-AES_BLOCK_SIZE))
+        goto end;
+    else if (qat_context->tls_version >= TLS1_1_VERSION)
+    {
+        /* TODO: This should just be a check for IGNORE_IV but for backward compatibility
+         * we check version and the IGNORE_IV field. IGNORE field check is done in the request
+         * creation. */
+
+        /* Note: The OpenSSL framework assumes that the IV field will be part of the
+         * encrypted data, yet never looks at the output of the encryption/decryption
+         * process for this field. In order to chain HASH and CIPHER we need to present
+         * contiguous SGL to QAT, thus we need to copy the IV from input to output in
+         * order to skip this field in encryption */
+    explicit_iv = cur_in;
+        if(cur_in != op_done->cur_out)
+            memcpy(op_done->cur_out, cur_in, EVP_CIPHER_CTX_iv_length(ctx));
+        cur_in += EVP_CIPHER_CTX_iv_length(ctx);
+        op_done->cur_out += EVP_CIPHER_CTX_iv_length(ctx);
+        op_done->cur_len -= EVP_CIPHER_CTX_iv_length(ctx);
+        payload_len -= EVP_CIPHER_CTX_iv_length(ctx);
+    }
+
+    if(!(ctx->encrypt) && (NO_PAYLOAD_LENGTH_SPECIFIED != qat_context->payload_length))
+    {
+        AES_KEY aes_key;
+        unsigned char in_blk[AES_BLOCK_SIZE] = {0x0};
+        unsigned char *key = qat_context->session_data->cipherSetupData.pCipherKey;
+        unsigned int  key_len = EVP_CIPHER_CTX_key_length(ctx) * 8; /* convert to bits */
+        unsigned char ivec[AES_BLOCK_SIZE] = {0x0};
+        unsigned char out_blk[AES_BLOCK_SIZE] = {0x0};
+
+        memcpy(in_blk, (cur_in + (op_done->cur_len - AES_BLOCK_SIZE)), AES_BLOCK_SIZE);
+        memcpy(ivec, (cur_in + (op_done->cur_len - (AES_BLOCK_SIZE + AES_BLOCK_SIZE))), AES_BLOCK_SIZE);
+
+        /* Dump input parameters */
+        DUMPL("Key :", key, EVP_CIPHER_CTX_key_length(ctx));
+        DUMPL("IV :", ivec, AES_BLOCK_SIZE);
+        DUMPL("Input Blk :", in_blk, AES_BLOCK_SIZE);
+
+        AES_set_decrypt_key(key, key_len, &aes_key);
+        AES_cbc_encrypt(in_blk, out_blk, AES_BLOCK_SIZE, &aes_key, ivec, 0);
+
+        DUMPL("Output Blk :", out_blk, AES_BLOCK_SIZE);
+
+        /* Extract pad length, calculate and update length */
+        payload_len = op_done->cur_len - ((out_blk[AES_BLOCK_SIZE - 1]) + 1 + SHA_DIGEST_LENGTH);
+    }
+
+    qat_context->tls_hdr[TLS_VIRT_HDR_SIZE-QAT_TLS_PAYLOADLENGTH_MSB_OFFSET] =
+                             payload_len>>QAT_BYTE_SHIFT;
+    qat_context->tls_hdr[TLS_VIRT_HDR_SIZE-QAT_TLS_PAYLOADLENGTH_LSB_OFFSET] =
+                             payload_len;
+
+    if (NULL == (agg_req = create_chained_request(ctx, op_done->cur_out,
+                    cur_in, op_done->cur_len,
+                                        qat_context->qat_ctx,
+                                        qat_context->meta_size,
+                                        SHA_DIGEST_LENGTH,
+                                        qat_context->tls_hdr,
+                                        TLS_VIRT_HDR_SIZE)))
+    {
+        WARN("%s: Unable to create request structure.\n", __func__);
+        goto end;
+    }
+    op_done->agg_req = agg_req;
+
+    if (NULL != explicit_iv)
+    {
+        memcpy(OPDATA_PTR(agg_req)->pIv, explicit_iv, EVP_CIPHER_CTX_iv_length(ctx));
+        OPDATA_PTR(agg_req)->packetType = CPA_CY_SYM_PACKET_TYPE_FULL;
+    }
+
+    /* TLS VIRT header is allocated when creating the request */
+    /* Create the OpData structure to remove this processing from the data path */
+    OPDATA_PTR(agg_req)->cryptoStartSrcOffsetInBytes += TLS_VIRT_HDR_SIZE;
+
+    /* HMAC Length */
+    OPDATA_PTR(agg_req)->messageLenToHashInBytes = TLS_VIRT_HDR_SIZE + payload_len;
+
+    /* Add record padding */
+    if(ctx->encrypt)
+    {
+        payload_len += SHA_DIGEST_LENGTH;
+        for (pad_len=op_done->cur_len-payload_len-1;payload_len<op_done->cur_len;payload_len++)
+        DST_BUFFER_DATA(agg_req)[1].pData[payload_len]=pad_len;
+    }
+
+    if(!(ctx->encrypt) &&
+    (NO_PAYLOAD_LENGTH_SPECIFIED != qat_context->payload_length) &&
+    ((qat_context->tls_version) < TLS1_1_VERSION))
+        memcpy(ctx->iv, in + len - AES_BLOCK_SIZE, EVP_CIPHER_CTX_iv_length(ctx));
+
+    DEBUG("Pre Perform Op\n");
+    DEBUG("Session Ptr: %p\n", qat_context->qat_ctx);
+    DUMPREQ(qat_context->instanceHandle, op_done, OPDATA_PTR(agg_req),
+            qat_context->session_data, SRC_BUFFER_LIST(agg_req),
+            DST_BUFFER_LIST(agg_req));
+
+    if ((sts = cpaCySymPerformOp(qat_context->instanceHandle,
+                                 op_done,
+                                 OPDATA_PTR(agg_req),
+                                 SRC_BUFFER_LIST(agg_req),
+                                 DST_BUFFER_LIST(agg_req),
+                                 &(qat_context->session_data->verifyDigest))) != CPA_STATUS_SUCCESS)
+    {
+        WARN("%s: cpaCySymPerformOp failed sts=%d.\n", __func__, sts);
+        if (CPA_STATUS_RETRY == sts)
+            QATerr(QAT_F_QAT_AES_CBC_HMAC_SHA1_CIPHER_ASYNCH, ERR_R_RETRY);
+        goto end;
+    }
+
+    /* message has been sent to CPM */
+    retVal = 1;
+    qat_context->payload_length = NO_PAYLOAD_LENGTH_SPECIFIED;
+
+    /* Update transmission stats */
+    qat_context->noRequests++;
+
+    //DEBUG("Post Perform Op\n");
+    //DUMPREQ(qat_context->instanceHandle, op_done, OPDATA_PTR(agg_req),
+    //        qat_context->session_data, SRC_BUFFER_LIST(agg_req),
+    //        DST_BUFFER_LIST(agg_req));
+
+    return retVal;
+
+    end:
+    /* QAT structure allocations */
+    if(NULL != agg_req)
+        destroy_request(agg_req);
+    if(NULL != op_done)
+        OPENSSL_free(op_done);
+
+    return 0;
+}
+#endif
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*    qat_aes_cbc_hmac_sha1_ctrl_asynch(EVP_CIPHER_CTX *ctx,
+*                               int type, int arg, void *ptr)
+*
+* @param ctx    [IN]  - pointer to existing ctx
+* @param type   [IN]  - type of request either
+*                       EVP_CTRL_AEAD_SET_MAC_KEY or EVP_CTRL_AEAD_TLS1_AAD
+* @param arg    [IN]  - size of the pointed to by ptr
+* @param ptr    [IN]  - input buffer contain the necessary parameters
+*
+* @retval x      The return value is dependent on the type of request being made
+*       EVP_CTRL_AEAD_SET_MAC_KEY return of 1 is success
+*       EVP_CTRL_AEAD_TLS1_AAD return value indicates the amount fo padding to
+*               be applied to the SSL/TLS record
+* @retval -1     function failed
+*
+* description:
+*    This function is a generic control interface provided by the EVP API. For
+*  chained requests this interface is used fro setting the hmac key value for
+*  authentication of the SSL/TLS record. The second type is used to specify the
+*  TLS virtual header which is used in the authentication calculationa nd to
+*  identify record payload size.
+*
+******************************************************************************/
+int qat_aes_cbc_hmac_sha1_ctrl_asynch(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)
+{
+    return qat_aes_cbc_hmac_sha1_ctrl(ctx, type, arg, ptr,1);
+}
+#endif
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*    qat_aes_cbc_hmac_sha1_cleanup_asynch(EVP_CIPHER_CTX *ctx)
+*
+* @param ctx    [IN]  - pointer to existing ctx
+*
+* @retval 1      function succeeded
+* @retval 0      function failed
+*
+* description:
+*    This function will cleanup all allocated resources required to perfrom the
+*  cryptographic transform.
+*
+******************************************************************************/
+int qat_aes_cbc_hmac_sha1_cleanup_asynch(EVP_CIPHER_CTX *ctx)
+{
+    return qat_aes_cbc_hmac_sha1_cleanup(ctx, 1);
+}
+#endif
+
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_chain.h ./engines/qat_engine/qat_chain.h
--- ../openssl-async/engines/qat_engine/qat_chain.h	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_chain.h	2015-03-05 12:43:44.238961000 +0000
@@ -0,0 +1,89 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qat_chain.h
+ *
+ * This file provides a interface for engine chain cipher operations
+ *
+ *****************************************************************************/
+
+#ifndef QAT_CHAIN_H
+#define QAT_CHAIN_H
+
+#include <openssl/engine.h>
+
+
+/* Qat engine AES-SHA1 sync chaining function declarations */
+int qat_aes_cbc_hmac_sha1_init_sync(EVP_CIPHER_CTX *ctx,
+                                      const unsigned char *inkey,
+                                      const unsigned char *iv, int enc);
+int qat_aes_cbc_hmac_sha1_cipher_sync(EVP_CIPHER_CTX *ctx, unsigned char *out,
+                                        const unsigned char *in, size_t len);
+int qat_aes_cbc_hmac_sha1_cleanup_sync(EVP_CIPHER_CTX *ctx);
+int qat_aes_cbc_hmac_sha1_ctrl_sync(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr);
+
+/* Qat engine AES-SHA1 async chaining function declarations */
+int qat_aes_cbc_hmac_sha1_init_asynch(EVP_CIPHER_CTX *ctx,
+                                      const unsigned char *inkey,
+                                      const unsigned char *iv, int enc,
+                                      int (*cb)(unsigned char *out, int outl,
+                                                void *cb_data, int status));
+int qat_aes_cbc_hmac_sha1_cipher_asynch(EVP_CIPHER_CTX *ctx, 
+					unsigned char *out,
+                                        const unsigned char *in, size_t len,
+                                        void *cb_data);
+int qat_aes_cbc_hmac_sha1_cleanup_asynch(EVP_CIPHER_CTX *ctx);
+int qat_aes_cbc_hmac_sha1_ctrl_asynch(EVP_CIPHER_CTX *ctx, int type, 
+					     int arg, void *ptr);
+
+EVP_CIPHER qat_aes_128_cbc_hmac_sha1, qat_aes_256_cbc_hmac_sha1;
+EVP_CIPHER qat_aes_128_cbc_hmac_sha1_asynch, qat_aes_256_cbc_hmac_sha1_asynch;
+			 
+#endif //QAT_CHAIN_H
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_ciphers.c ./engines/qat_engine/qat_ciphers.c
--- ../openssl-async/engines/qat_engine/qat_ciphers.c	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_ciphers.c	2015-03-05 12:43:44.240958000 +0000
@@ -0,0 +1,1307 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qat_ciphers.c
+ *
+ * This file contains the engine implementations for cipher operations
+ *
+ *****************************************************************************/
+
+#ifdef USE_QAT_MEM
+#include "qae_mem_utils.h"
+#endif
+#ifdef USE_QAE_MEM
+#include "qat_mem_drv_inf.h"
+#endif
+
+#include "qat_utils.h"
+#include "e_qat.h"
+#include "e_qat_err.h"
+
+#include "cpa.h"
+#include "cpa_types.h"
+#include "cpa_cy_sym.h"
+#include "qat_ciphers.h"
+#include "qat_chain.h"
+#include "qat_sym_common.h"
+
+#include <openssl/evp.h>
+#include <openssl/aes.h>
+#include <openssl/err.h>
+#include <openssl/sha.h>
+#include <openssl/tls1.h>
+#include <string.h>
+
+#ifdef OPENSSL_ENABLE_QAT_CIPHERS_SYNCH
+#ifdef OPENSSL_DISABLE_QAT_CIPHERS_SYNCH
+#undef OPENSSL_DISABLE_QAT_CIPHERS_SYNCH
+#endif
+#endif
+
+#ifdef OPENSSL_ENABLE_QAT_CIPHERS_ASYNCH
+#ifdef OPENSSL_DISABLE_QAT_CIPHERS_ASYNCH
+#undef OPENSSL_DISABLE_QAT_CIPHERS_ASYNCH
+#endif
+#endif
+
+#ifndef OPENSSL_QAT_ASYNCH
+#define OPENSSL_DISABLE_QAT_CIPHERS_ASYNCH
+#endif
+
+static int qat_cipher_init_synch(EVP_CIPHER_CTX * ctx, const unsigned char *key,
+                             const unsigned char *iv, int enc);
+static int qat_do_cipher_synch(EVP_CIPHER_CTX * ctx, unsigned char *out,
+                           const unsigned char *in, size_t inl);
+#ifdef OPENSSL_QAT_ASYNCH
+static int qat_cipher_init_asynch(EVP_CIPHER_CTX * ctx, const unsigned char *key,
+                              const unsigned char *iv, int enc,
+			      int (*cb)(unsigned char *out, int outl,
+                                         void *cb_data, int status));
+static int qat_do_cipher_asynch(EVP_CIPHER_CTX * ctx, unsigned char *out,
+                            const unsigned char *in, size_t inl,
+                            void *cb_data);
+#endif
+static int common_cipher_cleanup(EVP_CIPHER_CTX *ctx);
+
+/* Qat cipher RC4 function structure declaration */
+EVP_CIPHER qat_rc4 = {
+    NID_rc4,                    /* nid */
+    RC4_BLOCK_SIZE,             /* block_size */
+    RC4_KEY_SIZE,               /* key_size in Bytes - defined in header */
+    RC4_IV_LEN,                 /* iv_len in Bytes - defined in header */
+    qat_common_cipher_flags,    /* flags defined in header */
+#ifdef OPENSSL_QAT_ASYNCH
+    { qat_cipher_init_synch },
+    { qat_do_cipher_synch },
+#else
+    qat_cipher_init_synch,
+    qat_do_cipher_synch,
+#endif
+    common_cipher_cleanup,
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL,                       /* set_asn1_parameters */
+    NULL,                       /* get_asn1_parameters */
+    NULL,                       /* ctrl */
+    NULL                        /* app_data */
+};
+
+#ifdef OPENSSL_QAT_ASYNCH
+EVP_CIPHER qat_rc4_asynch = {
+    NID_rc4,                    /* nid */
+    RC4_BLOCK_SIZE,             /* block_size */
+    RC4_KEY_SIZE,               /* key_size in Bytes - defined in header */
+    RC4_IV_LEN,                 /* iv_len in Bytes - defined in header */
+    qat_common_cipher_flags | EVP_CIPH_FLAG_ASYNCH,/* flags defined in header */
+    { .asynch = qat_cipher_init_asynch },
+    { .asynch = qat_do_cipher_asynch },
+    common_cipher_cleanup,
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL,                       /* set_asn1_parameters */
+    NULL,                       /* get_asn1_parameters */
+    NULL,                       /* ctrl */
+    NULL                        /* app_data */
+};
+#endif
+/* Qat cipher DES function structure declaration */
+EVP_CIPHER qat_des_cbc = {
+    NID_des_cbc,                /* nid */
+    DES_BLOCK_SIZE,             /* block_size */
+    DES_KEY_SIZE,               /* key_size in Bytes - defined in header */
+    DES_IV_LEN,                 /* iv_len in Bytes - defined in header */
+    qat_common_cbc_flags,       /* flags defined in header */
+#ifdef OPENSSL_QAT_ASYNCH
+    { qat_cipher_init_synch },
+    { qat_do_cipher_synch },
+#else
+    qat_cipher_init_synch,
+    qat_do_cipher_synch,
+#endif
+    common_cipher_cleanup,
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL,                       /* set_asn1_parameters */
+    NULL,                       /* get_asn1_parameters */
+    NULL,                       /* ctrl */
+    NULL                        /* app_data */
+};
+
+#ifdef OPENSSL_QAT_ASYNCH
+EVP_CIPHER qat_des_cbc_asynch = {
+    NID_des_cbc,                /* nid */
+    DES_BLOCK_SIZE,             /* block_size */
+    DES_KEY_SIZE,               /* key_size in Bytes - defined in header */
+    DES_IV_LEN,                 /* iv_len in Bytes - defined in header */
+    qat_common_cbc_flags | EVP_CIPH_FLAG_ASYNCH,/* flags defined in header */
+    { .asynch = qat_cipher_init_asynch },
+    { .asynch = qat_do_cipher_asynch },
+    common_cipher_cleanup,
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL,                       /* set_asn1_parameters */
+    NULL,                       /* get_asn1_parameters */
+    NULL,                       /* ctrl */
+    NULL                        /* app_data */
+};
+#endif
+
+/* Qat cipher 3DES function structure declaration */
+EVP_CIPHER qat_des_ede3_cbc = {
+    NID_des_ede3_cbc,           /* nid */
+    DES3_BLOCK_SIZE,            /* block_size */
+    DES3_KEY_SIZE,              /* key_size in Bytes - defined in header */
+    DES3_IV_LEN,                /* iv_len in Bytes - defined in header */
+    qat_common_cbc_flags,       /* flags defined in header */
+#ifdef OPENSSL_QAT_ASYNCH
+    { qat_cipher_init_synch },
+    { qat_do_cipher_synch },
+#else
+    qat_cipher_init_synch,
+    qat_do_cipher_synch,
+#endif
+    common_cipher_cleanup,
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL,                       /* set_asn1_parameters */
+    NULL,                       /* get_asn1_parameters */
+    NULL,                       /* ctrl */
+    NULL                        /* app_data */
+};
+
+#ifdef OPENSSL_QAT_ASYNCH
+EVP_CIPHER qat_des_ede3_cbc_asynch = {
+    NID_des_ede3_cbc,           /* nid */
+    DES3_BLOCK_SIZE,            /* block_size */
+    DES3_KEY_SIZE,              /* key_size in Bytes - defined in header */
+    DES3_IV_LEN,                /* iv_len in Bytes - defined in header */
+    qat_common_cbc_flags | EVP_CIPH_FLAG_ASYNCH,/* flags defined in header */
+    { .asynch = qat_cipher_init_asynch },
+    { .asynch = qat_do_cipher_asynch },
+    common_cipher_cleanup,
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL,                       /* set_asn1_parameters */
+    NULL,                       /* get_asn1_parameters */
+    NULL,                       /* ctrl */
+    NULL                        /* app_data */
+};
+#endif
+
+/* Qat cipher AES128 function structure declaration */
+EVP_CIPHER qat_aes_128_cbc = {
+    NID_aes_128_cbc,            /* nid */
+    AES_BLOCK_SIZE,             /* block_size */
+    AES_KEY_SIZE_128,           /* key_size in Bytes - defined in header */
+    AES_IV_LEN,                 /* iv_len in Bytes - defined in header */
+    qat_common_cbc_flags,       /* flags defined in header */
+#ifdef OPENSSL_QAT_ASYNCH
+    { qat_cipher_init_synch },
+    { qat_do_cipher_synch },
+#else
+    qat_cipher_init_synch,
+    qat_do_cipher_synch,
+#endif
+    common_cipher_cleanup,
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL,                       /* set_asn1_parameters */
+    NULL,                       /* get_asn1_parameters */
+    NULL,                       /* ctrl */
+    NULL                        /* app_data */
+};
+
+#ifdef OPENSSL_QAT_ASYNCH
+EVP_CIPHER qat_aes_128_cbc_asynch = {
+    NID_aes_128_cbc,            /* nid */
+    AES_BLOCK_SIZE,             /* block_size */
+    AES_KEY_SIZE_128,           /* key_size in Bytes - defined in header */
+    AES_IV_LEN,                 /* iv_len in Bytes - defined in header */
+    qat_common_cbc_flags | EVP_CIPH_FLAG_ASYNCH,/* flags defined in header */
+    { .asynch = qat_cipher_init_asynch },
+    { .asynch = qat_do_cipher_asynch },
+    common_cipher_cleanup,
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL,                       /* set_asn1_parameters */
+    NULL,                       /* get_asn1_parameters */
+    NULL,                       /* ctrl */
+    NULL                        /* app_data */
+};
+#endif
+
+/* Qat cipher AES256 function structure declaration */
+EVP_CIPHER qat_aes_256_cbc = {
+    NID_aes_256_cbc,            /* nid */
+    AES_BLOCK_SIZE,             /* block_size */
+    AES_KEY_SIZE_256,           /* key_size in Bytes - defined in header */
+    AES_IV_LEN,                 /* iv_len in Bytes - defined in header */
+    qat_common_cbc_flags,       /* flags defined in header */
+#ifdef OPENSSL_QAT_ASYNCH
+    { qat_cipher_init_synch },
+    { qat_do_cipher_synch },
+#else
+    qat_cipher_init_synch,
+    qat_do_cipher_synch,
+#endif
+    common_cipher_cleanup,
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL,                       /* set_asn1_parameters */
+    NULL,                       /* get_asn1_parameters */
+    NULL,                       /* ctrl */
+    NULL                        /* app_data */
+};
+
+#ifdef OPENSSL_QAT_ASYNCH
+EVP_CIPHER qat_aes_256_cbc_asynch = {
+    NID_aes_256_cbc,            /* nid */
+    AES_BLOCK_SIZE,             /* block_size */
+    AES_KEY_SIZE_256,           /* key_size in Bytes - defined in header */
+    AES_IV_LEN,                 /* iv_len in Bytes - defined in header */
+    qat_common_cbc_flags | EVP_CIPH_FLAG_ASYNCH,/* flags defined in header */
+    { .asynch = qat_cipher_init_asynch },
+    { .asynch = qat_do_cipher_asynch },
+    common_cipher_cleanup,
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL,                       /* set_asn1_parameters */
+    NULL,                       /* get_asn1_parameters */
+    NULL,                       /* ctrl */
+    NULL                        /* app_data */
+};
+#endif
+/* Qat Symmetric cipher function register */
+int qat_cipher_nids[] = {
+    NID_aes_128_cbc,
+    NID_aes_256_cbc,
+    NID_rc4,
+    NID_des_cbc,
+    NID_des_ede3_cbc,
+    NID_aes_128_cbc_hmac_sha1,
+    NID_aes_256_cbc_hmac_sha1
+};
+
+/******************************************************************************
+* function:
+*         qat_ciphers(ENGINE *e,
+*                     const EVP_CIPHER **cipher,
+*                     const int **nids,
+*                     int nid,
+*                     int isAsynch)
+*
+* @param e      [IN] - OpenSSL engine pointer
+* @param cipher [IN] - cipher structure pointer
+* @param nids   [IN] - cipher function nids
+* @param nid    [IN] - cipher operation id
+* @param isAsynch [IN] - Whether the operation is synchronous (0)
+*                        or asynchronous (1)
+*
+* description:
+*   Qat engine cipher operations registrar
+******************************************************************************/
+static int
+qat_ciphers(ENGINE * e, const EVP_CIPHER ** cipher, const int **nids,
+            int nid, int isAsynch)
+{
+    int ok = 1;
+
+    /* No specific cipher => return a list of supported nids ... */
+    if (!cipher)
+    {
+        *nids = qat_cipher_nids;
+        /* num ciphers supported (size of array/size of 1 element) */
+        return (sizeof(qat_cipher_nids) / sizeof(qat_cipher_nids[0]));
+    }
+
+    if(!isAsynch)
+    {
+#ifndef OPENSSL_DISABLE_QAT_CIPHERS_SYNCH
+        switch (nid)
+        {
+            case NID_aes_128_cbc:
+                *cipher = &qat_aes_128_cbc;
+                break;
+            case NID_aes_256_cbc:
+                *cipher = &qat_aes_256_cbc;
+                break;
+            case NID_rc4:
+                *cipher = &qat_rc4;
+                break;
+            case NID_des_cbc:
+                *cipher = &qat_des_cbc;
+                break;
+            case NID_des_ede3_cbc:
+                *cipher = &qat_des_ede3_cbc;
+                break;
+            case NID_aes_128_cbc_hmac_sha1:
+                *cipher = &qat_aes_128_cbc_hmac_sha1;
+                break;
+            case NID_aes_256_cbc_hmac_sha1:
+                *cipher = &qat_aes_256_cbc_hmac_sha1;
+                break;
+            default:
+                ok = 0;
+                *cipher = NULL;
+        }
+#else
+        switch (nid)
+        {
+            case NID_aes_128_cbc:
+                *cipher = EVP_aes_128_cbc();
+                break;
+            case NID_aes_256_cbc:
+                *cipher = EVP_aes_256_cbc();
+                break;
+            case NID_rc4:
+                *cipher = EVP_rc4();
+                break;
+            case NID_des_cbc:
+                *cipher = EVP_des_cbc();
+                break;
+            case NID_des_ede3_cbc:
+                *cipher = EVP_des_ede3_cbc();
+                break;
+            case NID_aes_128_cbc_hmac_sha1:
+                *cipher = EVP_aes_128_cbc_hmac_sha1();
+                break;
+            case NID_aes_256_cbc_hmac_sha1:
+                *cipher = EVP_aes_256_cbc_hmac_sha1();
+                break;
+            default:
+                ok = 0;
+                *cipher = NULL;
+        }
+#endif
+    }
+else
+    {
+#ifndef OPENSSL_DISABLE_QAT_CIPHERS_ASYNCH
+        switch (nid)
+        {
+            case NID_aes_128_cbc:
+                *cipher = &qat_aes_128_cbc_asynch;
+                break;
+            case NID_aes_256_cbc:
+                *cipher = &qat_aes_256_cbc_asynch;
+                break;
+            case NID_rc4:
+                *cipher = &qat_rc4_asynch;
+                break;
+            case NID_des_cbc:
+                *cipher = &qat_des_cbc_asynch;
+                break;
+            case NID_des_ede3_cbc:
+                *cipher = &qat_des_ede3_cbc_asynch;
+                break;
+            case NID_aes_128_cbc_hmac_sha1:
+                *cipher = &qat_aes_128_cbc_hmac_sha1_asynch;
+                break;
+            case NID_aes_256_cbc_hmac_sha1:
+                *cipher = &qat_aes_256_cbc_hmac_sha1_asynch;
+                break;
+            default:
+                ok = 0;
+                *cipher = NULL;
+        }
+#else
+	ok = 0;
+	*cipher = NULL;
+#endif
+    }
+    return ok;
+}
+
+int
+qat_ciphers_synch(ENGINE * e, const EVP_CIPHER ** cipher, const int **nids, int nid)
+{
+    return qat_ciphers(e, cipher, nids, nid, 0);
+}
+
+#ifdef OPENSSL_QAT_ASYNCH
+int
+qat_ciphers_asynch(ENGINE * e, const EVP_CIPHER ** cipher, const int **nids, int nid)
+{
+    return qat_ciphers(e, cipher, nids, nid, 1);
+}
+#endif
+
+#ifdef OPENSSL_QAT_ASYNCH
+static void qat_cipherAsynchCallbackFn(void *callbackTag, CpaStatus status,
+                           const CpaCySymOp operationType, void *pOpData,
+                           CpaBufferList * pDstBuffer, CpaBoolean verifyResult)
+{
+    struct op_done_asynch *op_done = (struct op_done_asynch *)callbackTag;
+    int cb_status = status == CPA_STATUS_SUCCESS ? 1 : 0;
+    qat_ctx* qat_context = NULL;
+
+    if(NULL == op_done || NULL == pDstBuffer)
+    {
+        WARN("[%s] --- Invalid input parameter to callback - op_done - pDstBuff.\n", __func__);
+	    QATerr(QAT_F_QAT_CIPHERASYNCHCALLBACKFN, QAT_R_INVALID_INPUT_PARAMETER);
+        return;
+    }
+
+	if(NULL == op_done->cipher_ctx)
+    {
+        WARN("[%s] --- Invalid input parameter to callback - op_done->cipher_ctx.\n", __func__);
+	    QATerr(QAT_F_QAT_CIPHERASYNCHCALLBACKFN, QAT_R_INVALID_INPUT_PARAMETER);
+        return;
+    }
+
+	if(NULL == op_done->cipher_ctx->cipher_data)
+    {
+        WARN("[%s] --- Invalid input parameter to callback - op_done->cipher_ctx->cipher_data.\n", __func__);
+	    QATerr(QAT_F_QAT_CIPHERASYNCHCALLBACKFN, QAT_R_INVALID_INPUT_PARAMETER);
+        return;
+    }
+
+    qat_context = op_done->cipher_ctx->cipher_data;
+
+    DEBUG("e_qat.%s: status %d verifyResult %d\n", __func__, status,
+          verifyResult);
+    op_done->verifyResult = verifyResult;
+
+    if(EVP_CIPHER_CTX_flags(op_done->cipher_ctx) & EVP_CIPH_CBC_MODE)
+    {
+        if(op_done->cipher_ctx->encrypt)
+        {
+            memcpy(op_done->cipher_ctx->iv,
+	           (pDstBuffer->pBuffers[0].pData + op_done->orig_len - EVP_CIPHER_CTX_iv_length(op_done->cipher_ctx)),
+                   EVP_CIPHER_CTX_iv_length(op_done->cipher_ctx));
+        }
+    }
+
+    DUMPREQ(qat_context->instanceHandle, op_done, (CpaCySymOpData*)pOpData,
+            qat_context->session_data, pDstBuffer, pDstBuffer);
+
+    if (!isZeroCopy())
+    {
+	memcpy(op_done->orig_out, pDstBuffer->pBuffers[0].pData, op_done->orig_len);
+    }
+    else
+    {
+        op_done->orig_out = pDstBuffer->pBuffers[0].pData;
+    }
+
+    if(status == CPA_STATUS_SUCCESS)
+	cb_status = 1;
+
+    qat_context->cipher_cb(op_done->orig_out, op_done->orig_len, op_done->cb_data, cb_status);
+
+    if(NULL != op_done->agg_req)
+	destroy_request(op_done->agg_req);
+    if(NULL != op_done)
+        OPENSSL_free(op_done);
+
+    /* Update Reception stats */
+    qat_context->noResponses++;
+}
+#endif
+
+/******************************************************************************
+* function:
+*         cipher_init( EVP_CIPHER_CTX *ctx,
+*                          const unsigned char *key,
+*                          const unsigned char *iv,
+*                          int enc,
+                           int (*cb)(unsigned char *out, int outl,
+                                     void *cb_data, int status))
+*
+* @param ctx [IN] - cipher ctx
+* @param key [IN] - pointer to the key value. Must be set.
+* @param iv  [IN] - pointer to initial vector (can be NULL)
+* @param enc [IN] - encryption indicator
+* @param cb  [IN] - callback function pointer
+*
+* description:
+*   All the inputs are passed form the OpenSSL layer to the
+*   corresponding API cpaCySymInitSession() function.
+*   It is the first function called in cipher routine sequences,
+*   in order to initialize the cipher ctx structure and CpaCySymSession.
+*   The function will return 1 if successful.
+******************************************************************************/
+static int cipher_init(EVP_CIPHER_CTX * ctx, const unsigned char *key,
+                     const unsigned char *iv, int enc,
+                     int (*cb)(unsigned char *out, int outl,
+                                void *cb_data, int status))
+{
+
+    CpaCySymSessionSetupData *sessionSetupData = NULL;
+    Cpa32U sessionCtxSize = 0;
+    CpaCySymSessionCtx pSessionCtx = NULL;
+    qat_ctx *qat_context = NULL;
+    CpaStatus sts = 0;
+    CpaInstanceHandle instanceHandle;
+    void *srcPrivateMetaData = NULL;
+    void *dstPrivateMetaData = NULL;
+    Cpa32U metaSize = 0;
+    int cipherType;
+    CpaCySymCbFunc qat_eng_cb = NULL;
+
+    DEBUG("[%s] ---- CIPHER init %p, enc %d...\n\n", __func__, ctx, enc);
+
+    if ((!key) || (!ctx))
+    {
+        WARN("[%s] --- key or ctx is NULL.\n", __func__);
+        return 0;
+    }
+
+	if (NULL == ctx->cipher_data)
+    {
+        WARN("[%s] --- ctx->cipher_data is NULL.\n", __func__);
+        return 0;
+    }
+
+    if (NULL != iv)
+    {
+        memcpy(ctx->iv, iv, EVP_CIPHER_CTX_iv_length(ctx));
+    }
+	else
+    {
+        memset(ctx->iv, 0, EVP_CIPHER_CTX_iv_length(ctx));
+    }
+
+    if(NULL == (sessionSetupData = OPENSSL_malloc(sizeof(CpaCySymSessionSetupData))))
+    {
+        WARN("[%s] --- unable to allocate memory for session info.\n", __func__);
+        return 0;
+    }
+
+    /* Priority of this session */
+    sessionSetupData->sessionPriority = CPA_CY_PRIORITY_HIGH;
+    sessionSetupData->symOperation = CPA_CY_SYM_OP_CIPHER;
+    /* Cipher algorithm and mode */
+	cipherType = EVP_CIPHER_CTX_nid(ctx);
+    switch (cipherType)
+    {
+        case NID_aes_128_cbc:
+        case NID_aes_256_cbc:
+            sessionSetupData->cipherSetupData.cipherAlgorithm =
+                CPA_CY_SYM_CIPHER_AES_CBC;
+            break;
+        case NID_rc4:
+            sessionSetupData->cipherSetupData.cipherAlgorithm =
+                CPA_CY_SYM_CIPHER_ARC4;
+            break;
+        case NID_des_cbc:
+            sessionSetupData->cipherSetupData.cipherAlgorithm =
+                CPA_CY_SYM_CIPHER_DES_CBC;
+            break;
+        case NID_des_ede3_cbc:
+            sessionSetupData->cipherSetupData.cipherAlgorithm =
+                CPA_CY_SYM_CIPHER_3DES_CBC;
+            break;
+        default:
+            WARN("[%s] --- Unsupported Cipher Type.\n", __func__);
+            OPENSSL_free(sessionSetupData);
+            return 0;
+    }
+
+    sessionSetupData->cipherSetupData.cipherKeyLenInBytes =
+        (Cpa32U) EVP_CIPHER_CTX_key_length(ctx);
+
+    /* Cipher key */
+    sessionSetupData->cipherSetupData.pCipherKey = (Cpa8U *) key;
+    sessionSetupData->verifyDigest = CPA_FALSE;
+
+    /* Operation to perform */
+    if (enc)
+        sessionSetupData->cipherSetupData.cipherDirection =
+            CPA_CY_SYM_CIPHER_DIRECTION_ENCRYPT;
+    else
+        sessionSetupData->cipherSetupData.cipherDirection =
+            CPA_CY_SYM_CIPHER_DIRECTION_DECRYPT;
+
+    instanceHandle = get_next_inst();
+    if ((sts = cpaCySymSessionCtxGetSize
+         (instanceHandle, sessionSetupData,
+          &sessionCtxSize)) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCySymSessionCtxGetSize failed, sts = %d.\n",
+             __func__, sts);
+        OPENSSL_free(sessionSetupData);
+        return 0;
+    }
+
+    pSessionCtx = (CpaCySymSessionCtx) qaeCryptoMemAlloc(sessionCtxSize, __FILE__, __LINE__);
+    DEBUG("session %p size %d alloc\n", pSessionCtx, sessionCtxSize);
+
+    if (NULL == pSessionCtx)
+    {
+        WARN("[%s] --- pSessionCtx malloc failed !\n", __func__);
+        OPENSSL_free(sessionSetupData);
+        return 0;
+    }
+    if (!cb)
+    {
+	    /* Assign thestandard sync callback function */
+        qat_eng_cb = qat_crypto_callbackFn;
+    }
+#ifdef OPENSSL_QAT_ASYNCH
+    else
+    {
+	    /* Assign the asynch callback function */
+        qat_eng_cb = qat_cipherAsynchCallbackFn;
+    }
+#endif
+
+    if ((sts = cpaCySymInitSession
+               (instanceHandle, qat_eng_cb, sessionSetupData,
+                pSessionCtx)) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCySymInitSession failed, sts = %d \n", __func__, sts);
+        OPENSSL_free(sessionSetupData);
+        qaeCryptoMemFree (pSessionCtx);
+        return 0;
+    }
+
+    if ((sts = cpaCyBufferListGetMetaSize(instanceHandle,
+                                          1, &metaSize)) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCyBufferListGetBufferSize failed sts=%d.\n",
+             __func__, sts);
+        OPENSSL_free(sessionSetupData);
+        qaeCryptoMemFree (pSessionCtx);
+        return 0;
+    }
+
+    if (metaSize)
+    {
+        srcPrivateMetaData = qaeCryptoMemAlloc(metaSize, __FILE__, __LINE__);
+        if (!srcPrivateMetaData)
+        {
+            WARN("[%s] --- srcBufferList.pPrivateMetaData is NULL.\n",
+                 __func__);
+            qaeCryptoMemFree (pSessionCtx);
+            return 0;
+        }
+        dstPrivateMetaData = qaeCryptoMemAlloc(metaSize, __FILE__, __LINE__);
+        if (!dstPrivateMetaData)
+        {
+            WARN("[%s] --- dstBufferList.pPrivateMetaData is NULL.\n",
+                 __func__);
+            OPENSSL_free(sessionSetupData);
+            qaeCryptoMemFree (pSessionCtx);
+            qaeCryptoMemFree (srcPrivateMetaData);
+            return 0;
+        }
+    }
+    else
+    {
+        srcPrivateMetaData = NULL;
+        dstPrivateMetaData = NULL;
+    }
+
+    /* pinned memory is not required for qat_context */
+    qat_context = ctx->cipher_data;
+    qat_context->meta_size = metaSize;
+
+    if (NULL == qat_context)
+    {
+        WARN("[%s] --- qat_context not allocated.\n", __func__);
+        OPENSSL_free(sessionSetupData);
+        qaeCryptoMemFree (pSessionCtx);
+		if (srcPrivateMetaData)
+            qaeCryptoMemFree (srcPrivateMetaData);
+		if (dstPrivateMetaData)
+            qaeCryptoMemFree (dstPrivateMetaData);
+        return 0;
+    }
+
+    qat_context->paramNID = cipherType;
+
+    qat_context->ctx = pSessionCtx;
+    qat_context->session_data = sessionSetupData;
+    qat_context->cipher_cb = cb;
+    qat_context->srcPrivateMetaData = srcPrivateMetaData;
+    qat_context->dstPrivateMetaData = dstPrivateMetaData;
+
+    qat_context->enc = enc;
+    qat_context->instanceHandle = instanceHandle;
+    qat_context->init = 1;
+
+    return 1;
+}
+
+/******************************************************************************
+* function:
+*         qat_cipher_init_synch( EVP_CIPHER_CTX *ctx,
+*                                const unsigned char *key,
+*                                const unsigned char *iv,
+*                                int enc)
+*
+* @param ctx [IN] - cipher ctx
+* @param key [IN] - pointer to the key value.
+* @param iv  [IN] - pointer to initial vector.
+* @param enc [IN] - encryption indicator
+*
+* description:
+*   Wrapper to the cipher_init function for synchronous calls
+*   The function will return 1 if successful.
+******************************************************************************/
+static int
+qat_cipher_init_synch(EVP_CIPHER_CTX * ctx, const unsigned char *key,
+                  const unsigned char *iv, int enc)
+{
+    DEBUG("[%s] --- called.\n", __func__);
+
+    return cipher_init(ctx, key, iv, enc, NULL);
+}
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*         qat_cipher_init_asynch( EVP_CIPHER_CTX *ctx,
+*                                 const unsigned char *key,
+*                                 const unsigned char *iv,
+*                                 int enc,
+*                                 int (*cb)(unsigned char *out, int outl,
+*                                           void *cb_data, int status))
+*
+* @param ctx [IN] - cipher ctx
+* @param key [IN] - pointer to the key value.
+* @param iv  [IN] - pointer to initial vector.
+* @param enc [IN] - encryption indicator
+* @param cb  [IN] - callback function pointer
+*
+* description:
+*   Wrapper to the cipher_init function for asynchronous calls
+*   The function will return 1 if successful.
+******************************************************************************/
+static int
+qat_cipher_init_asynch(EVP_CIPHER_CTX * ctx, const unsigned char *key,
+                   const unsigned char *iv, int enc,
+                   int (*cb)(unsigned char *out, int outl,
+                              void *cb_data, int status))
+{
+    DEBUG("[%s] --- called.\n", __func__);
+
+    return cipher_init(ctx, key, iv, enc, cb);
+}
+#endif
+
+/******************************************************************************
+* function:
+*         qat_do_cipher_synch(EVP_CIPHER_CTX *ctx,
+*                                   unsigned char *out,
+*                                   const unsigned char *in,
+*                                   size_t inl)
+*
+* @param ctx [IN]  - pointer to cipher ctx
+* @param out [OUT] - pointer to the output file
+* @param in  [IN]  - pointer to input data
+* @param inl [IN]  - Message length to cipher in bytes
+*
+* description:
+*    This function is rewrite of aes_xxx_cbc_do_cipher() in OpenSSL.
+*    All the inputs are passed form the above OpenSSL layer to the
+*    corresponding API cpaCySymPerformOp() function.
+*    The function encrypt inl bytes from the buffer pointer in and writes
+*    the encrypted version to the output pointer.
+*    It is the second function called in cipher routine sequences
+*    and return 1 if successful
+******************************************************************************/
+static int qat_do_cipher_synch(EVP_CIPHER_CTX * ctx, unsigned char *out,
+                          const unsigned char *in, size_t inl)
+{
+
+    CpaCySymSessionCtx pSessionCtx = NULL;
+    CpaCySymOpData OpData = { 0, };
+    CpaBufferList srcBufferList = { 0, };
+    CpaFlatBuffer srcFlatBuffer = { 0, };
+    CpaBufferList dstBufferList = { 0, };
+    CpaFlatBuffer dstFlatBuffer = { 0, };
+    qat_ctx *qat_context = NULL;
+    CpaStatus sts = 0;
+    struct op_done opDone;
+    int cipherType = 0;
+    int inMemAlloc = 0;
+    int rc = 1;
+
+    DEBUG("\n[%s] --- do_cipher %p BEGIN, inl %d\n", __func__, ctx, (int) inl);
+	CRYPTO_QAT_LOG("CIPHER - %s\n", __func__);
+
+    if ((!in) || (!out) || (!ctx))
+    {
+        WARN("[%s] --- in, out or ctx is NULL.\n", __func__);
+        return 0;
+    }
+
+    DUMPL("Input", in, inl);
+
+    //Identify the Cipher algorithm being requested
+    cipherType = EVP_CIPHER_CTX_nid(ctx);
+
+	if (!(ctx->cipher_data))
+    {
+        WARN("[%s] --- ctx->cipher_data has not been initialised.\n", __func__);
+        return 0;
+    }
+    qat_context = (qat_ctx *) (ctx->cipher_data);
+
+    if (!(qat_context->init))
+    {
+        WARN("[%s] --- context has not been initialised with a key.\n", __func__);
+        return 0;
+    }
+
+    pSessionCtx = qat_context->ctx;
+
+    OpData.sessionCtx = pSessionCtx;
+    if (NID_rc4 != cipherType)
+        OpData.packetType = CPA_CY_SYM_PACKET_TYPE_FULL;
+    else
+        OpData.packetType = CPA_CY_SYM_PACKET_TYPE_PARTIAL;
+
+    /* Initialization Vector or Counter. */
+    DEBUG ("%s iv len is %d\n", __func__, EVP_CIPHER_CTX_iv_length(ctx));
+    DUMPL("ctx->iv", ctx->iv, EVP_CIPHER_CTX_iv_length(ctx));
+
+    if (isZeroCopy())
+    {
+        if (NID_rc4 != cipherType)
+            OpData.pIv = copyAllocPinnedMemory (ctx->iv, EVP_CIPHER_CTX_iv_length(ctx), __FILE__, __LINE__);
+        else
+            OpData.pIv = NULL;
+
+        /* There are cases where ctx is created on stack instead of in memory driver
+         * like it is in ssl3_send_newsession_ticket and
+         * passed on the same down to this function.
+         *
+         * The QAT Engine must receive a buffer that has been allocated by the memory driver.
+         * There is no mechanism to tell whether the in buffer is pointing to a ctx->buf
+         * that was allocated on the stack or in the memory driver.
+         * To be sure of having a memory driver allocated buffer in all cases
+         * we must always allocate a new buffer even though there are times when this is not necessary.*/
+        if( in == ctx->buf)
+        {
+            srcFlatBuffer.pData = (Cpa8U *) copyAllocPinnedMemory ((void*)in, inl, __FILE__, __LINE__);
+            inMemAlloc=1;
+        }
+        else
+        {
+            srcFlatBuffer.pData = (Cpa8U *) in;
+        }
+	    //TODO: Need to put a check in here to ensure that it's in place for RC4
+        dstFlatBuffer.pData = (Cpa8U *) out;
+    }
+    else
+    {
+        srcFlatBuffer.pData = (Cpa8U *) copyAllocPinnedMemory ((void*)in, inl, __FILE__, __LINE__);
+        //TODO for non-chained this could be an inplace operation. Investigate
+        if (NID_rc4 == cipherType)
+        {
+            OpData.pIv = NULL;
+            dstFlatBuffer.pData = srcFlatBuffer.pData;
+        }
+        else
+        {
+            OpData.pIv = (Cpa8U *) copyAllocPinnedMemory (ctx->iv, EVP_CIPHER_CTX_iv_length(ctx), __FILE__, __LINE__);
+            dstFlatBuffer.pData = (Cpa8U *) qaeCryptoMemAlloc(inl, __FILE__, __LINE__);
+        }
+    }
+
+    /* Starting point for cipher processing - given as number of bytes from
+       start of data in the source buffer. The result of the cipher operation
+       will be written back into the output buffer starting at this location. */
+    OpData.cryptoStartSrcOffsetInBytes = 0;
+    /* Starting point for hash processing - given as number of bytes from start
+       of packet in source buffer. */
+    OpData.hashStartSrcOffsetInBytes = 0;
+    /* The message length, in bytes, of the source buffer that the hash will be
+       computed on.  */
+    OpData.messageLenToHashInBytes = 0;
+    /* Pointer to the location where the digest result either exists or will be
+       inserted. */
+    OpData.pDigestResult = NULL;
+    /* Pointer to Additional Authenticated Data (AAD) needed for authenticated
+     cipher mechanisms - CCM and GCM. For other authentication mechanisms
+       this pointer is ignored. */
+    OpData.pAdditionalAuthData = NULL;
+    /* The message length, in bytes, of the source buffer that the crypto
+       operation will be computed on. This must be a multiple to the block size
+       if a block cipher is being used. */
+    OpData.messageLenToCipherInBytes = inl;
+
+    /* Cipher IV length in bytes.  Determines the amount of valid IV data
+       pointed to by the pIv parameter. */
+    OpData.ivLenInBytes = (Cpa32U) EVP_CIPHER_CTX_iv_length(ctx);
+
+    srcFlatBuffer.dataLenInBytes = (Cpa32U) inl;
+    /* Number of pointers */
+    srcBufferList.numBuffers = 1;
+    /* Pointer to an unbounded array containing the number of CpaFlatBuffers
+       defined by numBuffers */
+    srcBufferList.pBuffers = &srcFlatBuffer;
+    srcBufferList.pUserData = NULL;
+
+    srcBufferList.pPrivateMetaData = qat_context->srcPrivateMetaData;
+
+    dstFlatBuffer.dataLenInBytes = (Cpa32U) inl;
+    /* Number of pointers */
+    dstBufferList.numBuffers = 1;
+    /* Pointer to an unbounded array containing the number of CpaFlatBuffers
+       defined by numBuffers */
+    dstBufferList.pBuffers = &dstFlatBuffer;
+    /* This is an opaque field that is not read or modified internally. */
+    dstBufferList.pUserData = NULL;
+
+    dstBufferList.pPrivateMetaData = qat_context->dstPrivateMetaData;
+
+    DEBUG("[%s] performing with %d bytes (iv-len=%d)\n", __func__, (int)inl,
+          EVP_CIPHER_CTX_iv_length(ctx));
+
+    initOpDone(&opDone);
+
+    if (((sts = myPerformOp(qat_context->instanceHandle,
+							&opDone,
+							&OpData,
+							&srcBufferList,
+							&dstBufferList,
+							CPA_FALSE)) != CPA_STATUS_SUCCESS) ||
+		((rc = waitForOpToComplete(&opDone)) != 0))
+
+	{
+		if (sts != CPA_STATUS_SUCCESS)
+		{
+			WARN("[%s] --- cpaCySymPerformOp failed sts=%d.\n", __func__, sts);
+		}
+		else
+		{
+			WARN("[%s] --- cpaCySymPerformOp timed out.\n", __func__);
+		}
+		if (!isZeroCopy())
+		{
+			if(NID_rc4 != cipherType) //RC4 is an inplace operation
+			{
+				if (OpData.pIv)
+				{
+					qaeCryptoMemFree(OpData.pIv);
+					OpData.pIv=NULL;
+				}
+				if (srcFlatBuffer.pData)
+				{
+					qaeCryptoMemFree(srcFlatBuffer.pData);
+					srcFlatBuffer.pData=NULL;
+				}
+			}
+			if (dstFlatBuffer.pData)
+			{
+				qaeCryptoMemFree(dstFlatBuffer.pData);
+				dstFlatBuffer.pData=NULL;
+			}
+		}
+		else if ( isZeroCopy() &&
+				  inMemAlloc &&
+				  srcFlatBuffer.pData )
+		{
+			qaeCryptoMemFree(srcFlatBuffer.pData);
+			srcFlatBuffer.pData=NULL;
+		}
+
+		cleanupOpDone(&opDone);
+		return 0;
+    }
+	cleanupOpDone(&opDone);
+
+    /*  If encrypting, the IV is the last block of the destination (ciphertext)
+     *  buffer.  If decrypting, the source buffer is the ciphertext.
+     */
+    if (NID_rc4 != cipherType)
+    {
+        if (qat_context->enc)
+        {
+            memcpy(ctx->iv,
+                   (dstBufferList.pBuffers[0].pData + inl -
+                   EVP_CIPHER_CTX_iv_length(ctx)),
+                   EVP_CIPHER_CTX_iv_length(ctx));
+        }
+        else
+        {
+            memcpy(ctx->iv,
+                   (srcBufferList.pBuffers[0].pData + inl -
+                   EVP_CIPHER_CTX_iv_length(ctx)),
+                   EVP_CIPHER_CTX_iv_length(ctx));
+        }
+    }
+
+    if (!isZeroCopy())
+    {
+        if(NID_rc4 != cipherType) //RC4 is an inplace operation
+        {
+            qaeCryptoMemFree (OpData.pIv);
+            qaeCryptoMemFree (srcFlatBuffer.pData);
+        }
+        copyFreePinnedMemory (out, dstFlatBuffer.pData, inl);
+    }
+
+    DEBUG("[%s] --- do_cipher END\n\n", __func__);
+
+    return 1;
+}
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*         qat_do_cipher_asynch(EVP_CIPHER_CTX *ctx,
+*                          unsigned char *out,
+*                          const unsigned char *in,
+*                          size_t inl,
+*                          void *cb_data)
+*
+* @param ctx     [IN]  - pointer to cipher ctx
+* @param out     [OUT] - pointer to the output file
+* @param in      [IN]  - pointer to input data
+* @param inl     [IN]  - Message length to cipher in bytes
+* @param cb_data [IN] - Callback data
+*
+* description:
+*    This function is rewrite of aes_xxx_cbc_do_cipher() in OpenSSL.
+*    All the inputs are passed form the above OpenSSL layer to the
+*    corresponding API cpaCySymPerformOp() function.
+*    The function encrypt inl bytes from the buffer pointer in and writes
+*    the encrypted version to the output pointer.
+*    It is the second function called in cipher routine sequences
+*    and return 1 if successful
+******************************************************************************/
+static int qat_do_cipher_asynch(EVP_CIPHER_CTX * ctx, unsigned char *out,
+                          const unsigned char *in, size_t inl,
+                          void *cb_data)
+{
+    qat_ctx *qat_context = NULL;
+    CpaStatus sts = 0;
+    struct op_done_asynch *op_done = NULL;
+    AGG_REQ *agg_req = NULL;
+
+    DEBUG("\n[%s] --- qat_do_cipher_asynch %p BEGIN, inl %d\n", __func__, ctx, (int) inl);
+    CRYPTO_QAT_LOG("CIPHER - %s\n", __func__);
+
+    if ((!in) || (!out) || (!ctx))
+    {
+        WARN("[%s] --- in, out or ctx is NULL.\n", __func__);
+        return 0;
+    }
+
+	if (!ctx->cipher_data)
+    {
+        WARN("[%s] --- ctx->cipher_data is NULL.\n", __func__);
+        return 0;
+    }
+
+    qat_context = (qat_ctx *) (ctx->cipher_data);
+
+	if (!(qat_context->init))
+    {
+        WARN("[%s] --- context has not been initialised with a key.\n", __func__);
+        return 0;
+    }
+    DUMPL("Input", in, inl);
+    DEBUG ("%s iv len is %d\n", __func__, EVP_CIPHER_CTX_iv_length(ctx));
+    DUMPL("ctx->iv", ctx->iv, EVP_CIPHER_CTX_iv_length(ctx));
+
+    agg_req = create_request(ctx, out, in, inl,
+		qat_context->ctx, qat_context->meta_size);
+    if(NULL == agg_req)
+    {
+        WARN("%s: Unable to create request\n", __func__);
+        goto end;
+    }
+
+    //In Asynch mode the requestor and the recipient may be in different threads,
+    //therefore all memory transferred as part of the request needs to be malloc'd
+    if( NULL == (op_done = OPENSSL_malloc(sizeof(struct op_done_asynch))))
+    {
+        WARN("%s: Unable to malloc space for opDone Structure\n", __func__);
+        goto end;
+    }
+
+    op_done->cipher_ctx = ctx;
+    op_done->orig_out = out;
+    op_done->orig_len = inl;
+    op_done->agg_req = agg_req;
+    op_done->cb_data = cb_data;
+
+    /*  If encrypting, the IV is the last block of the destination (ciphertext)
+     *  buffer.  If decrypting, the source buffer is the ciphertext. If we are
+     *  are doing an inplace operation this doesn;t hold true so we need to get
+     *  decryption IV prior to actually decrypting the data.
+     */
+    if (NID_rc4 != EVP_CIPHER_CTX_nid(ctx) && !(ctx->encrypt))
+    {
+        memcpy(ctx->iv,
+               (SRC_BUFFER_DATA(agg_req)[0].pData + inl -
+                EVP_CIPHER_CTX_iv_length(ctx)),
+                EVP_CIPHER_CTX_iv_length(ctx));
+    }
+
+    DUMPREQ(qat_context->instanceHandle, op_done, OPDATA_PTR(agg_req),
+            qat_context->session_data, SRC_BUFFER_LIST(agg_req),
+	    DST_BUFFER_LIST(agg_req));
+
+    sts = cpaCySymPerformOp(qat_context->instanceHandle,
+                            op_done,
+                            OPDATA_PTR(agg_req),
+                            SRC_BUFFER_LIST(agg_req),
+                            DST_BUFFER_LIST(agg_req),
+                            CPA_FALSE);
+
+    if (sts != CPA_STATUS_SUCCESS)
+    {
+        WARN("%s: cpaCySymPerformOp failed sts=%d.\n", __func__, sts);
+        if (CPA_STATUS_RETRY == sts)
+	        QATerr(QAT_F_QAT_DO_CIPHER_ASYNCH, ERR_R_RETRY);
+        goto end;
+    }
+
+    /* Update transmission stats */
+    qat_context->noRequests++;
+
+    DEBUG("%s: qat_do_cipher_asynch END\n\n", __func__);
+
+    return 1;
+
+    end:
+    if(NULL != agg_req)
+	    destroy_request(agg_req);
+    if(NULL != op_done)
+        OPENSSL_free(op_done);
+    return 0;
+}
+#endif
+
+/******************************************************************************
+* function:
+*         common_cipher_cleanup(EVP_CIPHER_CTX *ctx)
+*
+* @param ctx [IN]  - pointer to cipher ctx
+*
+* description:
+*    This function is rewrite of aes_xxx_cbc_cleanup() in OpenSSL. The function is design
+*    to clears all information form a cipher context and free up any allocated memory
+*    associate it. It is the last function called in cipher routine sequences.
+*    The function will return 1 if successful
+******************************************************************************/
+static int common_cipher_cleanup(EVP_CIPHER_CTX *ctx)
+{
+    CpaStatus sts = 0;
+    CpaCySymSessionCtx pSessionCtx = NULL;
+    qat_ctx *qat_context = NULL;
+    int count=0;
+    Cpa64U num_inflight = 0;
+    struct timespec reqTime = {0};
+	struct timespec remTime = {0};
+
+    DEBUG("[%s] --- cleaning\n\n", __func__);
+
+    if (!ctx)
+    {
+        WARN("[%s] --- ctx is NULL.\n", __func__);
+        return 0;
+    }
+
+    if (!ctx->cipher_data)
+    {
+        WARN("[%s] --- ctx->cipher_data is NULL.\n", __func__);
+        return 0;
+    }
+
+    qat_context = (qat_ctx *) (ctx->cipher_data);
+
+    if(!(qat_context->init))
+    {
+        /* It is valid to call cleanup on a context that hasn't been initialised */
+        return 1;
+    }
+
+    pSessionCtx = qat_context->ctx;
+
+    /* Check for inflight requests */
+    num_inflight = qat_context->noRequests - qat_context->noResponses;
+    while((0 != num_inflight) && (count < QAT_CIPHER_CLEANUP_RETRY_COUNT))
+    {
+        count++;
+        /* Wait for some time */
+        reqTime.tv_nsec = QAT_CIPHER_CLEANUP_WAIT_TIME_NS;
+        do {
+           nanosleep(&reqTime, &remTime);
+		   reqTime.tv_sec = remTime.tv_sec;
+           reqTime.tv_nsec = remTime.tv_nsec;
+           if((errno < 0) && (EINTR != errno))
+           {
+               WARN("nanosleep system call failed: errno %i\n", errno);
+               break;
+           }
+        } while (EINTR == errno);
+
+        num_inflight = qat_context->noRequests - qat_context->noResponses;
+    }
+
+    if(0 != num_inflight)
+    {
+        WARN("[%s] --- Still %ld cipher messages in flight.\n",
+             __func__, num_inflight);
+        return 0;
+
+    }
+
+    if ((sts =
+         cpaCySymRemoveSession(qat_context->instanceHandle,
+                               pSessionCtx)) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCySymRemoveSession failed, sts = %d.\n",
+             __func__, sts);
+        return 0;
+    }
+
+    if (qat_context->session_data)
+	    OPENSSL_free(qat_context->session_data);
+    if (pSessionCtx)
+        qaeCryptoMemFree (pSessionCtx);
+    if (qat_context->srcPrivateMetaData)
+        qaeCryptoMemFree (qat_context->srcPrivateMetaData);
+    if (qat_context->dstPrivateMetaData)
+        qaeCryptoMemFree (qat_context->dstPrivateMetaData);
+
+    qat_context->init = 0;
+    return 1;
+
+}
+
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_ciphers.h ./engines/qat_engine/qat_ciphers.h
--- ../openssl-async/engines/qat_engine/qat_ciphers.h	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_ciphers.h	2015-03-05 12:43:44.241960000 +0000
@@ -0,0 +1,104 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qat_ciphers.h
+ *
+ * This file provides a interface for engine cipher operations
+ *
+ *****************************************************************************/
+
+#ifndef QAT_CIPHERS_H
+#define QAT_CIPHERS_H
+
+#include <openssl/engine.h>
+
+#define RC4_BLOCK_SIZE	    1
+#define RC4_IV_LEN  	    0
+#define RC4_KEY_SIZE  	    16
+#define RC4_FLAGS      	    0
+
+#define DES_BLOCK_SIZE	    8
+#define DES_KEY_SIZE	    8
+#define DES_IV_LEN	        8
+
+#define DES3_BLOCK_SIZE	    8
+#define DES3_KEY_SIZE	    24
+#define DES3_IV_LEN	        8
+
+#define AES_BLOCK_SIZE      16
+#define AES_IV_LEN          16
+#define AES_KEY_SIZE_256    32
+#define AES_KEY_SIZE_192    24
+#define AES_KEY_SIZE_128    16
+
+#define data(ctx) ((qat_chained_ctx *)(ctx)->cipher_data)
+#define HMAC_KEY_SIZE       64
+#define TLS_VIRT_HDR_SIZE   13
+
+#define NO_PAYLOAD_LENGTH_SPECIFIED ((size_t)-1)
+
+/* How long to wait for inflight messages before cleanup */
+#define QAT_CIPHER_CLEANUP_RETRY_COUNT 10
+#define QAT_CIPHER_CLEANUP_WAIT_TIME_NS 1000000
+
+#define qat_common_cipher_flags EVP_CIPH_FLAG_DEFAULT_ASN1
+#define qat_common_cbc_flags    (qat_common_cipher_flags | EVP_CIPH_CBC_MODE \
+                                | EVP_CIPH_CUSTOM_IV)
+
+#define QAT_TLS_PAYLOADLENGTH_MSB_OFFSET 2
+#define QAT_TLS_PAYLOADLENGTH_LSB_OFFSET 1
+#define QAT_TLS_VERSION_MSB_OFFSET       4
+#define QAT_TLS_VERSION_LSB_OFFSET       3
+#define QAT_BYTE_SHIFT                   8
+
+int qat_ciphers_synch(ENGINE * e, const EVP_CIPHER ** cipher, const int **nids, int nid);
+int qat_ciphers_asynch(ENGINE * e, const EVP_CIPHER ** cipher, const int **nids, int nid);
+
+#endif //QAT_CIPHERS_H
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_dh.c ./engines/qat_engine/qat_dh.c
--- ../openssl-async/engines/qat_engine/qat_dh.c	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_dh.c	2015-03-05 12:43:44.242963000 +0000
@@ -0,0 +1,938 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qat_dh.c
+ *
+ * This file provides implementaiotns for Diffie Hellman operations through an
+ * OpenSSL engine
+ *
+ *****************************************************************************/
+
+#include "qat_dh.h"
+#ifdef USE_QAT_MEM
+#include "qae_mem_utils.h"
+#endif
+#ifdef USE_QAE_MEM
+#include "qat_mem_drv_inf.h"
+#endif
+#include "qat_asym_common.h"
+#include "qat_utils.h"
+#include "cpa.h"
+#include "cpa_types.h"
+#include "cpa_cy_dh.h"
+#include "e_qat.h"
+#include "e_qat_err.h"
+#include <unistd.h>
+#include <string.h>
+
+#ifdef OPENSSL_ENABLE_QAT_DH_SYNCH
+#ifdef OPENSSL_DISABLE_QAT_DH_SYNCH
+#undef OPENSSL_DISABLE_QAT_DH_SYNCH
+#endif
+#endif
+
+#ifdef OPENSSL_ENABLE_QAT_DH_ASYNCH
+#ifdef OPENSSL_DISABLE_QAT_DH_ASYNCH
+#undef OPENSSL_DISABLE_QAT_DH_ASYNCH
+#endif
+#endif
+
+#ifndef OPENSSL_QAT_ASYNCH
+#define OPENSSL_DISABLE_QAT_DH_ASYNCH
+#endif
+
+/* To specify the DH op sizes supported by QAT engine */
+#define DH_QAT_RANGE_MIN 768
+#define DH_QAT_RANGE_MAX 4096
+
+int qat_dh_generate_key_synch(DH *dh);
+int qat_dh_generate_key_asynch(DH *dh,
+				int (*cb)(unsigned char *res, size_t reslen,
+				void *cb_data, int status),
+				void *cb_data);
+int qat_dh_compute_key_synch(unsigned char *key, const BIGNUM *pub_key, DH *dh);
+
+int qat_dh_compute_key_asynch(unsigned char *key, int *len, const BIGNUM *pub_key,
+				DH *dh,
+				int (*cb)(unsigned char *res, size_t reslen,
+				void *cb_data, int status),
+				void *cb_data);
+
+static DH_METHOD qat_dh_method = {
+	"QAT DH method",            /* name */
+	qat_dh_generate_key_synch,   /* generate_key */
+	qat_dh_compute_key_synch,    /* compute_key */
+	qat_mod_exp_dh,             /* bn_mod_exp */
+	NULL,                       /* init */
+	NULL,                       /* finish */
+	0,                          /* flags */
+	NULL,                       /* app_data */
+	NULL,                       /* generate_params */
+#ifdef OPENSSL_QAT_ASYNCH
+	qat_dh_generate_key_asynch, /* generate_key asynch */
+	qat_dh_compute_key_asynch   /* compute_key asynch */
+#endif
+	};
+
+DH_METHOD *get_DH_methods(void)
+{
+#ifdef OPENSSL_DISABLE_QAT_DH_SYNCH
+#ifndef OPENSSL_DISABLE_QAT_DH_ASYNCH
+	const DH_METHOD* def_dh_meth = DH_get_default_method();
+	if (def_dh_meth)
+		{
+		qat_dh_method.generate_key     = def_dh_meth->generate_key;
+		qat_dh_method.compute_key      = def_dh_meth->compute_key;
+		qat_dh_method.bn_mod_exp       = def_dh_meth->bn_mod_exp;
+		}
+	else
+		{
+		qat_dh_method.generate_key     = NULL;
+		qat_dh_method.compute_key      = NULL;
+		qat_dh_method.bn_mod_exp       = NULL;
+		}
+#endif
+#endif
+
+#ifdef OPENSSL_QAT_ASYNCH
+#ifndef OPENSSL_DISABLE_QAT_DH_SYNCH
+#ifdef OPENSSL_DISABLE_QAT_DH_ASYNCH
+	qat_dh_method.generate_key_asynch    = NULL;
+	qat_dh_method.compute_key_asynch     = NULL;
+#endif
+#endif
+#endif
+
+#ifdef OPENSSL_DISABLE_QAT_DH_SYNCH
+#ifdef OPENSSL_DISABLE_QAT_DH_ASYNCH
+	return NULL;
+#endif
+#endif
+	return &qat_dh_method;
+	}
+
+typedef struct dh_generate_op_data
+	{
+	DH *dh;
+	BIGNUM *priv_key;
+	BIGNUM *pub_key;
+	CpaCyDhPhase1KeyGenOpData* opData;
+	size_t outlen;
+	int (*cb_func)(unsigned char *res, size_t reslen,
+			void *cb_data, int status);
+	void *cb_data;
+	} dh_generate_op_data_t;
+
+typedef struct dh_compute_op_data
+	{
+	int *len;
+	unsigned char *key;
+	CpaCyDhPhase2SecretKeyGenOpData* opData;
+	size_t outlen;
+	int (*cb_func)(unsigned char *res, size_t reslen,
+			void *cb_data, int status);
+	void *cb_data;
+	} dh_compute_op_data_t;
+
+
+/* The DH range check is performed so that if the op sizes are not in the
+ * range supported by QAT engine then fall back to software */
+
+int dh_range_check(int plen)
+	{
+	int range=0;
+
+	if ((plen >= DH_QAT_RANGE_MIN) && (plen <= DH_QAT_RANGE_MAX))
+		range = 1;
+
+	return range;
+	}
+
+/* Callback to indicate QAT completion of DH generate & compute key */
+void qat_dhCallbackFn(void *pCallbackTag, CpaStatus status, void *pOpData,
+     CpaFlatBuffer *pPV)
+
+	{
+	qat_crypto_callbackFn(pCallbackTag, status, CPA_CY_SYM_OP_CIPHER, pOpData,
+				NULL, CPA_FALSE);
+	}
+
+#ifdef OPENSSL_QAT_ASYNCH
+/* Callback to indicate QAT completion of DH generate key in asynch mode*/
+void qat_dhGenerateAsynchCallbackFn(void *pCallbackTag, CpaStatus status,
+     void *pOpData, CpaFlatBuffer *pPV)
+
+	{
+	dh_generate_op_data_t* dh_asynch_data =
+				(dh_generate_op_data_t*)(pCallbackTag);
+	int cb_status = status == CPA_STATUS_SUCCESS ? 1 : 0;
+
+	if (!dh_asynch_data || !pPV)
+		{
+		WARN("[%s] --- parameter NULL!\n",__func__);
+		goto err;
+		}
+
+	dh_asynch_data->dh->priv_key=dh_asynch_data->priv_key;
+	/* Convert the flatbuffer result back to a BN */
+	BN_bin2bn(pPV->pData, pPV->dataLenInBytes, dh_asynch_data->pub_key);
+	dh_asynch_data->dh->pub_key=dh_asynch_data->pub_key;
+
+	dh_asynch_data->cb_func(NULL, 0, dh_asynch_data->cb_data, cb_status);
+err:
+
+	if (pPV)
+		{
+		if (pPV->pData)
+			{
+			qaeCryptoMemFree(pPV->pData);
+			}
+		OPENSSL_free(pPV);
+		}
+
+	if (dh_asynch_data)
+		{
+		if (dh_asynch_data->opData)
+			{
+			if (dh_asynch_data->opData->primeP.pData)
+			   qaeCryptoMemFree(dh_asynch_data->opData \
+			   ->primeP.pData);
+			if (dh_asynch_data->opData->baseG.pData)
+			   qaeCryptoMemFree(dh_asynch_data->opData \
+			   ->baseG.pData);
+			if (dh_asynch_data->opData->privateValueX.pData)
+			   qaeCryptoMemFree(dh_asynch_data->opData \
+			   ->privateValueX.pData);
+			OPENSSL_free (dh_asynch_data->opData);
+			}
+
+		if ((dh_asynch_data->pub_key != NULL)  &&
+		  (dh_asynch_data->dh->pub_key == NULL))
+			BN_free(dh_asynch_data->pub_key);
+		if ((dh_asynch_data->priv_key != NULL) &&
+		  (dh_asynch_data->dh->priv_key == NULL))
+			BN_free(dh_asynch_data->priv_key);
+		OPENSSL_free(dh_asynch_data);
+		}
+	}
+#endif
+
+#ifdef OPENSSL_QAT_ASYNCH
+/* Callback to indicate QAT completion of DH compute key asynch mode */
+void qat_dhComputeAsynchCallbackFn(void *pCallbackTag, CpaStatus status,
+     void *pOpData, CpaFlatBuffer *pSecretKey)
+
+	{
+	dh_compute_op_data_t* dh_asynch_data = (dh_compute_op_data_t*)(pCallbackTag);
+	int cb_status = status == CPA_STATUS_SUCCESS ? 1 : 0;
+	int index=1;
+
+	if (!dh_asynch_data || !pSecretKey || !dh_asynch_data->len)
+		{
+		WARN("[%s] --- parameter NULL!\n",__func__);
+		goto err;
+		}
+
+	if(!pSecretKey->pData[0])
+		{
+		while(!pSecretKey->pData[index])
+			index++;
+		pSecretKey->dataLenInBytes = pSecretKey->dataLenInBytes - index;
+		memcpy(dh_asynch_data->key, &pSecretKey->pData[index], pSecretKey->dataLenInBytes);
+		}
+	else
+		{
+		memcpy(dh_asynch_data->key, pSecretKey->pData, pSecretKey->dataLenInBytes);
+		}
+	*dh_asynch_data->len = pSecretKey->dataLenInBytes;
+
+	dh_asynch_data->cb_func(dh_asynch_data->key, *dh_asynch_data->len,
+				dh_asynch_data->cb_data, cb_status);
+err:
+	if (pSecretKey)
+		{
+		if (pSecretKey->pData)
+			{
+			qaeCryptoMemFree(pSecretKey->pData);
+			}
+		OPENSSL_free(pSecretKey);
+		}
+
+	if (dh_asynch_data)
+		{
+		if (dh_asynch_data->opData)
+			{
+			if (dh_asynch_data->opData->primeP.pData)
+				qaeCryptoMemFree(dh_asynch_data->opData \
+							->primeP.pData);
+			if (dh_asynch_data->opData->remoteOctetStringPV.pData)
+				qaeCryptoMemFree(dh_asynch_data->opData \
+					->remoteOctetStringPV.pData);
+			if (dh_asynch_data->opData->privateValueX.pData)
+				qaeCryptoMemFree(dh_asynch_data->opData \
+					->privateValueX.pData);
+			OPENSSL_free (dh_asynch_data->opData);
+			}
+		OPENSSL_free(dh_asynch_data);
+		}
+	}
+#endif
+
+/******************************************************************************
+* function:
+*         qat_dh_generate_key(DH * dh,
+*                             int (*cb)(unsigned char *res, size_t reslen,
+*                             void *cb_data, int status),
+*                             void *cb_data)
+*
+* description:
+*   Implement Diffie-Hellman phase 1 operations.
+******************************************************************************/
+int qat_dh_generate_key(DH *dh,
+			int (*cb)(unsigned char *res, size_t reslen,
+			void *cb_data, int status),
+			void *cb_data)
+	{
+	int ok=0, rc = 1;
+	int generate_new_key=0;
+	unsigned length=0;
+	BIGNUM *pub_key=NULL,*priv_key=NULL;
+	CpaInstanceHandle instanceHandle;
+	CpaCyDhPhase1KeyGenOpData *opData=NULL;
+	CpaFlatBuffer *pPV=NULL;
+	int qatPerformOpRetries = 0;
+	useconds_t ulPollInterval = getQatPollInterval();
+	int iMsgRetry = getQatMsgRetryCount();
+	CpaStatus status;
+	struct op_done op_done;
+	size_t buflen;
+#ifdef OPENSSL_QAT_ASYNCH
+	dh_generate_op_data_t *dh_op_done=NULL;
+#endif
+
+	DEBUG("%s been called \n", __func__);
+	CRYPTO_QAT_LOG("KX - %s\n", __func__);
+
+	opData = (CpaCyDhPhase1KeyGenOpData *)
+			OPENSSL_malloc(sizeof(CpaCyDhPhase1KeyGenOpData));
+	if (opData == NULL)
+		{
+		QATerr(QAT_F_QAT_DH_GENERATE_KEY, ERR_R_MALLOC_FAILURE);
+		return ok;
+		}
+
+	opData->primeP.pData        = NULL;
+	opData->baseG.pData         = NULL;
+	opData->privateValueX.pData = NULL;
+
+	if (dh->priv_key == NULL)
+		{
+		if ((priv_key = BN_new()) == NULL)
+			{
+			QATerr(QAT_F_QAT_DH_GENERATE_KEY, ERR_R_INTERNAL_ERROR);
+			goto err;
+			}
+		generate_new_key=1;
+		}
+	else
+		priv_key=dh->priv_key;
+
+	if (dh->pub_key == NULL)
+		{
+		if ((pub_key = BN_new()) == NULL)
+			{
+			QATerr(QAT_F_QAT_DH_GENERATE_KEY, ERR_R_INTERNAL_ERROR);
+			goto err;
+			}
+		}
+	else
+		pub_key=dh->pub_key;
+
+	if (generate_new_key)
+		{
+		if (dh->q)
+			{
+			do
+				{
+				if (!BN_rand_range(priv_key, dh->q))
+					{
+					QATerr(QAT_F_QAT_DH_GENERATE_KEY,
+						ERR_R_BN_LIB);
+					goto err;
+					}
+				}
+			while (BN_is_zero(priv_key) || BN_is_one(priv_key));
+			}
+		else
+			{
+			/* secret exponent length */
+			length = dh->length ? dh->length : BN_num_bits(dh->p)-1;
+			if (!BN_rand(priv_key, length, 0, 0))
+				{
+				QATerr(QAT_F_QAT_DH_GENERATE_KEY, ERR_R_BN_LIB);
+				goto err;
+				}
+			}
+		}
+
+	buflen = BN_num_bytes(dh->p);
+	pPV = (CpaFlatBuffer *)OPENSSL_malloc(sizeof(CpaFlatBuffer));
+	if (!pPV)
+		{
+		QATerr(QAT_F_QAT_DH_GENERATE_KEY, ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+	pPV->pData = qaeCryptoMemAlloc(buflen, __FILE__, __LINE__);
+	if (!pPV->pData)
+		{
+		QATerr(QAT_F_QAT_DH_GENERATE_KEY, ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+	pPV->dataLenInBytes = (Cpa32U) buflen;
+
+	if ((qat_BN_to_FB(&(opData->primeP),(BIGNUM *) dh->p) != 1) ||
+			(qat_BN_to_FB(&(opData->baseG),(BIGNUM *) dh->g) != 1) ||
+			(qat_BN_to_FB(&(opData->privateValueX), (BIGNUM *) priv_key) != 1))
+		{
+		QATerr(QAT_F_QAT_DH_GENERATE_KEY, ERR_R_INTERNAL_ERROR);
+		goto err;
+		}
+
+        if (!cb)      /* Synch mode */
+		{
+		initOpDone(&op_done);
+
+		do
+			{
+			if ((instanceHandle = get_next_inst()) == NULL)
+				{
+				QATerr(QAT_F_QAT_DH_GENERATE_KEY, ERR_R_INTERNAL_ERROR);
+				cleanupOpDone(&op_done);
+				goto err;
+				}
+
+			status = cpaCyDhKeyGenPhase1(instanceHandle,
+					qat_dhCallbackFn,
+					&op_done,
+					opData,
+					pPV);
+
+			if (status == CPA_STATUS_RETRY)
+				{
+				usleep(ulPollInterval +
+						(qatPerformOpRetries %
+						 QAT_RETRY_BACKOFF_MODULO_DIVISOR));
+				qatPerformOpRetries++;
+				}
+			}
+		while(status == CPA_STATUS_RETRY &&
+				((qatPerformOpRetries < iMsgRetry) ||
+				 (iMsgRetry == QAT_INFINITE_MAX_NUM_RETRIES)));
+
+		if (status != CPA_STATUS_SUCCESS)
+			{
+			QATerr(QAT_F_QAT_DH_GENERATE_KEY, ERR_R_INTERNAL_ERROR);
+			cleanupOpDone(&op_done);
+			goto err;
+			}
+
+		rc = waitForOpToComplete(&op_done);
+		cleanupOpDone(&op_done);
+		if (rc)
+			goto err;
+
+		dh->priv_key=priv_key;
+		/* Convert the flatbuffer result back to a BN */
+		BN_bin2bn(pPV->pData, pPV->dataLenInBytes, pub_key);
+		dh->pub_key=pub_key;
+
+		ok=1;
+		}
+#ifdef OPENSSL_QAT_ASYNCH
+        else   /* Asynch mode */
+		{
+		dh_op_done = (dh_generate_op_data_t *) OPENSSL_malloc(sizeof(dh_generate_op_data_t));
+		if (dh_op_done == NULL)
+			{
+			QATerr(QAT_F_QAT_DH_GENERATE_KEY, ERR_R_MALLOC_FAILURE);
+			goto err;
+			}
+
+		dh_op_done->priv_key = priv_key;
+		dh_op_done->pub_key = pub_key;
+		dh_op_done->dh = dh;
+		dh_op_done->opData = opData;
+		dh_op_done->cb_func = cb;
+		dh_op_done->cb_data = cb_data;
+
+		if ((instanceHandle = get_next_inst()) == NULL)
+			{
+			QATerr(QAT_F_QAT_DH_GENERATE_KEY, ERR_R_INTERNAL_ERROR);
+			OPENSSL_free(dh_op_done);
+			goto err;
+			}
+
+		status = cpaCyDhKeyGenPhase1(instanceHandle,
+				qat_dhGenerateAsynchCallbackFn,
+				dh_op_done,
+				opData,
+				pPV);
+
+		if (status != CPA_STATUS_SUCCESS)
+			{
+			WARN("[%s] --- Async cpaCyDhKeyGenPhase1 failed,\
+					status=%d.\n", __func__, status);
+			if (status == CPA_STATUS_RETRY)
+				{
+				QATerr(QAT_F_QAT_DH_GENERATE_KEY, ERR_R_RETRY);
+				}
+			OPENSSL_free(dh_op_done);
+			goto err;
+			}
+		return 1;
+		}
+#endif
+err:
+	if (pPV)
+		{
+		if (pPV->pData)
+			{
+			qaeCryptoMemFree(pPV->pData);
+			}
+		OPENSSL_free(pPV);
+		}
+
+	if (opData)
+		{
+		if (opData->primeP.pData) qaeCryptoMemFree(opData->primeP.pData);
+		if (opData->baseG.pData) qaeCryptoMemFree(opData->baseG.pData);
+		if (opData->privateValueX.pData) qaeCryptoMemFree(opData->privateValueX.pData);
+		OPENSSL_free (opData);
+		}
+
+	if ((pub_key != NULL)  && (dh->pub_key == NULL))  BN_free(pub_key);
+	if ((priv_key != NULL) && (dh->priv_key == NULL)) BN_free(priv_key);
+	return(ok);
+	}
+
+/******************************************************************************
+* function:
+*         qat_dh_generate_key_synch(DH * dh)
+*
+* description:
+*   Implement Diffie-Hellman phase 1 operations in synch mode.
+******************************************************************************/
+
+int qat_dh_generate_key_synch(DH *dh)
+	{
+	const DH_METHOD *default_dh_method = DH_OpenSSL();
+
+	if (!dh)
+		return 0;
+
+	/* If the op sizes are not in the range supported by QAT engine then
+	 * fall back to software */
+
+	if (!dh_range_check(BN_num_bits(dh->p)))
+		{
+		if (!default_dh_method)
+			return 0;
+		return default_dh_method->generate_key(dh);
+		}
+
+	return qat_dh_generate_key(dh, NULL, NULL);
+}
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*         qat_dh_generate_key_asynch(DH * dh,
+*                                    int (*cb)(unsigned char *res, size_t reslen,
+*                                    void *cb_data, int status),
+*                                    void *cb_data)
+*
+* description:
+*   Implement Diffie-Hellman phase 1 operations in asynch mode.
+******************************************************************************/
+
+int qat_dh_generate_key_asynch(DH *dh,
+				int (*cb)(unsigned char *res, size_t reslen,
+				void *cb_data, int status),
+				void *cb_data)
+	{
+	const DH_METHOD *default_dh_method = DH_OpenSSL();
+	const DH_METHOD * dh_tmp_meth;
+	int ret=0;
+
+	if (!dh || !cb)
+		return 0;
+
+	/* If the op sizes are not in the range supported by QAT engine then
+	 * fall back to software */
+
+	if (!dh_range_check(BN_num_bits(dh->p)))
+		{
+		if (!default_dh_method)
+			return 0;
+        dh_tmp_meth = dh->meth;
+        dh->meth = default_dh_method;
+        ret = default_dh_method->generate_key(dh);
+        dh->meth = dh_tmp_meth;
+        cb(NULL, 0, cb_data, ret);
+        return 1;
+		}
+
+	return qat_dh_generate_key(dh, cb, cb_data);
+	}
+#endif
+
+
+/******************************************************************************
+* function:
+*         qat_dh_compute_key(unsigned char *key, int *len,
+*                            const BIGNUM * pub_key, DH * dh,
+*                             int (*cb)(unsigned char *res, size_t reslen,
+*                             void *cb_data, int status), void *cb_data)
+*
+* description:
+*   Implement Diffie-Hellman phase 2 operations.
+******************************************************************************/
+int qat_dh_compute_key(unsigned char *key, int *len, const BIGNUM *pub_key, DH *dh,
+                       int (*cb)(unsigned char *res, size_t reslen,
+                       void *cb_data, int status), void *cb_data)
+	{
+	int ret= -1, rc = 1;
+	int check_result;
+	CpaInstanceHandle instanceHandle;
+	CpaCyDhPhase2SecretKeyGenOpData *opData=NULL;
+	CpaFlatBuffer *pSecretKey=NULL;
+	int qatPerformOpRetries = 0;
+	useconds_t ulPollInterval = getQatPollInterval();
+	int iMsgRetry = getQatMsgRetryCount();
+	CpaStatus status;
+	struct op_done op_done;
+	size_t buflen;
+#ifdef OPENSSL_QAT_ASYNCH
+	dh_compute_op_data_t *dh_op_done=NULL;
+#endif
+	int index=1;
+
+	DEBUG("%s been called \n", __func__);
+	CRYPTO_QAT_LOG("KX - %s\n", __func__);
+
+	opData = (CpaCyDhPhase2SecretKeyGenOpData *)
+			OPENSSL_malloc(sizeof(CpaCyDhPhase2SecretKeyGenOpData));
+	if (opData == NULL)
+		{
+		QATerr(QAT_F_QAT_DH_COMPUTE_KEY, ERR_R_MALLOC_FAILURE);
+		return ret;
+		}
+
+	opData->primeP.pData                = NULL;
+	opData->remoteOctetStringPV.pData   = NULL;
+	opData->privateValueX.pData         = NULL;
+
+	if (BN_num_bits(dh->p) > OPENSSL_DH_MAX_MODULUS_BITS)
+		{
+		QATerr(QAT_F_QAT_DH_COMPUTE_KEY, ERR_R_INTERNAL_ERROR);
+		goto err;
+		}
+
+	if (dh->priv_key == NULL)
+		{
+		QATerr(QAT_F_QAT_DH_COMPUTE_KEY, ERR_R_INTERNAL_ERROR);
+		goto err;
+		}
+
+	if (!DH_check_pub_key(dh, pub_key, &check_result) || check_result)
+		{
+		QATerr(QAT_F_QAT_DH_COMPUTE_KEY, ERR_R_INTERNAL_ERROR);
+		goto err;
+		}
+
+	buflen = BN_num_bytes(dh->p);
+	pSecretKey = (CpaFlatBuffer *)OPENSSL_malloc(sizeof(CpaFlatBuffer));
+	if (!pSecretKey)
+		{
+		QATerr(QAT_F_QAT_DH_COMPUTE_KEY, ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+	pSecretKey->pData = qaeCryptoMemAlloc(buflen, __FILE__, __LINE__);
+	if (!pSecretKey->pData)
+		{
+		QATerr(QAT_F_QAT_DH_COMPUTE_KEY, ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+	pSecretKey->dataLenInBytes = (Cpa32U) buflen;
+
+	if ((qat_BN_to_FB(&(opData->primeP), (BIGNUM *)dh->p) != 1) ||
+			(qat_BN_to_FB(&(opData->remoteOctetStringPV), (BIGNUM *)pub_key) != 1) ||
+			(qat_BN_to_FB(&(opData->privateValueX), (BIGNUM *)dh->priv_key) != 1))
+		{
+		QATerr(QAT_F_QAT_DH_COMPUTE_KEY, ERR_R_INTERNAL_ERROR);
+		goto err;
+		}
+
+	if (!cb)   /* Synch mode */
+		{
+		initOpDone(&op_done);
+
+		do
+			{
+			if ((instanceHandle = get_next_inst()) == NULL)
+				{
+				QATerr(QAT_F_QAT_DH_COMPUTE_KEY, ERR_R_INTERNAL_ERROR);
+				cleanupOpDone(&op_done);
+				goto err;
+				}
+
+			status = cpaCyDhKeyGenPhase2Secret(instanceHandle,
+					qat_dhCallbackFn,
+					&op_done,
+					opData,
+					pSecretKey);
+
+			if (status == CPA_STATUS_RETRY)
+				{
+				usleep(ulPollInterval +
+						(qatPerformOpRetries %
+						 QAT_RETRY_BACKOFF_MODULO_DIVISOR));
+				qatPerformOpRetries++;
+				}
+			}
+		while(status == CPA_STATUS_RETRY &&
+				((qatPerformOpRetries < iMsgRetry) ||
+				 (iMsgRetry == QAT_INFINITE_MAX_NUM_RETRIES)));
+
+		if (status != CPA_STATUS_SUCCESS)
+			{
+			QATerr(QAT_F_QAT_DH_COMPUTE_KEY, ERR_R_INTERNAL_ERROR);
+			cleanupOpDone(&op_done);
+			goto err;
+			}
+
+		rc = waitForOpToComplete(&op_done);
+		cleanupOpDone(&op_done);
+		if (rc)
+			goto err;
+
+		if(!pSecretKey->pData[0])
+			{
+			while(!pSecretKey->pData[index])
+				index++;
+			pSecretKey->dataLenInBytes = pSecretKey->dataLenInBytes - index;
+			memcpy(key, &pSecretKey->pData[index], pSecretKey->dataLenInBytes);
+			}
+		else
+			{
+			memcpy(key, pSecretKey->pData, pSecretKey->dataLenInBytes);
+			}
+			ret = pSecretKey->dataLenInBytes;
+		}
+#ifdef OPENSSL_QAT_ASYNCH
+        else  /* Asynch mode */
+		{
+		dh_op_done = (dh_compute_op_data_t *) OPENSSL_malloc(sizeof(dh_compute_op_data_t));
+		if (dh_op_done == NULL)
+			{
+			QATerr(QAT_F_QAT_DH_COMPUTE_KEY, ERR_R_MALLOC_FAILURE);
+			goto err;
+			}
+
+		dh_op_done->key = key;
+		dh_op_done->len = len;
+		dh_op_done->opData = opData;
+		dh_op_done->cb_func = cb;
+		dh_op_done->cb_data = cb_data;
+
+		if ((instanceHandle = get_next_inst()) == NULL)
+			{
+			QATerr(QAT_F_QAT_DH_COMPUTE_KEY, ERR_R_INTERNAL_ERROR);
+			OPENSSL_free(dh_op_done);
+			goto err;
+			}
+
+		status = cpaCyDhKeyGenPhase2Secret(instanceHandle,
+				qat_dhComputeAsynchCallbackFn,
+				dh_op_done,
+				opData,
+				pSecretKey);
+
+		if (status != CPA_STATUS_SUCCESS)
+			{
+			WARN("[%s] --- Asynch cpaCyDhKeyGenPhase2Secret failed, status=%d.\n", __func__, status);
+			if (status == CPA_STATUS_RETRY)
+				{
+				QATerr(QAT_F_QAT_DH_COMPUTE_KEY, ERR_R_RETRY);
+				}
+			OPENSSL_free(dh_op_done);
+			ret=0;
+			goto err;
+			}
+		return 1;
+		}
+#endif
+
+err:
+	if (pSecretKey)
+		{
+		if (pSecretKey->pData)
+			{
+			qaeCryptoMemFree(pSecretKey->pData);
+			}
+		OPENSSL_free(pSecretKey);
+		}
+
+	if (opData)
+		{
+		if (opData->primeP.pData) qaeCryptoMemFree(opData->primeP.pData);
+		if (opData->remoteOctetStringPV.pData) qaeCryptoMemFree(opData->remoteOctetStringPV.pData);
+		if (opData->privateValueX.pData) qaeCryptoMemFree(opData->privateValueX.pData);
+		OPENSSL_free (opData);
+		}
+
+	return(ret);
+	}
+
+/******************************************************************************
+* function:
+*         qat_dh_compute_key_synch(unsigned char *key,
+*                            const BIGNUM * pub_key, DH * dh)
+*
+* description:
+*   Implement Diffie-Hellman phase 2 operations in synch mode.
+******************************************************************************/
+int qat_dh_compute_key_synch(unsigned char *key, const BIGNUM *pub_key, DH *dh)
+	{
+	const DH_METHOD *default_dh_method = DH_OpenSSL();
+
+	if (!dh)
+		return -1;
+
+	/* If the op sizes are not in the range supported by QAT engine then
+	 * fall back to software */
+
+	if (!dh_range_check(BN_num_bits(dh->p)))
+		{
+		if (!default_dh_method)
+			return -1;
+		return default_dh_method->compute_key(key, pub_key, dh);
+		}
+
+	return qat_dh_compute_key(key, NULL, pub_key, dh, NULL, NULL);
+	}
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*         qat_dh_compute_key_asynch(unsigned char *key, int *len,
+*                            const BIGNUM * pub_key, DH * dh,
+*                            int (*cb)(unsigned char *res, size_t reslen,
+*                            void *cb_data, int status), void *cb_data)
+*
+* description:
+*   Implement Diffie-Hellman phase 2 operations in asynch mode.
+******************************************************************************/
+int qat_dh_compute_key_asynch(unsigned char *key, int *len, const BIGNUM *pub_key, DH *dh,
+                       int (*cb)(unsigned char *res, size_t reslen,
+                       void *cb_data, int status), void *cb_data)
+	{
+	const DH_METHOD *default_dh_method = DH_OpenSSL();
+	const DH_METHOD *dh_tmp_meth;
+	int ret=0;
+
+	if (!dh || !cb)
+		return -1;
+
+	/* If the op sizes are not in the range supported by QAT engine then
+	 * fall back to software */
+
+	if (!dh_range_check(BN_num_bits(dh->p)))
+		{
+		if (!default_dh_method)
+			return -1;
+        dh_tmp_meth = dh->meth;
+        dh->meth = default_dh_method;
+        ret = default_dh_method->compute_key(key, pub_key, dh);
+        dh->meth = dh_tmp_meth;
+        cb(key, ret, cb_data, ret);
+        return 1;
+		}
+
+	return qat_dh_compute_key(key, len, pub_key, dh, cb, cb_data);
+	}
+#endif
+
+/******************************************************************************
+* function:
+*         qat_mod_exp_dh(const DH * dh, BIGNUM * r, const BIGNUM * a,
+*                        const BIGNUM * p, const BIGNUM * m, BN_CTX * ctx,
+*                        BN_MONT_CTX * m_ctx)
+*
+* @param dh    [IN] - Pointer to a OpenSSL DH struct.
+* @param r     [IN] - Result bignum of mod_exp
+* @param a     [IN] - Base used for mod_exp
+* @param p     [IN] - Exponent used for mod_exp
+* @param m     [IN] - Modulus used for mod_exp
+* @param ctx   [IN] - EVP context.
+* @param m_ctx [IN] - EVP context for Montgomery multiplication.
+*
+* description:
+*   Overridden modular exponentiation function used in DH.
+*
+******************************************************************************/
+int qat_mod_exp_dh(const DH * dh, BIGNUM * r, const BIGNUM * a,
+			const BIGNUM * p, const BIGNUM * m, BN_CTX * ctx,
+			BN_MONT_CTX * m_ctx)
+	{
+	DEBUG("%s been called \n", __func__);
+	CRYPTO_QAT_LOG("KX - %s\n", __func__);
+	return qat_mod_exp(r, a, p, m);
+	}
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_dh.h ./engines/qat_engine/qat_dh.h
--- ../openssl-async/engines/qat_engine/qat_dh.h	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_dh.h	2015-03-05 12:43:44.243964000 +0000
@@ -0,0 +1,78 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+  */
+
+/*****************************************************************************
+ * @file qat_dh.h
+ *
+ * This file provides an interface to Diffie Hellman operations
+ *
+ *****************************************************************************/
+
+#ifndef QAT_DH_H
+#define QAT_DH_H
+
+#include <openssl/dh.h>
+
+/* Qat engine DH methods declaration */
+int qat_mod_exp_dh(const DH *dh, BIGNUM *r, const BIGNUM *a,
+                   const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,
+                   BN_MONT_CTX *m_ctx);
+int qat_dh_generate_key(DH *dh,
+                        int (*cb)(unsigned char *res, size_t reslen,
+                        void *cb_data, int status),
+                        void *cb_data);
+
+int qat_dh_compute_key(unsigned char *key, int *len, const BIGNUM *pub_key, DH *dh,
+                       int (*cb)(unsigned char *res, size_t reslen,
+                       void *cb_data, int status), void *cb_data);
+
+
+DH_METHOD *get_DH_methods(void);
+
+#endif //QAT_DH_H
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_digests.c ./engines/qat_engine/qat_digests.c
--- ../openssl-async/engines/qat_engine/qat_digests.c	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_digests.c	2015-03-05 12:43:44.245958000 +0000
@@ -0,0 +1,1568 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qat_digests.c
+ *
+ * This file provides an implementaion of the digest operations for an
+ * OpenSSL engine
+ *
+ *****************************************************************************/
+
+#include <openssl/ossl_typ.h>
+#include <openssl/evp.h>
+#include <openssl/sha.h>
+#include <openssl/md5.h>
+
+#include <string.h>
+#ifdef USE_QAT_MEM
+#include "qae_mem_utils.h"
+#endif
+#ifdef USE_QAE_MEM
+#include "qat_mem_drv_inf.h"
+#endif
+#include "qat_utils.h"
+#include "e_qat.h"
+#include "e_qat_err.h"
+
+#include "cpa.h"
+#include "cpa_types.h"
+#include "cpa_cy_sym.h"
+#include "qat_digests.h"
+
+/* Qat digest function register */
+static int qat_digest_nids[] = {
+    NID_sha1,
+    NID_md5,
+    NID_sha256,
+    NID_sha512,
+};
+
+#ifndef QAT_MAX_DIGEST_CHAIN_LENGTH
+#define QAT_MAX_DIGEST_CHAIN_LENGTH 1000000000
+#endif
+
+#ifdef OPENSSL_ENABLE_QAT_DIGEST_SYNCH
+#ifdef OPENSSL_DISABLE_QAT_DIGEST_SYNCH
+#undef OPENSSL_DISABLE_QAT_DIGEST_SYNCH
+#endif
+#endif
+
+#ifdef OPENSSL_ENABLE_QAT_DIGEST_ASYNCH
+#ifdef OPENSSL_DISABLE_QAT_DIGEST_ASYNCH
+#undef OPENSSL_DISABLE_QAT_DIGEST_ASYNCH
+#endif
+#endif
+
+
+#ifndef OPENSSL_QAT_ASYNCH
+#define OPENSSL_DISABLE_QAT_DIGEST_ASYNCH
+#endif
+
+/* How long to wait for inflight messages before cleanup */
+#define QAT_CLEANUP_RETRY_COUNT 10
+#define QAT_CLEANUP_WAIT_TIME_NS 1000000
+
+#define CTX_NOT_CLEAN       255
+
+static int digest_init_synch(EVP_MD_CTX * ctx);
+static int digest_update(EVP_MD_CTX * ctx, const void *data, size_t count);
+static int digest_final_synch(EVP_MD_CTX * ctx, unsigned char *md);
+
+#ifdef OPENSSL_QAT_ASYNCH
+static int digest_init_asynch(EVP_MD_CTX *ctx,
+                   int (*cb)(unsigned char *md, unsigned int size,
+                              void *cb_data, int status));
+static int digest_update_asynch(EVP_MD_CTX * ctx, const void *data, size_t count,
+                                void *cb_data);
+static int digest_final_asynch(EVP_MD_CTX *ctx, unsigned char *md, void *cb_data);
+static int digest_cleanup_asynch(EVP_MD_CTX * ctx);
+#endif
+
+static int qat_digest_copy(EVP_MD_CTX * ctx_out, const EVP_MD_CTX *ctx_in);
+static int digest_cleanup(EVP_MD_CTX * ctx);
+
+/* Qat digest SHA1 function structure declaration */
+static const EVP_MD qat_sha1 = {
+    NID_sha1,                   /* nid */
+    NID_sha1WithRSAEncryption,
+    SHA_DIGEST_LENGTH,          /* output size */
+    EVP_MD_FLAG_PKEY_METHOD_SIGNATURE| /* flags */
+    EVP_MD_FLAG_DIGALGID_ABSENT,
+#ifdef OPENSSL_QAT_ASYNCH
+    { digest_init_synch },
+    { digest_update },
+    { digest_final_synch },
+#else
+    digest_init_synch,
+    digest_update,
+    digest_final_synch,
+#endif  
+    qat_digest_copy,
+    digest_cleanup,
+#ifdef OPENSSL_QAT_ASYNCH
+    { NULL },                       /* qat_digest_sign */
+    { NULL },                       /* qat_digest_verify */
+#else
+    NULL,                       /* qat_digest_sign */
+    NULL,                       /* qat_digest_verify */
+#endif
+    {0, 0, 0, 0, 0}
+    ,                           /* EVP pkey */
+    SHA_LBLOCK,                 /* block size */
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL                        /* qat_digest_ctrl */
+};
+
+#ifdef OPENSSL_QAT_ASYNCH
+EVP_MD qat_sha1_asynch = {
+    NID_sha1,                   /* nid */
+    NID_sha1WithRSAEncryption,
+    SHA_DIGEST_LENGTH,          /* output size */
+    EVP_MD_FLAG_PKEY_METHOD_SIGNATURE|
+    EVP_MD_FLAG_DIGALGID_ABSENT|
+    EVP_MD_FLAG_ASYNCH,     /* flags */
+    { .asynch = digest_init_asynch },
+    { .asynch = digest_update_asynch },
+    { .asynch = digest_final_asynch },
+    qat_digest_copy,
+    digest_cleanup_asynch,
+    { NULL },                       /* qat_digest_sign */
+    { NULL },                       /* qat_digest_verify */
+    {0, 0, 0, 0, 0}
+    ,                           /* EVP pkey */
+    SHA_LBLOCK,                 /* block size */
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL                        /* qat_digest_ctrl */
+};
+#endif
+
+/* Qat digest SHA256 function structure declaration */
+static const EVP_MD qat_sha256 = {
+    NID_sha256,                   /* nid */
+    NID_sha256WithRSAEncryption,
+    SHA256_DIGEST_LENGTH,          /* output size */
+    EVP_MD_FLAG_PKEY_METHOD_SIGNATURE| /* flags */
+    EVP_MD_FLAG_DIGALGID_ABSENT,
+#ifdef OPENSSL_QAT_ASYNCH
+    { digest_init_synch },
+    { digest_update },
+    { digest_final_synch },
+#else
+    digest_init_synch,
+    digest_update,
+    digest_final_synch,
+#endif
+    qat_digest_copy,
+    digest_cleanup,
+#ifdef OPENSSL_QAT_ASYNCH
+    { NULL },                       /* qat_digest_sign */
+    { NULL },                       /* qat_digest_verify */
+#else
+    NULL,                       /* qat_digest_sign */
+    NULL,                       /* qat_digest_verify */
+#endif
+    {0, 0, 0, 0, 0}
+    ,                           /* EVP pkey */
+    SHA256_BLOCK_SIZE,                 /* block size */
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL                        /* qat_digest_ctrl */
+};
+
+#ifdef OPENSSL_QAT_ASYNCH
+EVP_MD qat_sha256_asynch = {
+    NID_sha256,                   /* nid */
+    NID_sha256WithRSAEncryption,
+    SHA256_DIGEST_LENGTH,          /* output size */
+    EVP_MD_FLAG_PKEY_METHOD_SIGNATURE|
+    EVP_MD_FLAG_DIGALGID_ABSENT|
+    EVP_MD_FLAG_ASYNCH,     /* flags */
+    { .asynch = digest_init_asynch },
+    { .asynch = digest_update_asynch },
+    { .asynch = digest_final_asynch },
+    qat_digest_copy,
+    digest_cleanup_asynch,
+    { NULL },                       /* qat_digest_sign */
+    { NULL },                       /* qat_digest_verify */
+    {0, 0, 0, 0, 0}
+    ,                           /* EVP pkey */
+    SHA256_BLOCK_SIZE,                 /* block size */
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL                        /* qat_digest_ctrl */
+};
+#endif
+
+/* Qat digest SHA384 function structure declaration */
+static const EVP_MD qat_sha384 = {
+    NID_sha384,                   /* nid */
+    NID_sha384WithRSAEncryption,
+    SHA384_DIGEST_LENGTH,          /* output size */
+    EVP_MD_FLAG_PKEY_METHOD_SIGNATURE|
+    EVP_MD_FLAG_DIGALGID_ABSENT,   /* flags defined above */
+#ifdef OPENSSL_QAT_ASYNCH
+    { digest_init_synch },
+    { digest_update },
+    { digest_final_synch },
+#else
+    digest_init_synch,
+    digest_update,
+    digest_final_synch,
+#endif
+    qat_digest_copy,
+    digest_cleanup,
+#ifdef OPENSSL_QAT_ASYNCH
+    { NULL },                       /* qat_digest_sign */
+    { NULL },                       /* qat_digest_verify */
+#else
+    NULL,                       /* qat_digest_sign */
+    NULL,                       /* qat_digest_verify */
+#endif
+    {0, 0, 0, 0, 0}
+    ,                           /* EVP pkey */
+    SHA512_BLOCK_SIZE,                 /* block size: same of sha512 */
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL                        /* qat_digest_ctrl */
+};
+
+#ifdef OPENSSL_QAT_ASYNCH
+EVP_MD qat_sha384_asynch = {
+    NID_sha384,                   /* nid */
+    NID_sha384WithRSAEncryption,
+    SHA384_DIGEST_LENGTH,          /* output size */
+    EVP_MD_FLAG_PKEY_METHOD_SIGNATURE|
+    EVP_MD_FLAG_DIGALGID_ABSENT|
+    EVP_MD_FLAG_ASYNCH,          /* flags defined above */
+    { .asynch = digest_init_asynch },
+    { .asynch = digest_update_asynch },
+    { .asynch = digest_final_asynch },
+    qat_digest_copy,
+    digest_cleanup_asynch,
+    { NULL },                       /* qat_digest_sign */
+    { NULL },                       /* qat_digest_verify */
+    {0, 0, 0, 0, 0}
+    ,                           /* EVP pkey */
+    SHA512_BLOCK_SIZE,                 /* block size: same of sha512 */
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL                        /* qat_digest_ctrl */
+};
+#endif
+
+/* Qat digest SHA512 function structure declaration */
+static const EVP_MD qat_sha512 = {
+    NID_sha512,                   /* nid */
+    NID_sha512WithRSAEncryption,
+    SHA512_DIGEST_LENGTH,          /* output size */
+    EVP_MD_FLAG_PKEY_METHOD_SIGNATURE|
+    EVP_MD_FLAG_DIGALGID_ABSENT,   /* flags defined above */
+#ifdef OPENSSL_QAT_ASYNCH
+    { digest_init_synch },
+    { digest_update },
+    { digest_final_synch },
+#else
+    digest_init_synch,
+    digest_update,
+    digest_final_synch,
+#endif
+    qat_digest_copy,
+    digest_cleanup,
+#ifdef OPENSSL_QAT_ASYNCH
+    { NULL },                       /* qat_digest_sign */
+    { NULL },                       /* qat_digest_verify */
+#else
+    NULL,                       /* qat_digest_sign */
+    NULL,                       /* qat_digest_verify */
+#endif
+    {0, 0, 0, 0, 0}
+    ,                           /* EVP pkey */
+    SHA512_BLOCK_SIZE,                 /* block size */
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL                        /* qat_digest_ctrl */
+};
+
+#ifdef OPENSSL_QAT_ASYNCH
+EVP_MD qat_sha512_asynch = {
+    NID_sha512,                   /* nid */
+    NID_sha512WithRSAEncryption,
+    SHA512_DIGEST_LENGTH,          /* output size */
+    EVP_MD_FLAG_PKEY_METHOD_SIGNATURE|
+    EVP_MD_FLAG_DIGALGID_ABSENT|
+    EVP_MD_FLAG_ASYNCH,          /* flags defined above */
+    { .asynch = digest_init_asynch },
+    { .asynch = digest_update_asynch },
+    { .asynch = digest_final_asynch },
+    qat_digest_copy,
+    digest_cleanup_asynch,
+    { NULL },                       /* qat_digest_sign */
+    { NULL },                       /* qat_digest_verify */
+    {0, 0, 0, 0, 0}
+    ,                           /* EVP pkey */
+    SHA512_BLOCK_SIZE,                 /* block size */
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL                        /* qat_digest_ctrl */
+};
+#endif
+/* Qat digest MD5 function structure declaration */
+static const EVP_MD qat_md5 = {
+    NID_md5,                    /* nid */
+    NID_md5WithRSAEncryption,
+    MD5_DIGEST_LENGTH,          /* output size */
+    0,                          /* flags defined above */
+#ifdef OPENSSL_QAT_ASYNCH
+    { digest_init_synch },
+    { digest_update },
+    { digest_final_synch },
+#else
+    digest_init_synch,
+    digest_update,
+    digest_final_synch,
+#endif
+    qat_digest_copy,
+    digest_cleanup,
+#ifdef OPENSSL_QAT_ASYNCH
+    { NULL },                       /* qat_digest_sign */
+    { NULL },                       /* qat_digest_verify */
+#else
+    NULL,                       /* qat_digest_sign */
+    NULL,                       /* qat_digest_verify */
+#endif
+    {0, 0, 0, 0, 0},            /* EVP pkey */
+    MD5_LBLOCK,                 /* block size */
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL                        /* qat_digest_ctrl */
+};
+
+#ifdef OPENSSL_QAT_ASYNCH
+EVP_MD qat_md5_asynch = {
+    NID_md5,                   /* nid */
+    NID_md5WithRSAEncryption,
+    MD5_DIGEST_LENGTH,          /* output size */
+    0 | EVP_MD_FLAG_ASYNCH,     /* flags defined above */
+    { .asynch = digest_init_asynch },
+    { .asynch = digest_update_asynch },
+    { .asynch = digest_final_asynch },
+    qat_digest_copy,
+    digest_cleanup_asynch,
+    { NULL },                       /* qat_digest_sign */
+    { NULL },                       /* qat_digest_verify */
+    {0, 0, 0, 0, 0},            /* EVP pkey */
+    MD5_LBLOCK,                 /* block size */
+    sizeof(qat_ctx),            /* ctx_size */
+    NULL                        /* qat_digest_ctrl */
+};
+#endif
+
+static
+void buffer_list_cleanup(qat_buffer** buff, int count)
+{
+    qat_buffer* buff_cur = *buff;
+    qat_buffer* buff_next = NULL;
+    int j = 0;
+
+    for(j=0; j<count; j++)
+    {
+    if(NULL != buff_cur->data)
+            qaeCryptoMemFree (buff_cur->data);
+        buff_next = buff_cur->next;
+        OPENSSL_free (buff_cur);
+        buff_cur = buff_next;
+    }
+    *buff = NULL;
+}
+
+/******************************************************************************
+* function:
+*         qat_digest_context_copy(EVP_MD_CTX *ctx_out,
+*                                 const EVP_MD_CTX *ctx_in)
+*
+* @param ctx_out [OUT] - pointer to new ctx
+* @param ctx_in  [IN]  - pointer to existing context
+*
+* @retval 0      function succeeded
+* @retval 1      function failed
+*
+* description:
+*    This function copies a context.  All buffers are also
+*    copied.
+******************************************************************************/
+static int qat_digest_context_copy (EVP_MD_CTX *ctx_out,
+                                    const EVP_MD_CTX *ctx_in)
+{
+    qat_ctx *qat_out = NULL;
+    qat_ctx *qat_in = NULL;
+    qat_buffer *buff_in = NULL;
+    qat_buffer *buff_out = NULL;
+    int i = 0;
+
+    DEBUG("[%s] Function Started \n", __func__);
+    if ((!ctx_in) || (!ctx_out))
+    {
+        WARN("[%s] --- ctx_in or ctx_out is NULL.\n", __func__);
+        return 0;
+    }
+
+    DEBUG("[%s] %p->%p\n", __func__, ctx_in->md_data, ctx_out->md_data);
+
+    qat_out = (qat_ctx *) (ctx_out->md_data);
+    qat_in = (qat_ctx *) (ctx_in->md_data);
+
+
+    /*  If source or dest context has not yet been initialised, there is nothing
+     *  we can do except return success.
+     */
+    if (!qat_in || !qat_out)
+    {
+        return 1;
+    }
+
+    buff_in = qat_in->first;
+    qat_out->first = NULL;
+
+    for (i = 0; i < qat_in->buff_count; i++)
+    {
+    DEBUG("[%s] --- buff_in %p for iteration %d\n", __func__, buff_in, i);
+        buff_out = OPENSSL_malloc (sizeof (qat_buffer));
+
+        if(NULL == buff_out)
+        {
+           WARN("[%s] --- buff_out is null for iteration %d\n", __func__, i);
+           goto end;
+        }
+
+        buff_out->data = copyAllocPinnedMemory ((void*) buff_in->data, buff_in->len, __FILE__, __LINE__);
+        if(NULL == buff_out->data)
+        {
+           /* Free resources for this iteration */
+           OPENSSL_free (buff_out);
+           WARN("[%s] --- buff_out data is null for iteration %d\n", __func__, i);
+           goto end;
+        }
+
+        buff_out->len = buff_in->len;
+        buff_out->next = NULL;
+
+        if (qat_out->first)
+        {
+            qat_out->last->next = buff_out;
+            qat_out->last = buff_out;
+        }
+        else
+        {
+            qat_out->first = buff_out;
+            qat_out->last = buff_out;
+        }
+
+        buff_in = buff_in->next;
+    }
+
+    qat_out->buff_count = qat_in->buff_count;
+    qat_out->buff_total_bytes = qat_in->buff_total_bytes;
+    qat_out->init = qat_in->init;
+    qat_out->failed_submission = qat_in->failed_submission;
+
+    DEBUG("[%s] --- qat_out->buff_count = %d\n", __func__, qat_out->buff_count);
+    DEBUG("[%s] --- qat_out->buff_total_bytes = %d\n", __func__, qat_out->buff_total_bytes);
+    DEBUG("[%s] Function Finished \n", __func__);
+
+    return 1;
+
+end:
+    /* Free allocated memory in case of error */
+    buffer_list_cleanup(&(qat_out->first), i);
+    return 0;
+
+}
+
+
+/******************************************************************************
+* function:
+*         qat_digestAsynchCallbackFn(void *callbackTag, CpaStatus status,
+*                         const CpaCySymOp operationType, void *pOpData,
+*                         CpaBufferList * pDstBuffer, CpaBoolean verifyResult)
+*
+* @param ctx_out [OUT] - pointer to new ctx
+* @param ctx_in  [IN]  - pointer to existing context
+*
+* @retval none
+*
+* description:
+*    In asynchronous mode this is callback we register for the session. This
+*    function completes the digest processing before calling the users callback
+*
+******************************************************************************/
+static void qat_digestAsynchCallbackFn(void *callbackTag, CpaStatus status,
+                           const CpaCySymOp operationType, void *pOpData,
+                           CpaBufferList * pDstBuffer, CpaBoolean verifyResult)
+{
+    int sts = 0;
+    CpaCySymSessionCtx pSessionCtx = NULL;
+    struct op_done_asynch *opDone = callbackTag;
+    int cb_status = status == CPA_STATUS_SUCCESS ? 1 : 0;
+    CpaCySymOpData *opData = pOpData;
+
+    DEBUG("[%s] Function Started \n", __func__);
+    /* Check Params */
+    if(NULL == opDone || NULL == pDstBuffer)
+    {
+        WARN("[%s] --- Invalid input parameter to callback - op_done - pDstBuff.\n", __func__);
+    QATerr(QAT_F_QAT_DIGESTASYNCHCALLBACKFN, QAT_R_INVALID_INPUT_PARAMETER);
+        return;
+    }
+    if(NULL == opData)
+    {
+        WARN("[%s] --- Invalid input parameter to callback - opData.\n", __func__);
+        QATerr(QAT_F_QAT_DIGESTASYNCHCALLBACKFN, QAT_R_INVALID_INPUT_PARAMETER);
+        return;
+    }
+
+    /* Update result */
+    memcpy(opDone->orig_out, opData->pDigestResult, EVP_MD_CTX_size(opDone->md_ctx));
+
+    /* Update Reception stats */
+    opDone->qat_ctx.single->noResponses++;
+
+    pSessionCtx = opDone->qat_ctx.single->ctx;
+
+    if (NULL == pSessionCtx) {
+        WARN("[%s] -- pSessionCtx is NULL\n", __func__);
+    }
+
+    sts = cpaCySymRemoveSession(opDone->qat_ctx.single->instanceHandle,
+                               pSessionCtx);
+    if(CPA_STATUS_SUCCESS != sts)
+    {
+        WARN("[%s] --- cpaCySymRemoveSession failed, sts = %d.\n",
+             __func__, sts);
+        /* Carry on trying to clean up */
+    }
+
+    /* Free Memory */
+    qaeCryptoMemFree (pSessionCtx);
+
+    if(NULL != pDstBuffer->pPrivateMetaData)
+       qaeCryptoMemFree(pDstBuffer->pPrivateMetaData);
+
+    OPENSSL_free(pDstBuffer->pBuffers);
+
+    buffer_list_cleanup(&(opDone->qat_ctx.single->first),
+         opDone->qat_ctx.single->buff_count);
+    opDone->qat_ctx.single->first = NULL;
+    opDone->qat_ctx.single->last = NULL;
+    opDone->qat_ctx.single->buff_count = 0;
+    opDone->qat_ctx.single->buff_total_bytes = 0;
+
+    /* Call user callback */
+    opDone->qat_ctx.single->md_cb(opDone->orig_out,
+                                     EVP_MD_CTX_size(opDone->md_ctx),
+                                     opDone->cb_data, cb_status);
+
+    OPENSSL_free(pDstBuffer);
+
+    qaeCryptoMemFree(opData->pDigestResult);
+    OPENSSL_free(opData);
+
+    OPENSSL_free(opDone);
+
+    DEBUG("[%s] Function Finished \n", __func__);
+
+}
+
+/******************************************************************************
+* function:
+*   digest_init(EVP_MD_CTX *ctx,
+*               int (*cb)(unsigned char *md, unsigned int size,
+*                       void *cb_data, int status))
+*
+*
+* @param ctx [IN] - pointer to digest ctx
+* @param cb [IN]  - function pointer to callback function for async requests
+*
+* description:
+*    This function is rewrite of sha/MD5_init() function in OpenSSL
+*    It is the first function called in SHA/MD5 digest routine sequence
+*    Function will return 1 if successful
+******************************************************************************/
+static int
+digest_init(EVP_MD_CTX * ctx,
+            int (*cb)(unsigned char *md, unsigned int size,
+                       void *cb_data, int status))
+{
+    qat_ctx *qat_context = NULL;
+
+    DEBUG("[%s] Function Started \n", __func__);
+    /* Check params */
+    if(NULL == ctx)
+    {
+       WARN("[%s] --- ctx is NULL\n", __func__);
+       return 0;
+    }
+
+    /*  It does sometimes happen that we are asked to initialise a
+     *  context before md_data has been allocated.  We politely refuse
+     *  since we have nowhere to store our data but return success anyway.
+     *  It will be initialised later on.
+     */
+    if (NULL == ctx->md_data)
+    {
+        DEBUG("[%s] --- qat_context not allocated.\n", __func__);
+        return 1;
+    }
+
+    qat_context = (qat_ctx *) ctx->md_data;
+
+    /* If this ctx has called Init before and been updated
+     * with out a clean or final call we must free up the buffers
+     * That were created in the update
+     */
+    if ((CTX_NOT_CLEAN == qat_context->init) && !qat_context->copiedCtx)
+    {
+        DEBUG("[%s] ---- Init with unclean ctx\n", __func__);
+        DEBUG("%s: qat_context->buff_count = %d, ctx = %p\n", __func__, qat_context->buff_count, qat_context);
+        buffer_list_cleanup(&(qat_context->first), qat_context->buff_count);
+    }
+
+    memset(qat_context ,0x00, sizeof(qat_ctx));
+
+    qat_context->init = 1;
+    qat_context->md_cb = cb;
+
+    DEBUG("%s: qat_context %p\n", __func__, qat_context);
+    DEBUG("[%s] Function Finished \n", __func__);
+
+    return 1;
+}
+
+/******************************************************************************
+* function:
+*   digest_init_sync(EVP_MD_CTX *ctx)
+*
+* @param ctx [IN] - pointer to digest ctx
+*
+* description:
+*    Digest init - sync case
+******************************************************************************/
+static int
+digest_init_synch(EVP_MD_CTX * ctx)
+{
+    return digest_init(ctx, NULL);
+}
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*   digest_init_asynch(EVP_MD_CTX *ctx,
+*               int (*cb)(unsigned char *md, unsigned int size,
+*
+*
+* @param ctx [IN] - pointer to digest ctx
+* @param cb [IN]  - function pointer to callback function
+*
+* description:
+*    Digest init - asynch case
+******************************************************************************/
+static int
+digest_init_asynch(EVP_MD_CTX *ctx,
+                   int (*cb)(unsigned char *md, unsigned int size,
+                              void *cb_data, int status))
+{
+    if(NULL == cb)
+    {
+       WARN("[%s] --- cb NULL.\n", __func__);
+       return 0;
+    }
+    else
+    {
+       return digest_init(ctx, cb);
+    }
+}
+#endif
+
+/******************************************************************************
+* function:
+*         digest_update(EVP_MD_CTX *ctx,
+*                         const void *data,
+*                         size_t count)
+*
+* @param ctx   [IN] - pointer to MD ctx
+* @param data  [IN] - pointer to chunks of inputdata
+* @param count [IN] - message Length To Hash In Bytes
+*
+* description:
+*   This function is rewrite of sha/MD5_update() in OpenSSL,
+*   It will be called repeatedly with chunks of target message to be
+*   hashed before it pass to cpaCy function.
+*   The second function called in SHA/MD5 digest routine sequence
+*   and return 1 if successful
+******************************************************************************/
+static int digest_update(EVP_MD_CTX * ctx, const void *data, size_t count)
+{
+    qat_ctx *qat_context = NULL;
+    qat_buffer *buff;
+
+    DEBUG("[%s] Function Started \n", __func__);
+    if (0 == count)
+        return 1;
+
+    if (isZeroCopy())
+    {
+        WARN("[%s] --- digest acceleration does not support zero copy.\n", __func__);
+    }
+
+    if ((!ctx) || (!data))
+    {
+        WARN("[%s] --- ctx or data is NULL.\n", __func__);
+        return 0;
+    }
+
+    if (NULL == ctx->md_data)
+    {
+        WARN("[%s] --- qat_context not allocated.\n", __func__);
+        return 0;
+    }
+
+    qat_context = (qat_ctx *) (ctx->md_data);
+
+    if (0 == qat_context->init)
+    {
+        WARN("[%s] --- update called before init\n", __func__);
+        return 0;
+    }
+
+    if (qat_context->buff_total_bytes + count > QAT_MAX_DIGEST_CHAIN_LENGTH)
+    {
+        WARN("[%s] --- Maximum digest chain length exceeded.\n", __func__);
+        return 0;
+    }
+
+    buff = OPENSSL_malloc (sizeof (qat_buffer));
+
+    if (!buff)
+    {
+        WARN("[%s] --- alloc failure.\n", __func__);
+        return 0;
+    }
+
+    buff->data = copyAllocPinnedMemory ((void*) data, count, __FILE__, __LINE__);
+    if (!buff->data)
+    {
+        WARN("[%s] --- alloc failure.\n", __func__);
+        OPENSSL_free (buff);
+    buff = NULL;
+        return 0;
+    }
+    buff->len = count;
+    buff->next = NULL;
+
+    if (NULL == qat_context->first )
+    {
+        qat_context->first = buff;
+        qat_context->last = buff;
+    }
+    else
+    {
+        qat_context->last->next = buff;
+        qat_context->last = buff;
+    }
+
+    DEBUG("%s: After update: qat_context->first = %p\n", __func__, qat_context->first);
+    DEBUG("%s: After update: qat_context->last = %p\n", __func__, qat_context->last);
+    qat_context->buff_count++;
+    qat_context->buff_total_bytes += count;
+    qat_context->init = CTX_NOT_CLEAN;
+
+    DEBUG("%s: added buffer len %d to chain, count now %d len %d, ctx %p\n",
+          __func__, (int) count, qat_context->buff_count,
+          (int) qat_context->buff_total_bytes, qat_context);
+
+    DEBUG("[%s] Function Finished \n", __func__);
+
+    return 1;
+}
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*         digest_update_asynch(EVP_MD_CTX *ctx, const void *data, size_t count,
+*                         void *cb_data)
+*
+* @param ctx   [IN] - pointer to MD ctx
+* @param data  [IN] - pointer to chunks of inputdata
+* @param count [IN] - message Length To Hash In Bytes
+* @param cb_data [IN] - users callback data
+*
+* description:
+*   This function is rewrite of sha/MD5_update() in OpenSSL,
+*   It will be called repeatedly with chunks of target message to be
+*   processed. It will also call the user's callback function.
+*   The second function called in SHA/MD5 digest routine sequence
+*   and return 1 if successful
+******************************************************************************/
+static int
+digest_update_asynch(EVP_MD_CTX * ctx, const void *data, size_t count,
+                     void *cb_data)
+{
+    qat_ctx *qat_context = NULL;
+    int status = 0;
+
+    DEBUG("[%s] Function Started \n", __func__);
+    if ((!ctx) || (!ctx->md_data))
+    {
+        WARN("[%s] --- ctx or md_data is NULL.\n", __func__);
+        return 0;
+    }
+
+    status = digest_update(ctx, data, count);
+
+    qat_context = (qat_ctx*)(ctx->md_data);
+    if (!status)
+        qat_context->failed_submission=1;
+
+    if(!qat_context->md_cb)
+    {
+        WARN("[%s] --- md_cb is NULL.\n", __func__);
+        return 0;
+    }
+
+    qat_context->md_cb(NULL, 0, cb_data, status);
+    DEBUG("[%s] Function Finished \n", __func__);
+    return 1;
+
+}
+#endif
+
+/******************************************************************************
+* function:
+*   digest_final(EVP_MD_CTX *ctx, unsigned char *md, void *cb_data, unsigned int enableAsync)
+*
+* @param ctx [IN]  - pointer to MD ctx
+* @param md  [OUT] - digest message output
+* @param cb_data [IN] - users callback data
+* @param mode [IN}  - Sync or Async mode.
+*
+* description:
+*   This function is the rewrite of OpenSSL sha/MD5_final() function.
+*   It places the digested message in md in case of Sync mode.
+*     In Async mode, the digest message is placed in md through associated callback.
+*   The third function called in SHA/MD5 digest routine sequence
+*   and return 1 if successful
+******************************************************************************/
+static int
+digest_final(EVP_MD_CTX * ctx, unsigned char *md, void *cb_data, unsigned int enableAsync)
+{
+    CpaCySymSessionCtx pSessionCtx = NULL;
+    CpaCySymOpData *OpData = NULL;
+    CpaBufferList *srcBufferList = NULL;
+    CpaFlatBuffer *srcFlatBuffer = NULL;
+    CpaStatus sts = 0;
+    Cpa32U metaSize = 0;
+    void *srcPrivateMetaData = NULL;
+    struct op_done opDoneSync;
+    struct op_done_asynch *opDoneAsync = NULL;
+    qat_ctx *qat_context = NULL;
+    qat_buffer *buff = NULL;
+    int i = 0;
+    int success = 1;
+    int rc = 1;
+
+    CpaCySymSessionSetupData sessionSetupData = { 0 };
+    Cpa32U sessionCtxSize = 0;
+    CpaInstanceHandle instanceHandle;
+
+    DEBUG("[%s] Function Started \n", __func__);
+    CRYPTO_QAT_LOG("DIGEST - %s\n", __func__);
+
+    if ((!ctx) || (!md))
+    {
+        WARN("[%s] --- ctx or md is NULL.\n", __func__);
+        return 0;
+    }
+
+    if (!ctx->md_data )
+    {
+        WARN("[%s] --- qat_context not allocated.\n", __func__);
+        return 0;
+    }
+
+    qat_context = (qat_ctx *) (ctx->md_data);
+
+    if (0 == qat_context->init)
+    {
+        WARN("[%s] --- final called before init\n", __func__);
+        return 0;
+    }
+
+    sessionSetupData.sessionPriority = CPA_CY_PRIORITY_HIGH;
+    sessionSetupData.symOperation = CPA_CY_SYM_OP_HASH;
+    sessionSetupData.hashSetupData.hashMode = CPA_CY_SYM_HASH_MODE_PLAIN;
+    sessionSetupData.verifyDigest = CPA_FALSE;
+    switch(EVP_MD_CTX_type(ctx))
+    {
+        case NID_sha1:
+            sessionSetupData.hashSetupData.hashAlgorithm = CPA_CY_SYM_HASH_SHA1;
+          break;
+        case NID_sha256:
+            sessionSetupData.hashSetupData.hashAlgorithm = CPA_CY_SYM_HASH_SHA256;
+          break;
+        case NID_sha384:
+            sessionSetupData.hashSetupData.hashAlgorithm = CPA_CY_SYM_HASH_SHA384;
+          break;
+        case NID_sha512:
+            sessionSetupData.hashSetupData.hashAlgorithm = CPA_CY_SYM_HASH_SHA512;
+          break;
+        case NID_md5:
+            sessionSetupData.hashSetupData.hashAlgorithm = CPA_CY_SYM_HASH_MD5;
+          break;
+        default:
+            WARN("[%s] --- Unsupported Digest Type\n", __func__);
+            return 0;
+    }
+    sessionSetupData.hashSetupData.digestResultLenInBytes = EVP_MD_CTX_size(ctx);
+
+    /* Operation to perform */
+    instanceHandle = get_next_inst();
+    if ((sts = cpaCySymSessionCtxGetSize(instanceHandle,
+                                         &sessionSetupData,
+                                         &sessionCtxSize)) !=
+        CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCySymSessionCtxGetSize failed, sts = %d.\n",
+             __func__, sts);
+        return 0;
+    }
+
+    /* setup session ctx */
+    pSessionCtx = (CpaCySymSessionCtx) qaeCryptoMemAlloc(sessionCtxSize, __FILE__, __LINE__);
+    if (NULL == pSessionCtx)
+    {
+        WARN("[%s] --- pSessionCtx malloc failed.\n", __func__);
+        success = 0;
+        goto end;
+    }
+    if(enableAsync)
+    {
+        if ((sts = cpaCySymInitSession
+            (instanceHandle, qat_digestAsynchCallbackFn, &sessionSetupData,
+            pSessionCtx)) != CPA_STATUS_SUCCESS)
+        {
+            WARN("[%s] --- cpaCySymInitSession failed, sts = %d.\n", __func__, sts);
+            success = 0;
+            goto end;
+        }
+    }
+    else
+    {
+        if ((sts = cpaCySymInitSession
+            (instanceHandle, qat_crypto_callbackFn, &sessionSetupData,
+             pSessionCtx)) != CPA_STATUS_SUCCESS)
+        {
+            WARN("[%s] --- cpaCySymInitSession failed, sts = %d.\n", __func__, sts);
+            success = 0;
+            goto end;
+        }
+    }
+
+    qat_context->ctx = pSessionCtx;
+    qat_context->instanceHandle = instanceHandle;
+
+    if((NULL == (OpData = OPENSSL_malloc(sizeof(CpaCySymOpData)))) ||
+       (NULL == (srcBufferList = OPENSSL_malloc(sizeof(CpaBufferList)))))
+    {
+        WARN("[%s] --- alloc failure OpData or \
+                  srcBufferList \n", __func__);
+        success = 0;
+        goto end;
+    }
+
+
+    /* OpData structure setup */
+    OpData->pDigestResult = qaeCryptoMemAlloc(EVP_MD_CTX_size(ctx), __FILE__, __LINE__);
+
+    if (!OpData->pDigestResult)
+    {
+        WARN("[%s] --- alloc failure.\n", __func__);
+        success = 0;
+        goto end;
+    }
+
+    OpData->sessionCtx = pSessionCtx;
+    OpData->packetType = CPA_CY_SYM_PACKET_TYPE_FULL;
+    OpData->hashStartSrcOffsetInBytes = 0;
+    OpData->messageLenToHashInBytes = qat_context->buff_total_bytes;
+    OpData->pAdditionalAuthData = NULL;
+
+    /*  Allocate meta data and flat buffer array for as many buffers
+     *  as we are holding in our context linked list.
+     */
+    if ((sts = cpaCyBufferListGetMetaSize(qat_context->instanceHandle,
+                                          qat_context->buff_count, &metaSize)) != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCyBufferListGetBufferSize failed sts=%d.\n",
+             __func__, sts);
+        success = 0;
+        goto end;
+    }
+
+    if (metaSize)
+    {
+        srcPrivateMetaData = qaeCryptoMemAlloc(metaSize, __FILE__, __LINE__);
+
+        if (!srcPrivateMetaData)
+        {
+            WARN("[%s] --- srcBufferList.pPrivateMetaData is NULL.\n",
+                 __func__);
+            success = 0;
+            goto end;
+        }
+    }
+    else
+    {
+        srcPrivateMetaData = NULL;
+    }
+
+    if (qat_context->buff_count > 0) /* zero length plaintext supported */
+    {
+        srcFlatBuffer = OPENSSL_malloc (((int) (qat_context->buff_count)) * sizeof (CpaFlatBuffer));
+        if (NULL == srcFlatBuffer)
+        {
+            WARN("[%s] --- FlatBuffer malloc failed.\n", __func__);
+            success = 0;
+            goto end;
+        }
+    }
+
+    /*  Populate the pData and length elements of the flat buffer array
+     *  from the context linked list of qat_buffers
+     */
+    buff = qat_context->first;
+
+    for (i = 0; i < qat_context->buff_count; i++)
+    {
+        srcFlatBuffer[i].pData = buff->data;
+        srcFlatBuffer[i].dataLenInBytes = (Cpa32U) buff->len;
+        buff = buff->next;
+    }
+
+    /* Number of pointers */
+    srcBufferList->numBuffers = qat_context->buff_count;
+
+    /* Pointer to an unbounded array containing the number of CpaFlatBuffers
+       defined by numBuffers */
+    srcBufferList->pBuffers = srcFlatBuffer;
+    /* This is an opaque field that is not read or modified internally. */
+    srcBufferList->pUserData = NULL;
+
+    srcBufferList->pPrivateMetaData = srcPrivateMetaData;
+
+    if(enableAsync)
+    {
+        if(NULL == (opDoneAsync = OPENSSL_malloc(sizeof(struct op_done_asynch))))
+        {
+            WARN("[%s] --- alloc op_done", __func__);
+            success = 0;
+            goto end;
+        }
+        qat_context->failed_submission=0;
+        opDoneAsync->md_ctx = ctx;
+        opDoneAsync->orig_out = md;
+        opDoneAsync->qat_ctx.single = qat_context;
+        opDoneAsync->cb_data = cb_data;
+        if((sts = cpaCySymPerformOp(qat_context->instanceHandle,
+            opDoneAsync,
+            OpData,
+            srcBufferList,
+            srcBufferList,
+            CPA_FALSE )) != CPA_STATUS_SUCCESS)
+        {
+            if(CPA_STATUS_RETRY == sts) {
+                QATerr(QAT_F_DIGEST_FINAL, ERR_R_RETRY);
+            }
+            success = 0;
+            goto end;
+        }
+        /* Update transmission stats */
+        qat_context->noRequests++;
+        DEBUG("[%s] Function Finished \n", __func__);
+        return 1;
+    }
+    else
+    {
+        initOpDone(&opDoneSync);
+
+        if (((sts = myPerformOp(qat_context->instanceHandle,
+            &opDoneSync,
+            OpData,
+            srcBufferList,
+            srcBufferList,
+            CPA_FALSE )) != CPA_STATUS_SUCCESS) ||
+            ((rc = waitForOpToComplete(&opDoneSync)) != 0))
+        {
+            if (sts != CPA_STATUS_SUCCESS)
+            {
+                WARN("[%s] --- cpaCySymPerformOp failed sts=%d.\n", __func__, sts);
+            }
+            else
+            {
+                WARN("[%s] --- cpaCySymPerformOp timed out.\n", __func__);
+            }
+            cleanupOpDone(&opDoneSync);
+            success = 0;
+        }
+        else
+        {
+            cleanupOpDone(&opDoneSync);
+            memcpy(md, OpData->pDigestResult, EVP_MD_CTX_size(ctx));
+        }
+
+        sts = cpaCySymRemoveSession(qat_context->instanceHandle,
+                               pSessionCtx);
+        if(CPA_STATUS_SUCCESS != sts)
+        {
+            WARN("[%s] --- cpaCySymRemoveSession failed, sts = %d.\n",
+             __func__, sts);
+            success = 0;
+        }
+
+        qat_context->ctx = NULL;
+        qat_context->init = 0;
+
+
+        DEBUG("[%s] Function Finished \n", __func__);
+    }
+
+    end:
+    if(NULL != pSessionCtx)
+    {
+        qaeCryptoMemFree(pSessionCtx);
+        qat_context->ctx = NULL;
+    }
+
+    if( NULL != OpData )
+    {
+        if(NULL != OpData->pDigestResult)
+        qaeCryptoMemFree(OpData->pDigestResult);
+        OPENSSL_free(OpData);
+    }
+
+    if(NULL != srcBufferList)
+        OPENSSL_free(srcBufferList);
+
+    if(NULL != srcPrivateMetaData)
+        qaeCryptoMemFree (srcPrivateMetaData);
+
+    if(NULL != srcFlatBuffer)
+        OPENSSL_free(srcFlatBuffer);
+    /*  Free the list of chained buffers
+     */
+    if(!enableAsync && NULL != qat_context->first)
+    {
+        buffer_list_cleanup(&(qat_context->first), qat_context->buff_count);
+        qat_context->first = NULL;
+        qat_context->last = NULL;
+        qat_context->buff_count = 0;
+        qat_context->buff_total_bytes = 0;
+    }
+    if(NULL != opDoneAsync)
+        OPENSSL_free(opDoneAsync);
+
+    return success;
+}
+
+
+
+/******************************************************************************
+* function:
+*   digest_final_synch(EVP_MD_CTX *ctx,
+*                unsigned char *md)
+*
+* @param ctx [IN]  - pointer to MD ctx
+* @param md  [OUT] - digest message output
+*
+* description:
+*   Digest Final in synch case
+******************************************************************************/
+static int digest_final_synch(EVP_MD_CTX * ctx, unsigned char *md)
+{
+    return digest_final( ctx, md, NULL, 0);
+}
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*   digest_final_asynch(EVP_MD_CTX *ctx, void *cb_data)
+*
+* @param ctx [IN]  - pointer to MD ctx
+* @param cb_data [IN] - users callback data
+*
+* description:
+*   Digest Final in asynch case
+******************************************************************************/
+static int
+digest_final_asynch(EVP_MD_CTX * ctx, unsigned char *md, void *cb_data)
+{
+    qat_ctx *qat_context = NULL;
+    int status = 0;
+
+    DEBUG("[%s] Function Started \n", __func__);
+    if ((!ctx) || (!ctx->md_data))
+    {
+        WARN("[%s] --- ctx or md_data is NULL.\n", __func__);
+        return status;
+    }
+
+    status = digest_final( ctx, md, cb_data, 1);
+
+    if (!status)
+    {
+        qat_context = (qat_ctx*)(ctx->md_data);
+        qat_context->failed_submission=1;
+    }
+
+    DEBUG("[%s] Function Finished \n", __func__);
+    return status;
+}
+#endif
+
+/******************************************************************************
+* function:
+*   int digest_cleanup(EVP_MD_CTX *ctx)
+*
+* @param ctx [IN] - pointer to sha ctx
+*
+* description:
+*     This function is the rewrite of OpenSSL digest xxx_cleanup() function.
+*     It design to set digested message in ctx to zeros if there is still values in it.
+*     The last function called in the digest routine sequence
+*     and return 1 if successful
+******************************************************************************/
+static int digest_cleanup(EVP_MD_CTX * ctx)
+{
+    qat_ctx *qat_context = NULL;
+
+    DEBUG("[%s] Function Started \n", __func__);
+    if (!ctx)
+    {
+        WARN("[%s] --- ctx is NULL.\n", __func__);
+        return 0;
+    }
+
+    if ( NULL == ctx->md_data )
+    {
+        DEBUG ("[%s] --- qat_context not allocated.\n", __func__);
+        return 1;
+    }
+
+    qat_context = (qat_ctx *) (ctx->md_data);
+
+    if (0 == qat_context->init)
+    {
+        return 1;
+    }
+
+    buffer_list_cleanup(&(qat_context->first), qat_context->buff_count);
+
+    qat_context->first = NULL;
+    qat_context->last = NULL;
+    qat_context->buff_count = 0;
+    qat_context->buff_total_bytes = 0;
+    qat_context->init = 0;
+
+    DEBUG("[%s] Function Finished \n", __func__);
+    return 1;
+}
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*   int digest_cleanup_asynch(EVP_MD_CTX *ctx)
+*
+* @param ctx [IN] - pointer to sha ctx
+*
+* description:
+*     This function is the rewrite of OpenSSL digest xxx_cleanup() function.
+*     It design to set digested message in ctx to zeros if there is still values in it.
+*     The last function called in the digest routine sequence
+*     and return 1 if successful
+******************************************************************************/
+static int digest_cleanup_asynch(EVP_MD_CTX * ctx)
+{
+    qat_ctx *qat_context = NULL;
+
+    DEBUG("[%s] Function Started \n", __func__);
+    if (!ctx)
+    {
+        WARN("[%s] --- ctx is NULL.\n", __func__);
+        return 0;
+    }
+
+    if ( NULL == ctx->md_data )
+    {
+        DEBUG ("[%s] --- qat_context not allocated.\n", __func__);
+        return 1;
+    }
+
+    qat_context = (qat_ctx *) (ctx->md_data);
+
+    if (0 == qat_context->init)
+    {
+        /*No warning here as this maybe legitimate if the callback has cleaned up already. */
+        return 1;
+    }
+
+    if (1 == qat_context->failed_submission)
+    {
+        buffer_list_cleanup(&(qat_context->first), qat_context->buff_count);
+
+        qat_context->first = NULL;
+        qat_context->last = NULL;
+        qat_context->buff_count = 0;
+        qat_context->buff_total_bytes = 0;
+        qat_context->init = 0;
+        qat_context->failed_submission = 0;
+    }
+
+    DEBUG("[%s] Function Finished \n", __func__);
+    return 1;
+}
+#endif
+
+/******************************************************************************
+* function:
+*         qat_digest_copy(EVP_MD_CTX *ctx_out,
+*                        const EVP_MD_CTX *ctx_in)
+*
+* @param ctx_out [OUT] - pointer to new ctx
+* @param ctx_in  [IN]  - pointer to existing context
+*
+* description:
+*    This function copies a context and creates a new session
+*    to be associated with this context.  All buffers are also
+*    copied.
+******************************************************************************/
+static int qat_digest_copy (EVP_MD_CTX *ctx_out, const EVP_MD_CTX *ctx_in)
+{
+    int sts = 1;
+    qat_ctx *qat_context = NULL;
+
+    DEBUG("[%s] Function Started \n", __func__);
+    if ((!ctx_in) || (!ctx_out))
+    {
+        WARN("[%s] --- ctx_in or ctx_out is NULL.\n", __func__);
+        return 0;
+    }
+
+    qat_context = ctx_out?ctx_out->md_data:NULL;
+
+    if(qat_context != NULL)
+    {
+       qat_context->copiedCtx = 1;
+       sts = digest_init(ctx_out, qat_context->md_cb);
+    }
+
+    if(sts)
+       sts = qat_digest_context_copy (ctx_out, ctx_in);
+
+    DEBUG("[%s] Function Finished \n", __func__);
+    return sts;
+}
+
+/******************************************************************************
+* function:
+*         qat_digests(ENGINE *e,
+*                     const EVP_MD **digest,
+*                     const int **nids,
+*                     int nid)
+*
+* @param e      [IN] - OpenSSL engine pointer
+* @param digest [IN] - digest structure pointer
+* @param nids   [IN] - digest functions nids
+* @param nid    [IN] - digest operation id
+*
+* description:
+*   Qat engine digest operations registrar
+******************************************************************************/
+static int
+qat_digests(ENGINE * e, const EVP_MD ** digest, const int **nids, int nid,
+            int isAsynch)
+{
+    int ok = 1;
+
+    /* No specific digest => return a list of supported nids ... */
+    if (!digest)
+    {
+        *nids = qat_digest_nids;
+        /* num digests supported (array/numelements -1) */
+        return (sizeof(qat_digest_nids) / sizeof(qat_digest_nids[0]));
+    }
+
+    if(!isAsynch)
+    {
+#ifndef OPENSSL_DISABLE_QAT_DIGEST_SYNCH
+        switch (nid)
+        {
+            case NID_sha1:
+                *digest = &qat_sha1;
+                break;
+            case NID_sha256:
+                *digest = &qat_sha256;
+                break;
+            case NID_sha384:
+                *digest = &qat_sha384;
+                break;
+            case NID_sha512:
+                *digest = &qat_sha512;
+                break;
+            case NID_md5:
+                *digest = &qat_md5;
+                break;
+            default:
+                WARN("[%s] --- Algorithm not supported by QAT engine\n", __func__);
+                ok = 0;
+                *digest = NULL;
+        }
+#else
+        switch (nid)
+        {
+            case NID_sha1:
+                *digest = EVP_sha1();
+                break;
+            case NID_sha256:
+                *digest = EVP_sha256();
+                break;
+            case NID_sha384:
+                *digest = EVP_sha384();
+                break;
+            case NID_sha512:
+                *digest = EVP_sha512();
+                break;
+            case NID_md5:
+                *digest = EVP_md5();
+                break;
+            default:
+                WARN("[%s] --- Algorithm not supported by QAT engine\n", __func__);
+                ok = 0;
+                *digest = NULL;
+        }
+#endif /* OPENSSL_DISABLE_QAT_DIGEST_SYNCH  */
+    }
+else
+    {
+#ifndef OPENSSL_DISABLE_QAT_DIGEST_ASYNCH
+        switch (nid)
+        {
+            case NID_sha1:
+                *digest = &qat_sha1_asynch;
+                break;
+            case NID_sha256:
+                *digest = &qat_sha256_asynch;
+                break;
+            case NID_sha384:
+                *digest = &qat_sha384_asynch;
+                break;
+            case NID_sha512:
+                *digest = &qat_sha512_asynch;
+                break;
+            case NID_md5:
+                *digest = &qat_md5_asynch;
+                break;
+            default:
+                WARN("[%s] --- Algorithm not supported by QAT engine\n", __func__);
+                ok = 0;
+                *digest = NULL;
+        }
+#else
+    WARN("[%s] --- Algorithm not supported by QAT engine\n", __func__);
+    ok = 0;
+    *digest = NULL;
+#endif /* OPENSSL_DISABLE_QAT_DIGEST_ASYNCH */
+    }
+    return ok;
+}
+
+/******************************************************************************
+* function:
+*   qat_digests_sync(ENGINE *e,
+*                     const EVP_MD **digest,
+*                     const int **nids,
+*                     int nid)
+*
+* @param e      [IN] - OpenSSL engine pointer
+* @param digest [IN] - digest structure pointer
+* @param nids   [IN] - digest functions nids
+* @param nid    [IN] - digest operation id
+*
+* description:
+*    Qat Digests - sync case
+******************************************************************************/
+
+int
+qat_digests_synch(ENGINE * e, const EVP_MD ** digest, const int **nids, int nid)
+{
+    return qat_digests(e, digest, nids, nid, 0);
+}
+
+/******************************************************************************
+* function:
+*   qat_digests_asynch(ENGINE *e,
+*                     const EVP_MD **digest,
+*                     const int **nids,
+*                     int nid)
+*
+* @param e      [IN] - OpenSSL engine pointer
+* @param digest [IN] - digest structure pointer
+* @param nids   [IN] - digest functions nids
+* @param nid    [IN] - digest operation id
+*
+* description:
+*    Qat Digests - asynch case
+******************************************************************************/
+
+int
+qat_digests_asynch(ENGINE * e, const EVP_MD ** digest, const int **nids, int nid)
+{
+    return qat_digests(e, digest, nids, nid, 1);
+}
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_digests.h ./engines/qat_engine/qat_digests.h
--- ../openssl-async/engines/qat_engine/qat_digests.h	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_digests.h	2015-03-05 12:43:44.246963000 +0000
@@ -0,0 +1,70 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qat_digests.h
+ *
+ * This file provides an interface for digest operations
+ *
+ *****************************************************************************/
+
+#ifndef QAT_DIGESTS_H
+#define QAT_DIGESTS_H
+
+#include <openssl/engine.h>
+#include <openssl/ossl_typ.h>
+
+#define SHA256_BLOCK_SIZE   32
+
+#define SHA512_BLOCK_SIZE   64
+
+int qat_digests_synch(ENGINE * e, const EVP_MD ** digests, const int **nids, int nid);
+int qat_digests_asynch(ENGINE * e, const EVP_MD ** digests, const int **nids, int nid);
+
+#endif //QAT_DIGESTS_H
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_dsa.c ./engines/qat_engine/qat_dsa.c
--- ../openssl-async/engines/qat_engine/qat_dsa.c	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_dsa.c	2015-03-05 12:43:44.248958000 +0000
@@ -0,0 +1,1046 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qat_dsa.c
+ *
+ * This file provides an implementation of DSA operations for an OpenSSL
+ * engine
+ *
+ *****************************************************************************/
+
+#include "qat_dsa.h"
+#include "qat_utils.h"
+#include "cpa_cy_dsa.h"
+#include "qat_asym_common.h"
+
+#include <openssl/dsa.h>
+#include "cpa.h"
+#include "cpa_types.h"
+#include "cpa_cy_dh.h"
+#include "e_qat.h"
+#include "e_qat_err.h"
+#ifdef USE_QAT_MEM
+#include "qae_mem_utils.h"
+#endif
+#ifdef USE_QAE_MEM
+#include "qat_mem_drv_inf.h"
+#endif
+
+#include <string.h>
+#include <unistd.h>
+
+#ifdef OPENSSL_ENABLE_QAT_DSA_SYNCH
+#ifdef OPENSSL_DISABLE_QAT_DSA_SYNCH
+#undef OPENSSL_DISABLE_QAT_DSA_SYNCH
+#endif
+#endif
+
+#ifdef OPENSSL_ENABLE_QAT_DSA_ASYNCH
+#ifdef OPENSSL_DISABLE_QAT_DSA_ASYNCH
+#undef OPENSSL_DISABLE_QAT_DSA_ASYNCH
+#endif
+#endif
+
+DSA_SIG *qat_dsa_do_sign_synch(const unsigned char *dgst, int dlen, DSA *dsa);
+int qat_dsa_do_verify_synch(const unsigned char *dgst, int dgst_len,
+                      DSA_SIG *sig, DSA *dsa);
+#ifdef OPENSSL_QAT_ASYNCH
+DSA_SIG *qat_dsa_do_sign_asynch(const unsigned char *dgst, int dlen,
+                                unsigned char *sig, unsigned int *siglen,
+                                DSA *dsa, int (*cb)(unsigned char *res,
+                                size_t reslen, void *cb_data, int status),
+                                void *cb_data);
+int qat_dsa_do_verify_asynch(const unsigned char *dgst, int dgst_len,
+                      DSA_SIG *sig, DSA *dsa,
+                      int (*cb)(void *cb_data, int status), void *cb_data);
+#endif
+/* Qat DSA method structure declaration. */
+static DSA_METHOD qat_dsa_method = {
+	"QAT DSA method",           /* name */
+	qat_dsa_do_sign_synch,      /* do_sign */
+	qat_dsa_sign_setup,         /* sign_setup */
+	qat_dsa_do_verify_synch,    /* do_verify */
+	NULL,                       /* mod_exp */
+	qat_mod_exp_dsa,            /* bn_mod_exp */
+	NULL,                       /* init */
+	NULL,                       /* finish */
+	0,                          /* flags */
+	NULL,                       /* app_data */
+	NULL,                       /* dsa_paramgen */
+	NULL                        /* dsa_keygen */
+#ifdef OPENSSL_QAT_ASYNCH
+	,qat_dsa_do_sign_asynch,     /* do_sign asynch */
+	qat_dsa_do_verify_asynch    /* do_verify asynch */
+#endif
+	};
+
+DSA_METHOD *get_DSA_methods(void)
+	{
+#ifdef OPENSSL_DISABLE_QAT_DSA_SYNCH
+#ifndef OPENSSL_DISABLE_QAT_DSA_ASYNCH
+	const DSA_METHOD* def_dsa_meth = DSA_get_default_method();
+	if (def_dsa_meth)
+		{
+		qat_dsa_method.dsa_do_sign    = def_dsa_meth->dsa_do_sign;
+		qat_dsa_method.dsa_sign_setup = def_dsa_meth->dsa_sign_setup;
+		qat_dsa_method.dsa_do_verify  = def_dsa_meth->dsa_do_verify;
+		qat_dsa_method.bn_mod_exp     = def_dsa_meth->bn_mod_exp;
+		}
+	else
+		{
+		qat_dsa_method.dsa_do_sign    = NULL;
+		qat_dsa_method.dsa_sign_setup = NULL;
+		qat_dsa_method.dsa_do_verify  = NULL;
+		qat_dsa_method.bn_mod_exp     = NULL;
+		}
+#endif
+#endif
+
+#ifdef OPENSSL_QAT_ASYNCH
+#ifndef OPENSSL_DISABLE_QAT_DSA_SYNCH
+#ifdef OPENSSL_DISABLE_QAT_DSA_ASYNCH
+	qat_dsa_method.dsa_do_sign_asynch    = NULL;
+	qat_dsa_method.dsa_do_verify_asynch  = NULL;
+#endif
+#endif
+#endif
+
+#ifdef OPENSSL_DISABLE_QAT_DSA_SYNCH
+#ifdef OPENSSL_DISABLE_QAT_DSA_ASYNCH
+	return NULL;
+#endif
+#endif
+	return &qat_dsa_method;
+	}
+
+typedef struct dsa_sign_op_data
+	{
+	BIGNUM *r;
+	BIGNUM *s;
+	unsigned char *sig;
+	unsigned int *siglen;
+	CpaCyDsaRSSignOpData* opData;
+	int (*cb_func)(unsigned char *res,  size_t reslen, void *cb_data, int status);
+	void *cb_data;
+	} dsa_sign_op_data_t;
+
+typedef struct dsa_verify_op_data
+	{
+	CpaCyDsaVerifyOpData* opData;
+	int (*cb_func)(void *cb_data, int status);
+	void *cb_data;
+	} dsa_verify_op_data_t;
+
+/* DSA range Supported in QAT {L,N} = {1024, 160}, {2048, 224} {2048, 256},
+ *                             {3072, 256} */
+int dsa_qat_range[4][2] =
+	{
+	{1024, 160},
+	{2048, 224},
+	{2048, 256},
+	{3072, 256}
+	};
+
+/* DSA range check is performed so that if the sizes of P and Q are not in
+ * the range supported by QAT engine then fall back to software */
+
+int dsa_range_check(int plen, int qlen)
+	{
+	int i,j,range=0;
+
+	for (i=0,j=0; i<4; i++)
+		{
+		if ((plen == dsa_qat_range[i][j]) && (qlen == dsa_qat_range[i][j+1]))
+			{
+			range = 1;
+			break;
+			}
+		}
+	return range;
+	}
+
+/* Callback to indicate QAT sync completion of DSA Sign */
+void qat_dsaSignCallbackFn(void *pCallbackTag, CpaStatus status, void *pOpData,
+     CpaBoolean bDsaSignStatus, CpaFlatBuffer *pResultR, CpaFlatBuffer *pResultS)
+
+	{
+	qat_crypto_callbackFn(pCallbackTag, status, CPA_CY_SYM_OP_CIPHER, pOpData,
+			NULL, CPA_FALSE);
+	}
+
+/* Callback to indicate QAT sync completion of DSA Verify */
+void qat_dsaVerifyCallbackFn(void *pCallbackTag, CpaStatus status, void *pOpData,
+     CpaBoolean bDsaVerifyStatus)
+
+	{
+	qat_crypto_callbackFn(pCallbackTag, status, CPA_CY_SYM_OP_CIPHER, pOpData,
+			NULL, bDsaVerifyStatus);
+	}
+
+#ifdef OPENSSL_QAT_ASYNCH
+/* Callback to indicate QAT sync completion of DSA Sign in asynch mode */
+void qat_dsaSignAsynchCallbackFn(void *pCallbackTag, CpaStatus status, void *pOpData,
+	CpaBoolean bDsaSignStatus, CpaFlatBuffer *pResultR, CpaFlatBuffer *pResultS)
+	{
+	DSA_SIG  *ret=NULL;
+	dsa_sign_op_data_t* sign_async_data = (dsa_sign_op_data_t*) (pCallbackTag);
+	int cb_status = status == CPA_STATUS_SUCCESS ? 1 : 0;
+
+	if (!sign_async_data || !pResultR || !pResultS ||
+                !sign_async_data->siglen || !sign_async_data->sig)
+		{
+		WARN("[%s] --- parameters NULL!\n", __func__);
+		goto err;
+		}
+
+	ret = DSA_SIG_new();
+	if (!ret)
+		{
+		WARN("[%s] --- DSA_SIG_new() failed!\n", __func__);
+		goto err;
+		}
+
+	/* Convert the flatbuffer results back to a BN */
+	BN_bin2bn(pResultR->pData, pResultR->dataLenInBytes, sign_async_data->r);
+	BN_bin2bn(pResultS->pData, pResultS->dataLenInBytes, sign_async_data->s);
+	ret->r = sign_async_data->r;
+	ret->s = sign_async_data->s;
+
+	*sign_async_data->siglen = i2d_DSA_SIG(ret, &sign_async_data->sig);
+
+	/* Invoke the user registered callback */
+	sign_async_data->cb_func(sign_async_data->sig, *sign_async_data->siglen, sign_async_data->cb_data, cb_status);
+
+err:
+	if (ret)
+		{
+		DSA_SIG_free(ret);
+		}
+
+	if (pResultR)
+		{
+		if (pResultR->pData)
+			{
+			qaeCryptoMemFree(pResultR->pData);
+			}
+		OPENSSL_free(pResultR);
+		}
+	if (pResultS)
+		{
+		if (pResultS->pData)
+			{
+			qaeCryptoMemFree(pResultS->pData);
+			}
+		OPENSSL_free(pResultS);
+		}
+
+	if (sign_async_data)
+		{
+		if (sign_async_data->opData)
+			{
+			if (sign_async_data->opData->P.pData) qaeCryptoMemFree(sign_async_data->opData->P.pData);
+			if (sign_async_data->opData->Q.pData) qaeCryptoMemFree(sign_async_data->opData->Q.pData);
+			if (sign_async_data->opData->G.pData) qaeCryptoMemFree(sign_async_data->opData->G.pData);
+			if (sign_async_data->opData->X.pData) qaeCryptoMemFree(sign_async_data->opData->X.pData);
+			if (sign_async_data->opData->K.pData) qaeCryptoMemFree(sign_async_data->opData->K.pData);
+			if (sign_async_data->opData->Z.pData) qaeCryptoMemFree(sign_async_data->opData->Z.pData);
+			OPENSSL_free(sign_async_data->opData);
+			}
+                OPENSSL_free(sign_async_data);
+		}
+	}
+#endif
+
+#ifdef OPENSSL_QAT_ASYNCH
+/* Callback to indicate QAT sync completion of DSA Verify in asynch mode*/
+void qat_dsaVerifyAsynchCallbackFn(void *pCallbackTag, CpaStatus status, void *pOpData,
+     CpaBoolean bDsaVerifyStatus)
+
+	{
+	dsa_verify_op_data_t* verify_async_data = (dsa_verify_op_data_t*) (pCallbackTag);
+	int cb_status = bDsaVerifyStatus == CPA_TRUE ? 1 : 0;
+
+	if (!verify_async_data)
+		{
+		WARN("[%s] --- pCallbackTag NULL!\n", __func__);
+		goto err;
+		}
+
+	/* Invoke the user registered callback */
+	verify_async_data->cb_func(verify_async_data->cb_data, cb_status);
+
+err:
+	if (verify_async_data)
+		{
+		if (verify_async_data->opData)
+			{
+			if (verify_async_data->opData->P.pData) qaeCryptoMemFree(verify_async_data->opData->P.pData);
+			if (verify_async_data->opData->Q.pData) qaeCryptoMemFree(verify_async_data->opData->Q.pData);
+			if (verify_async_data->opData->G.pData) qaeCryptoMemFree(verify_async_data->opData->G.pData);
+			if (verify_async_data->opData->Y.pData) qaeCryptoMemFree(verify_async_data->opData->Y.pData);
+			if (verify_async_data->opData->Z.pData) qaeCryptoMemFree(verify_async_data->opData->Z.pData);
+			if (verify_async_data->opData->R.pData) qaeCryptoMemFree(verify_async_data->opData->R.pData);
+			if (verify_async_data->opData->S.pData) qaeCryptoMemFree(verify_async_data->opData->S.pData);
+			OPENSSL_free(verify_async_data->opData);
+			}
+		OPENSSL_free(verify_async_data);
+		}
+	}
+#endif
+
+/******************************************************************************
+* function:
+*         qat_mod_exp_dsa(DSA *dsa, BIGNUM *r, BIGNUM *a, const BIGNUM *p,
+*                         const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)
+*
+* @param dsa   [IN] - Pointer to a OpenSSL DSA struct.
+* @param r     [IN] - Result bignum of mod_exp
+* @param a     [IN] - Base used for mod_exp
+* @param p     [IN] - Exponent used for mod_exp
+* @param m     [IN] - Modulus used for mod_exp
+* @param ctx   [IN] - EVP context.
+* @param m_ctx [IN] - EVP context for Montgomery multiplication.
+*
+* description:
+*   Overridden modular exponentiation function used in DSA.
+*
+******************************************************************************/
+int qat_mod_exp_dsa(DSA *dsa, BIGNUM *r, BIGNUM *a, const BIGNUM *p,
+                    const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)
+	{
+	DEBUG("%s been called \n", __func__);
+	CRYPTO_QAT_LOG("AU - %s\n", __func__);
+	return qat_mod_exp(r, a, p, m);
+	}
+
+/******************************************************************************
+* function:
+*         qat_dsa_do_sign(const unsigned char *dgst, int dlen,
+*                         unsigned char *sig, unsigned int *siglen,
+*                         DSA *dsa, int (*cb)(unsigned char *res,
+*                         size_t reslen, void *cb_data, int status),
+*                         void *cb_data)
+*
+* description:
+*   Generate DSA R and S Signatures.
+******************************************************************************/
+DSA_SIG *qat_dsa_do_sign(const unsigned char *dgst, int dlen,
+                         unsigned char *sig, unsigned int *siglen,
+                         DSA *dsa, int (*cb)(unsigned char *res,
+                         size_t reslen, void *cb_data, int status),
+                         void *cb_data)
+	{
+	BIGNUM *r=NULL,*s=NULL;
+	BIGNUM *k=NULL;
+	BN_CTX *ctx=NULL;
+	DSA_SIG *ret=NULL;
+	CpaFlatBuffer *pResultR=NULL;
+	CpaFlatBuffer *pResultS=NULL;
+	CpaInstanceHandle instanceHandle;
+	CpaCyDsaRSSignOpData *opData=NULL;
+	CpaBoolean bDsaSignStatus;
+	CpaStatus status;
+	size_t buflen;
+	struct op_done op_done;
+	int qatPerformOpRetries = 0;
+	useconds_t ulPollInterval = getQatPollInterval();
+	int iMsgRetry = getQatMsgRetryCount();
+#ifdef OPENSSL_QAT_ASYNCH
+	dsa_sign_op_data_t *dsa_op_done=NULL;
+#endif
+	int rc = 1;
+
+    DEBUG("[%s] --- called.\n", __func__);
+    CRYPTO_QAT_LOG("AU - %s\n", __func__);
+
+	if (!dsa->p || !dsa->q || !dsa->g)
+		{
+		QATerr(QAT_F_QAT_DSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+		return ret;
+		}
+
+	opData = (CpaCyDsaRSSignOpData *)
+                       OPENSSL_malloc(sizeof(CpaCyDsaRSSignOpData));
+	if (opData == NULL)
+		{
+		QATerr(QAT_F_QAT_DSA_DO_SIGN, ERR_R_MALLOC_FAILURE);
+		return ret;
+		}
+
+	memset(opData, 0, sizeof(CpaCyDsaRSSignOpData));
+
+	if ((r = BN_new()) == NULL)
+		{
+		QATerr(QAT_F_QAT_DSA_DO_SIGN, ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	if ((s = BN_new()) == NULL)
+		{
+		QATerr(QAT_F_QAT_DSA_DO_SIGN, ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	if ((ctx = BN_CTX_new()) == NULL)
+		{
+		QATerr(QAT_F_QAT_DSA_DO_SIGN, ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	BN_CTX_start(ctx);
+
+	if ((k = BN_CTX_get(ctx)) == NULL)
+		{
+		QATerr(QAT_F_QAT_DSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+		goto err;
+		}
+
+	if (dlen > BN_num_bytes(dsa->q))
+		/* if the digest length is greater than the size of q use the
+		 * BN_num_bits(dsa->q) leftmost bits of the digest, see
+		 * fips 186-3, 4.2 */
+		dlen = BN_num_bytes(dsa->q);
+	do
+		{
+		if (!BN_rand_range(k, dsa->q))
+			{
+			QATerr(QAT_F_QAT_DSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+			goto err;
+			}
+		}
+	while (BN_is_zero(k));
+
+	buflen = BN_num_bytes(dsa->q);
+	pResultR = (CpaFlatBuffer *)OPENSSL_malloc(sizeof(CpaFlatBuffer));
+	if (!pResultR)
+		{
+		QATerr(QAT_F_QAT_DSA_DO_SIGN, ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+	pResultR->pData = qaeCryptoMemAlloc(buflen, __FILE__, __LINE__);
+	if (!pResultR->pData)
+		{
+		QATerr(QAT_F_QAT_DSA_DO_SIGN, ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+	pResultR->dataLenInBytes = (Cpa32U) buflen;
+	pResultS = (CpaFlatBuffer *)OPENSSL_malloc(sizeof(CpaFlatBuffer));
+	if (!pResultS)
+		{
+		QATerr(QAT_F_QAT_DSA_DO_SIGN, ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+	pResultS->pData = qaeCryptoMemAlloc(buflen, __FILE__, __LINE__);
+	if (!pResultS->pData)
+		{
+		QATerr(QAT_F_QAT_DSA_DO_SIGN, ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+	pResultS->dataLenInBytes = (Cpa32U) buflen;
+
+	if ((qat_BN_to_FB(&(opData->P), dsa->p) != 1) ||
+		(qat_BN_to_FB(&(opData->Q), dsa->q) != 1) ||
+		(qat_BN_to_FB(&(opData->G), dsa->g) != 1) ||
+		(qat_BN_to_FB(&(opData->X), dsa->priv_key) != 1) ||
+		(qat_BN_to_FB(&(opData->K), k) != 1))
+		{
+		QATerr(QAT_F_QAT_DSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+		goto err;
+		}
+
+	opData->Z.pData = qaeCryptoMemAlloc(dlen, __FILE__, __LINE__);
+	if (!opData->Z.pData)
+		{
+		QATerr(QAT_F_QAT_DSA_DO_SIGN, ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+	opData->Z.dataLenInBytes = (Cpa32U) dlen;
+
+	memcpy(opData->Z.pData, dgst, dlen);
+
+	ret = DSA_SIG_new();
+	if (!ret)
+		{
+		QATerr(QAT_F_QAT_DSA_DO_SIGN, ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	if (!cb) /* Synch mode */
+		{
+		initOpDone(&op_done);
+
+		do
+			{
+			if ((instanceHandle = get_next_inst()) == NULL)
+				{
+				QATerr(QAT_F_QAT_DSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+				cleanupOpDone(&op_done);
+				DSA_SIG_free(ret);
+				ret = NULL;
+				goto err;
+				}
+
+			status = cpaCyDsaSignRS(instanceHandle,
+					qat_dsaSignCallbackFn,
+					&op_done,
+					opData,
+					&bDsaSignStatus,
+					pResultR,
+					pResultS);
+
+			if (status == CPA_STATUS_RETRY)
+				{
+				usleep(ulPollInterval +
+						(qatPerformOpRetries %
+						 QAT_RETRY_BACKOFF_MODULO_DIVISOR));
+				qatPerformOpRetries++;
+				}
+			}
+		while(status == CPA_STATUS_RETRY &&
+				((qatPerformOpRetries < iMsgRetry) ||
+				 (iMsgRetry == QAT_INFINITE_MAX_NUM_RETRIES)));
+
+		if (status != CPA_STATUS_SUCCESS)
+			{
+			QATerr(QAT_F_QAT_DSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+			cleanupOpDone(&op_done);
+			DSA_SIG_free(ret);
+			ret = NULL;
+			goto err;
+			}
+
+		rc = waitForOpToComplete(&op_done);
+		cleanupOpDone(&op_done);
+		if (rc)
+			{
+			DSA_SIG_free(ret);
+			ret = NULL;
+			goto err;
+			}
+
+		/* Convert the flatbuffer results back to a BN */
+		BN_bin2bn(pResultR->pData, pResultR->dataLenInBytes, r);
+		BN_bin2bn(pResultS->pData, pResultS->dataLenInBytes, s);
+		ret->r = r;
+		ret->s = s;
+		}
+#ifdef OPENSSL_QAT_ASYNCH
+	else  /* Asynch mode */
+		{
+		dsa_op_done = (dsa_sign_op_data_t *) OPENSSL_malloc(sizeof(dsa_sign_op_data_t));
+		if (dsa_op_done == NULL)
+			{
+			QATerr(QAT_F_QAT_DSA_DO_SIGN, ERR_R_MALLOC_FAILURE);
+			DSA_SIG_free(ret);
+			ret = NULL;
+			goto err;
+			}
+
+		dsa_op_done->r = r;
+		dsa_op_done->s = s;
+		dsa_op_done->sig = sig;
+		dsa_op_done->siglen = siglen;
+		dsa_op_done->opData = opData;
+		dsa_op_done->cb_func = cb;
+		dsa_op_done->cb_data = cb_data;
+
+		if ((instanceHandle = get_next_inst()) == NULL)
+			{
+			QATerr(QAT_F_QAT_DSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+			OPENSSL_free(dsa_op_done);
+			DSA_SIG_free(ret);
+			ret = NULL;
+			goto err;
+			}
+
+		status = cpaCyDsaSignRS(instanceHandle,
+				qat_dsaSignAsynchCallbackFn,
+				dsa_op_done,
+				opData,
+				&bDsaSignStatus,
+				pResultR,
+				pResultS);
+
+		if (status != CPA_STATUS_SUCCESS)
+			{
+			WARN("[%s] --- Async cpaCyEcdsaSignRS, status=%d.\n", __func__, status);
+			if (status == CPA_STATUS_RETRY)
+				{
+				QATerr(QAT_F_QAT_DSA_DO_SIGN, ERR_R_RETRY);
+				}
+			else
+				QATerr(QAT_F_QAT_DSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+			OPENSSL_free(dsa_op_done);
+			DSA_SIG_free(ret);
+			ret = NULL;
+			goto err;
+			}
+		if (ctx) BN_CTX_end(ctx);
+		if (ctx) BN_CTX_free(ctx);
+		return ret;
+		}
+#endif
+err:
+	if (!ret)
+		{
+		BN_free(r);
+		BN_free(s);
+		}
+	if (pResultR)
+		{
+		if (pResultR->pData)
+			{
+			qaeCryptoMemFree(pResultR->pData);
+			}
+		OPENSSL_free(pResultR);
+		}
+	if (pResultS)
+		{
+		if (pResultS->pData)
+			{
+			qaeCryptoMemFree(pResultS->pData);
+			}
+		OPENSSL_free(pResultS);
+		}
+
+	if (opData)
+		{
+		if (opData->P.pData) qaeCryptoMemFree(opData->P.pData);
+		if (opData->Q.pData) qaeCryptoMemFree(opData->Q.pData);
+		if (opData->G.pData) qaeCryptoMemFree(opData->G.pData);
+		if (opData->X.pData) qaeCryptoMemFree(opData->X.pData);
+		if (opData->K.pData) qaeCryptoMemFree(opData->K.pData);
+		if (opData->Z.pData) qaeCryptoMemFree(opData->Z.pData);
+		OPENSSL_free (opData);
+		}
+
+	if (ctx) BN_CTX_end(ctx);
+	if (ctx) BN_CTX_free(ctx);
+
+	return(ret);
+	}
+
+/******************************************************************************
+* function:
+*         qat_dsa_do_sign_synch(const unsigned char *dgst, int dlen, DSA *dsa)
+*
+* description:
+*   Generate DSA R and S Signatures in synch mode.
+******************************************************************************/
+DSA_SIG *qat_dsa_do_sign_synch(const unsigned char *dgst, int dlen, DSA *dsa)
+	{
+	const DSA_METHOD *default_dsa_method = DSA_OpenSSL();
+
+	if (!dsa)
+		return NULL;
+
+	/* If the sizes of P and Q are not in the range supported by QAT
+	 * engine then fall back to software */
+
+	if (!dsa_range_check(BN_num_bits(dsa->p),BN_num_bits(dsa->q)))
+		{
+		if(!default_dsa_method)
+			return NULL;
+		return default_dsa_method->dsa_do_sign(dgst, dlen, dsa);
+		}
+
+	return qat_dsa_do_sign(dgst, dlen, NULL, NULL, dsa, NULL, NULL);
+	}
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*         qat_dsa_do_sign_asynch(const unsigned char *dgst, int dlen,
+*                                unsigned char *sig, unsigned int *siglen,
+*                                DSA *dsa, int (*cb)(unsigned char *res,
+*                                size_t reslen, void *cb_data, int status),
+*                                void *cb_data)
+*
+* description:
+*   Generate DSA R and S Signatures in asynch mode.
+******************************************************************************/
+DSA_SIG *qat_dsa_do_sign_asynch(const unsigned char *dgst, int dlen,
+                                unsigned char *sig, unsigned int *siglen,
+                                DSA *dsa, int (*cb)(unsigned char *res,
+                                size_t reslen, void *cb_data, int status),
+                                void *cb_data)
+	{
+	const DSA_METHOD *default_dsa_method = DSA_OpenSSL();
+	DSA_SIG *ret=NULL;
+
+	qat_dsa_method.bn_mod_exp     = default_dsa_method->bn_mod_exp;
+
+	if (!dsa || !cb || !siglen)
+		return NULL;
+
+	/* If the sizes of P and Q are not in the range supported by QAT
+	 * engine then fall back to software */
+
+	if (!dsa_range_check(BN_num_bits(dsa->p),BN_num_bits(dsa->q)))
+		{
+		if(!default_dsa_method)
+			return NULL;
+
+		ret =  default_dsa_method->dsa_do_sign(dgst, dlen, dsa);
+		if (!ret)
+			return NULL;
+
+		*siglen = i2d_DSA_SIG(ret, &sig);
+		cb(sig, *siglen, cb_data, 1);
+		return ret;
+		}
+
+	return qat_dsa_do_sign(dgst, dlen, sig, siglen, dsa, cb, cb_data);
+	}
+#endif
+
+/******************************************************************************
+* function:
+*         qat_dsa_sign_setup(DSA *dsa, BN_CTX *ctx_in, BIGNUM **kinvp,
+*                            BIGNUM **rp)
+*
+* description:
+*   Wrapper around the default OpenSSL DSA dsa_sign_setup() function to avoid
+*   a null function pointer.
+*   See the OpenSSL documentation for parameters.
+******************************************************************************/
+int qat_dsa_sign_setup(DSA *dsa, BN_CTX *ctx_in, BIGNUM **kinvp,
+                       BIGNUM **rp)
+	{
+	const DSA_METHOD *openssl_dsa_method = DSA_OpenSSL();
+	DEBUG("%s been called \n", __func__);
+
+	return openssl_dsa_method->dsa_sign_setup(dsa, ctx_in, kinvp, rp);
+	}
+
+/******************************************************************************
+* function:
+*         qat_dsa_do_verify(const unsigned char *dgst, int dgst_len,
+*                           DSA_SIG *sig, DSA *dsa,
+*                           int (*cb)(void *cb_data, int status), void *cb_data)
+*
+* description:
+*   Verify DSA R and S Signatures.
+******************************************************************************/
+int qat_dsa_do_verify(const unsigned char *dgst, int dgst_len,
+                      DSA_SIG *sig, DSA *dsa,
+                      int (*cb)(void *cb_data, int status), void *cb_data)
+	{
+	BN_CTX *ctx;
+	BIGNUM *z=NULL;
+	int ret = -1, i=0, rc = 1;
+	CpaInstanceHandle instanceHandle;
+	CpaCyDsaVerifyOpData *opData=NULL;
+	CpaBoolean bDsaVerifyStatus;
+	CpaStatus status;
+	struct op_done op_done;
+	int qatPerformOpRetries = 0;
+	useconds_t ulPollInterval = getQatPollInterval();
+	int iMsgRetry = getQatMsgRetryCount();
+#ifdef OPENSSL_QAT_ASYNCH
+	dsa_verify_op_data_t *dsa_op_done=NULL;
+#endif
+
+    DEBUG("[%s] --- called.\n", __func__);
+    CRYPTO_QAT_LOG("AU - %s\n", __func__);
+
+	if (!dsa->p || !dsa->q || !dsa->g)
+		{
+		QATerr(QAT_F_QAT_DSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		return ret;
+		}
+
+	i = BN_num_bits(dsa->q);
+	/* fips 186-3 allows only different sizes for q */
+	if (i != 160 && i != 224 && i != 256)
+		{
+		QATerr(QAT_F_QAT_DSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		return ret;
+		}
+
+	opData = (CpaCyDsaVerifyOpData *)
+                       OPENSSL_malloc(sizeof(CpaCyDsaVerifyOpData));
+	if (opData == NULL)
+		{
+		QATerr(QAT_F_QAT_DSA_DO_VERIFY, ERR_R_MALLOC_FAILURE);
+		return ret;
+		}
+
+	memset(opData, 0, sizeof(CpaCyDsaVerifyOpData));
+
+	if ((ctx = BN_CTX_new()) == NULL)
+		{
+		QATerr(QAT_F_QAT_DSA_DO_VERIFY, ERR_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	BN_CTX_start(ctx);
+
+	if ((z = BN_CTX_get(ctx)) == NULL)
+		{
+		QATerr(QAT_F_QAT_DSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		goto err;
+		}
+
+	if (BN_is_zero(sig->r) || BN_is_negative(sig->r) ||
+			BN_ucmp(sig->r, dsa->q) >= 0)
+		{
+		QATerr(QAT_F_QAT_DSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		goto err;
+		}
+	if (BN_is_zero(sig->s) || BN_is_negative(sig->s) ||
+			BN_ucmp(sig->s, dsa->q) >= 0)
+		{
+		QATerr(QAT_F_QAT_DSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		goto err;
+		}
+
+	if (dgst_len > (i >> 3))
+		/* if the digest length is greater than the size of q use the
+		 * BN_num_bits(dsa->q) leftmost bits of the digest, see
+		 * fips 186-3, 4.2 */
+		dgst_len = (i >> 3);
+	if (BN_bin2bn(dgst,dgst_len,z) == NULL)
+		{
+		QATerr(QAT_F_QAT_DSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		goto err;
+		}
+
+	if ((qat_BN_to_FB(&(opData->P), dsa->p) != 1) ||
+			(qat_BN_to_FB(&(opData->Q), dsa->q) != 1) ||
+			(qat_BN_to_FB(&(opData->G), dsa->g) != 1) ||
+			(qat_BN_to_FB(&(opData->Y), dsa->pub_key) != 1) ||
+			(qat_BN_to_FB(&(opData->Z), z) != 1) ||
+			(qat_BN_to_FB(&(opData->R), sig->r) != 1) ||
+			(qat_BN_to_FB(&(opData->S), sig->s) != 1))
+		{
+		QATerr(QAT_F_QAT_DSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		goto err;
+		}
+
+	if (!cb)  /* Synch mode */
+		{
+		initOpDone(&op_done);
+
+		do
+			{
+			if ((instanceHandle = get_next_inst()) == NULL)
+				{
+				QATerr(QAT_F_QAT_DSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+				cleanupOpDone(&op_done);
+				goto err;
+				}
+
+			status = cpaCyDsaVerify(instanceHandle,
+					qat_dsaVerifyCallbackFn,
+					&op_done,
+					opData,
+					&bDsaVerifyStatus);
+
+			if (status == CPA_STATUS_RETRY)
+				{
+				usleep(ulPollInterval +
+						(qatPerformOpRetries %
+						 QAT_RETRY_BACKOFF_MODULO_DIVISOR));
+				qatPerformOpRetries++;
+				}
+			}
+		while(status == CPA_STATUS_RETRY &&
+				((qatPerformOpRetries < iMsgRetry) ||
+				 (iMsgRetry == QAT_INFINITE_MAX_NUM_RETRIES)));
+
+		if (status != CPA_STATUS_SUCCESS)
+			{
+			QATerr(QAT_F_QAT_DSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+			cleanupOpDone(&op_done);
+			goto err;
+			}
+
+		rc = waitForOpToComplete(&op_done);
+		if (op_done.verifyResult == CPA_TRUE)
+			ret=1;
+
+		cleanupOpDone(&op_done);
+		if (rc )
+			{
+			ret = 0;
+			goto err;
+			}
+		}
+#ifdef OPENSSL_QAT_ASYNCH
+        else   /* Asynch mode */
+		{
+		dsa_op_done = (dsa_verify_op_data_t *) OPENSSL_malloc(sizeof(dsa_verify_op_data_t));
+		if (dsa_op_done == NULL)
+			{
+			QATerr(QAT_F_QAT_DSA_DO_VERIFY, ERR_R_MALLOC_FAILURE);
+			goto err;
+			}
+
+		dsa_op_done->opData = opData;
+		dsa_op_done->cb_func = cb;
+		dsa_op_done->cb_data = cb_data;
+
+		if ((instanceHandle = get_next_inst()) == NULL)
+			{
+			QATerr(QAT_F_QAT_DSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+			OPENSSL_free(dsa_op_done);
+			goto err;
+			}
+
+		status = cpaCyDsaVerify(instanceHandle,
+				qat_dsaVerifyAsynchCallbackFn,
+				dsa_op_done,
+				opData,
+				&bDsaVerifyStatus);
+
+		if (status != CPA_STATUS_SUCCESS)
+			{
+			WARN("[%s] --- Async cpaCyDsaVerify, status=%d.\n", __func__, status);
+			if (status == CPA_STATUS_RETRY)
+				{
+				QATerr(QAT_F_QAT_DSA_DO_VERIFY, ERR_R_RETRY);
+				}
+			OPENSSL_free(dsa_op_done);
+			ret=0;
+			goto err;
+			}
+		ret = 1;
+		if (ctx) BN_CTX_end(ctx);
+		if (ctx) BN_CTX_free(ctx);
+		return ret;
+		}
+#endif
+
+err:
+	if (opData)
+		{
+		if (opData->P.pData) qaeCryptoMemFree(opData->P.pData);
+		if (opData->Q.pData) qaeCryptoMemFree(opData->Q.pData);
+		if (opData->G.pData) qaeCryptoMemFree(opData->G.pData);
+		if (opData->Y.pData) qaeCryptoMemFree(opData->Y.pData);
+		if (opData->Z.pData) qaeCryptoMemFree(opData->Z.pData);
+		if (opData->R.pData) qaeCryptoMemFree(opData->R.pData);
+		if (opData->S.pData) qaeCryptoMemFree(opData->S.pData);
+		OPENSSL_free (opData);
+		}
+
+	if (ctx) BN_CTX_end(ctx);
+	if (ctx) BN_CTX_free(ctx);
+
+	return(ret);
+	}
+
+/******************************************************************************
+* function:
+*         qat_dsa_do_verify_synch(const unsigned char *dgst, int dgst_len,
+*                           DSA_SIG *sig, DSA *dsa)
+*
+* description:
+*   Verify DSA R and S Signatures in synch mode.
+******************************************************************************/
+int qat_dsa_do_verify_synch(const unsigned char *dgst, int dgst_len,
+                      DSA_SIG *sig, DSA *dsa)
+	{
+	const DSA_METHOD *default_dsa_method = DSA_OpenSSL();
+
+	if (!dsa)
+		return -1;
+
+	/* If the sizes of P and Q are not in the range supported by QAT
+	 * engine then fall back to software */
+
+	if (!dsa_range_check(BN_num_bits(dsa->p),BN_num_bits(dsa->q)))
+		{
+		if (!default_dsa_method)
+			return -1;
+		return default_dsa_method->dsa_do_verify
+                                          (dgst, dgst_len, sig, dsa);
+		}
+
+	return qat_dsa_do_verify(dgst, dgst_len, sig, dsa, NULL, NULL);
+	}
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*         qat_dsa_do_verify_asynch(const unsigned char *dgst, int dgst_len,
+*                           DSA_SIG *sig, DSA *dsa,
+*                           int (*cb)(void *cb_data, int status), void *cb_data)
+*
+* description:
+*   Verify DSA R and S Signatures in asynch mode.
+******************************************************************************/
+int qat_dsa_do_verify_asynch(const unsigned char *dgst, int dgst_len,
+		DSA_SIG *sig, DSA *dsa,
+		int (*cb)(void *cb_data, int status), void *cb_data)
+	{
+	const DSA_METHOD *default_dsa_method = DSA_OpenSSL();
+	int ret=0;
+
+	if (!dsa || !cb)
+		return -1;
+
+	/* If the sizes of P and Q are not in the range supported by QAT
+	 * engine then fall back to software */
+
+	if (!dsa_range_check(BN_num_bits(dsa->p),BN_num_bits(dsa->q)))
+		{
+		if (!default_dsa_method)
+			return -1;
+		ret = default_dsa_method->dsa_do_verify
+				(dgst, dgst_len, sig, dsa);
+		cb(cb_data, ret);
+		return 1;
+		}
+
+	return qat_dsa_do_verify(dgst, dgst_len, sig, dsa, cb, cb_data);
+	}
+#endif
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_dsa.h ./engines/qat_engine/qat_dsa.h
--- ../openssl-async/engines/qat_engine/qat_dsa.h	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_dsa.h	2015-03-05 12:43:44.249956000 +0000
@@ -0,0 +1,80 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qat_dsa.h
+ *
+ * This file provides an interface for DSA opeartion
+ *
+ *****************************************************************************/
+
+#ifndef QAT_DSA_H
+#define QAT_DSA_H
+
+#include <openssl/dsa.h>
+
+/* Qat engine DSA methods declaration */
+DSA_SIG *qat_dsa_do_sign(const unsigned char *dgst, int dlen,
+                         unsigned char *sig, unsigned int *siglen,
+                         DSA *dsa, int (*cb)(unsigned char *res,
+                         size_t reslen, void *cb_data, int status),
+                         void *cb_data);
+
+int qat_dsa_sign_setup(DSA *dsa, BN_CTX *ctx_in, BIGNUM **kinvp,
+                       BIGNUM **rp);
+int qat_dsa_do_verify(const unsigned char *dgst, int dgst_len,
+                      DSA_SIG *sig, DSA *dsa,
+                      int (*cb)(void *cb_data, int status), void *cb_data);
+
+int qat_mod_exp_dsa(DSA *dsa, BIGNUM *r, BIGNUM *a, const BIGNUM *p,
+                    const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);
+
+DSA_METHOD *get_DSA_methods(void);
+
+#endif //QAT_DSA_H
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_ecdh.c ./engines/qat_engine/qat_ecdh.c
--- ../openssl-async/engines/qat_engine/qat_ecdh.c	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_ecdh.c	2015-03-05 12:43:44.250962000 +0000
@@ -0,0 +1,1061 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qat_ecdh.c
+ *
+ * This file provides support for ECDH
+ *
+ *****************************************************************************/
+
+#include <string.h>
+#include <limits.h>
+#include <unistd.h>
+#include "qat_ecdh.h"
+#include <openssl/ecdh.h>
+#include <openssl/err.h>
+#include <openssl/ec.h>
+#include <ech_locl.h>
+#include "cpa.h"
+#include "cpa_types.h"
+#include "cpa_cy_ecdh.h"
+#include "cpa_cy_ec.h"
+#include "e_qat.h"
+#include "qat_asym_common.h"
+#ifdef USE_QAT_MEM
+#include "qae_mem_utils.h"
+#endif
+#ifdef USE_QAE_MEM
+#include "qat_mem_drv_inf.h"
+#endif
+#include "e_qat_err.h"
+#include "qat_utils.h"
+
+#ifdef OPENSSL_ENABLE_QAT_ECDH_SYNCH
+#ifdef OPENSSL_DISABLE_QAT_ECDH_SYNCH
+#undef OPENSSL_DISABLE_QAT_ECDH_SYNCH
+#endif
+#endif
+
+#ifdef OPENSSL_ENABLE_QAT_ECDH_ASYNCH
+#ifdef OPENSSL_DISABLE_QAT_ECDH_ASYNCH
+#undef OPENSSL_DISABLE_QAT_ECDH_ASYNCH
+#endif
+#endif
+
+#ifndef OPENSSL_QAT_ASYNCH
+#define OPENSSL_DISABLE_QAT_ECDH_ASYNCH
+#endif
+
+/* Qat engine ECDH methods declaration */
+static int qat_ecdh_compute_key(void *outX, size_t lenX, void *outY, size_t lenY, const EC_POINT *pub_key,
+								EC_KEY *ecdh,
+								void *(*KDF)(const void *in, size_t inlen, void *out, size_t *outlen),
+								int (*cb)(unsigned char *res, size_t reslen, void *cb_data, int status),
+								void *cb_data);
+
+static int qat_ecdh_compute_key_sync(void *out, size_t outlen,
+        const EC_POINT *pub_key,EC_KEY *ecdh,
+        void *(*KDF)(const void *in, size_t inlen, void *out, size_t *outlen));
+
+#ifdef OPENSSL_QAT_ASYNCH
+static int qat_ecdh_compute_key_async(void *out, size_t outlen,
+									  const EC_POINT *pub_key, EC_KEY *ecdh,
+									  void *(*KDF)(const void *in, size_t inlen, void *out, size_t *outlen),
+									  int (*cb)(unsigned char *res, size_t reslen,void *cb_data, int status),
+									  void *cb_data);
+#endif
+
+#ifdef OPENSSL_QAT_ASYNCH
+static int qat_ecdh_generate_key_sync(EC_KEY *ecdh);
+
+static int qat_ecdh_generate_key_async(
+        EC_KEY *ecdh,
+        int (*cb)(unsigned char *res, size_t reslen,void *cb_data, int status),
+        void *cb_data);
+#endif
+
+static ECDH_METHOD qat_ecdh_method = {
+	"QAT ECDH method",          /* name */
+	qat_ecdh_compute_key_sync,  /* compute_key sync */
+#ifdef OPENSSL_QAT_ASYNCH
+	qat_ecdh_compute_key_async, /* compute_key async */
+#endif
+	0,                          /* flags    */
+	NULL                        /* app_data */
+#ifdef OPENSSL_QAT_ASYNCH
+	,qat_ecdh_generate_key_sync,  /* generate_key sync */
+	qat_ecdh_generate_key_async /* generate_key async */
+#endif
+};
+
+ECDH_METHOD *get_ECDH_methods(void)
+{
+
+#ifdef OPENSSL_DISABLE_QAT_ECDH_SYNCH
+#ifndef OPENSSL_DISABLE_QAT_ECDH_ASYNCH
+    const ECDH_METHOD* def_ecdh_meth = ECDH_get_default_method();
+
+    qat_ecdh_method.compute_key = def_ecdh_meth->compute_key;
+    qat_ecdh_method.generate_key = def_ecdh_meth->generate_key;
+#endif
+#endif 
+
+#ifdef OPENSSL_QAT_ASYNCH
+#ifndef OPENSSL_DISABLE_QAT_ECDH_SYNCH
+#ifdef OPENSSL_DISABLE_QAT_ECDH_ASYNCH
+    qat_ecdh_method.compute_key_asynch = NULL;
+    qat_ecdh_method.generate_key_asynch = NULL;
+#endif
+#endif 
+#endif
+
+#ifdef OPENSSL_DISABLE_QAT_ECDH_SYNCH
+#ifdef OPENSSL_DISABLE_QAT_ECDH_ASYNCH
+    return NULL;
+#endif
+#endif
+    return &qat_ecdh_method;
+}
+
+typedef struct ecdh_op_data
+{
+    BN_CTX *ctx;
+    CpaCyEcdhPointMultiplyOpData* ecdh_mul_op_data;
+    size_t outlenX;
+    size_t outlenY;
+    unsigned char* cb_outputX;
+    unsigned char* cb_outputY;
+    EC_KEY* ecdh;
+    void *(*KDF)(const void *in, size_t inlen, void *out, size_t *outlen);
+    int (*cb_func)(unsigned char *res, size_t reslen, void *cb_data, int status);
+    void *cb_data;
+} ecdh_op_data_t;
+
+/* Callback to indicate QAT completion of ECDH point multiply */
+void qat_ecdhCallbackFn(void *pCallbackTag, CpaStatus status, void *pOpData,
+     CpaBoolean multiplyStatus, CpaFlatBuffer *pXk, CpaFlatBuffer *pYk)
+
+{
+	qat_crypto_callbackFn(pCallbackTag, status, CPA_CY_SYM_OP_CIPHER, pOpData,
+			NULL, CPA_FALSE);
+}
+
+#ifdef OPENSSL_QAT_ASYNCH
+/* Async Callback function for ECDH point multiply */
+void qat_ecdhAsyncCallbackFn(void *pCallbackTag,
+							 CpaStatus status,
+							 void *pOpData,
+							 CpaBoolean multiplyStatus,
+							 CpaFlatBuffer *pXk,
+							 CpaFlatBuffer *pYk)
+{
+	BIGNUM *x_bn = NULL, *y_bn = NULL, *tx_bn = NULL, *ty_bn = NULL;
+	const EC_GROUP *group;
+	EC_POINT* pub_key = NULL;
+	ecdh_op_data_t* ecdh_async_data = (ecdh_op_data_t*)(pCallbackTag);
+	int cb_status = status == CPA_STATUS_SUCCESS ? 1 : 0;
+
+	if (!ecdh_async_data)
+	{
+		WARN("[%s] --- pCallbackTag NULL!\n",
+				__func__);
+		goto err;
+	}
+
+	/* Invoke the key derivative function */
+	if (ecdh_async_data->KDF != NULL)
+	{
+		if (ecdh_async_data->KDF(pXk->pData,
+								 pXk->dataLenInBytes,
+								 ecdh_async_data->cb_outputX,
+								 &ecdh_async_data->outlenX) == NULL)
+		{
+			QATerr(QAT_F_QAT_ECDHASYNCCALLBACKFN, QAT_R_ECDH_KDF_FAILED);
+			cb_status = CPA_STATUS_FAIL;
+		}
+	}
+	else
+	{
+		/* no KDF, just copy as much as we can */
+		if (ecdh_async_data->outlenX > pXk->dataLenInBytes)
+			ecdh_async_data->outlenX = pXk->dataLenInBytes;
+		memcpy(ecdh_async_data->cb_outputX, pXk->pData, ecdh_async_data->outlenX);
+
+
+		if(ecdh_async_data->cb_outputY != NULL)
+		{
+			if (ecdh_async_data->outlenY > pYk->dataLenInBytes)
+				ecdh_async_data->outlenY = pYk->dataLenInBytes;
+			memcpy(ecdh_async_data->cb_outputY, pYk->pData, ecdh_async_data->outlenY);
+		}
+	}
+
+	if (ecdh_async_data->cb_outputY != NULL)
+	{
+		if (((x_bn = BN_new()) == NULL) ||
+			((y_bn = BN_new()) == NULL) ||
+			((tx_bn = BN_new()) == NULL) ||
+			((ty_bn = BN_new()) == NULL))
+		{
+			QATerr(QAT_F_QAT_ECDHASYNCCALLBACKFN, QAT_R_MEM_ALLOC_FAILED);
+			cb_status = CPA_STATUS_FAIL;
+			goto err;
+		}
+
+		/* key gen case for now..... */
+		x_bn = BN_bin2bn(ecdh_async_data->cb_outputX, (int) ecdh_async_data->outlenX, NULL);
+		y_bn = BN_bin2bn(ecdh_async_data->cb_outputY, (int) ecdh_async_data->outlenY, NULL);
+
+		group = EC_KEY_get0_group(ecdh_async_data->ecdh);
+		pub_key = (EC_POINT *)EC_KEY_get0_public_key(ecdh_async_data->ecdh);
+		if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)
+		{
+			if (!EC_POINT_set_affine_coordinates_GFp(group, pub_key, x_bn, y_bn, ecdh_async_data->ctx))
+			{
+				QATerr(QAT_F_QAT_ECDHASYNCCALLBACKFN, QAT_R_ECDH_SET_AFFINE_COORD_FAILED);
+				cb_status = CPA_STATUS_FAIL;
+				goto err;
+			}
+			if (!EC_POINT_get_affine_coordinates_GFp(group, pub_key, tx_bn, ty_bn, ecdh_async_data->ctx))
+			{
+				QATerr(QAT_F_QAT_ECDHASYNCCALLBACKFN, QAT_R_ECDH_GET_AFFINE_COORD_FAILED);
+				cb_status = CPA_STATUS_FAIL;
+				goto err;
+			}
+
+			/* Check if retrieved coordinates match originals: if not values
+			 * are out of range.
+			 */
+			if (BN_cmp(x_bn, tx_bn) || BN_cmp(y_bn, ty_bn))
+			{
+				QATerr(QAT_F_QAT_ECDHASYNCCALLBACKFN, ERR_R_INTERNAL_ERROR);
+				cb_status = CPA_STATUS_FAIL;
+				goto err;
+			}
+		}
+		else
+		{
+			if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_characteristic_two_field)
+			{
+				if (!EC_POINT_set_affine_coordinates_GF2m(group, pub_key, x_bn, y_bn, ecdh_async_data->ctx))
+				{
+					QATerr(QAT_F_QAT_ECDHASYNCCALLBACKFN, QAT_R_ECDH_SET_AFFINE_COORD_FAILED);
+					cb_status = CPA_STATUS_FAIL;
+					goto err;
+				}
+				if (!EC_POINT_get_affine_coordinates_GF2m(group, pub_key, tx_bn, ty_bn, ecdh_async_data->ctx))
+				{
+					QATerr(QAT_F_QAT_ECDHASYNCCALLBACKFN, QAT_R_ECDH_GET_AFFINE_COORD_FAILED);
+					cb_status = CPA_STATUS_FAIL;
+					goto err;
+				}
+				if (BN_cmp(x_bn, tx_bn) || BN_cmp(y_bn, ty_bn))
+				{
+					QATerr(QAT_F_QAT_ECDHASYNCCALLBACKFN, ERR_R_INTERNAL_ERROR);
+					cb_status = CPA_STATUS_FAIL;
+					goto err;
+				}
+			}
+			else
+			{
+				QATerr(QAT_F_QAT_ECDHASYNCCALLBACKFN, QAT_R_ECDH_UNKNOWN_FIELD_TYPE);
+				cb_status = CPA_STATUS_FAIL;
+				goto err;
+			}
+		}
+	}
+err:
+	/* Invoke the user registered callback */
+	if (ecdh_async_data)
+		ecdh_async_data->cb_func(ecdh_async_data->cb_outputX,
+								 ecdh_async_data->outlenX,
+								 ecdh_async_data->cb_data,
+								 cb_status);
+
+	if (pXk)
+	{
+		if (pXk->pData)
+		{
+			qaeCryptoMemFree(pXk->pData);
+		}
+		OPENSSL_free(pXk);
+	}
+	if (pYk)
+	{
+		if (pYk->pData)
+		{
+			qaeCryptoMemFree(pYk->pData);
+		}
+		OPENSSL_free(pYk);
+	}
+
+	if (ecdh_async_data)
+	{
+		if (ecdh_async_data->cb_outputY != NULL)
+		{
+			OPENSSL_free(ecdh_async_data->cb_outputX);
+			if (x_bn != NULL)
+				BN_free(x_bn);
+			if (y_bn != NULL)
+				BN_free(y_bn);
+			if (tx_bn != NULL)
+				BN_free(tx_bn);
+			if (ty_bn != NULL)
+				BN_free(ty_bn);
+		}
+
+		if (ecdh_async_data->ecdh_mul_op_data)
+		{
+			if (ecdh_async_data->ecdh_mul_op_data->k.pData) qaeCryptoMemFree(ecdh_async_data->ecdh_mul_op_data->k.pData);
+			if (ecdh_async_data->ecdh_mul_op_data->xg.pData) qaeCryptoMemFree(ecdh_async_data->ecdh_mul_op_data->xg.pData);
+			if (ecdh_async_data->ecdh_mul_op_data->yg.pData) qaeCryptoMemFree(ecdh_async_data->ecdh_mul_op_data->yg.pData);
+			if (ecdh_async_data->ecdh_mul_op_data->a.pData) qaeCryptoMemFree(ecdh_async_data->ecdh_mul_op_data->a.pData);
+			if (ecdh_async_data->ecdh_mul_op_data->b.pData) qaeCryptoMemFree(ecdh_async_data->ecdh_mul_op_data->b.pData);
+			if (ecdh_async_data->ecdh_mul_op_data->q.pData) qaeCryptoMemFree(ecdh_async_data->ecdh_mul_op_data->q.pData);
+			OPENSSL_free(ecdh_async_data->ecdh_mul_op_data);
+		}
+		if (ecdh_async_data->ctx) BN_CTX_end(ecdh_async_data->ctx);
+		if (ecdh_async_data->ctx) BN_CTX_free(ecdh_async_data->ctx);
+		OPENSSL_free(ecdh_async_data);
+	}
+}
+#endif
+
+static int qat_ecdh_compute_key(void *outX, size_t outlenX, void *outY, size_t outlenY,
+								const EC_POINT *pub_key, EC_KEY *ecdh,
+								void *(*KDF)(const void *in, size_t inlen, void *out, size_t *outlen),
+								int (*cb)(unsigned char *res, size_t reslen,void *cb_data, int status),
+								void *cb_data)
+{
+	BN_CTX *ctx = NULL;
+	BIGNUM *p=NULL, *a=NULL, *b=NULL;
+	BIGNUM *xg=NULL, *yg=NULL;
+	const BIGNUM *priv_key;
+	const EC_GROUP* group;
+	int ret= -1, rc = 1;
+	size_t buflen;
+
+	CpaInstanceHandle instanceHandle;
+	CpaCyEcdhPointMultiplyOpData *opData = NULL;
+	CpaBoolean bEcdhStatus;
+	CpaFlatBuffer *pResultX = NULL;
+	CpaFlatBuffer *pResultY = NULL;
+	int qatPerformOpRetries = 0;
+	useconds_t ulPollInterval = getQatPollInterval();
+	int iMsgRetry = getQatMsgRetryCount();
+	CpaStatus status;
+	struct op_done op_done;
+#ifdef OPENSSL_QAT_ASYNCH
+	ecdh_op_data_t *ecdh_op_done = NULL;
+#endif
+
+	DEBUG("%s been called \n", __func__);
+	CRYPTO_QAT_LOG("KX - %s\n", __func__);
+
+	opData = (CpaCyEcdhPointMultiplyOpData *)OPENSSL_malloc(sizeof(CpaCyEcdhPointMultiplyOpData));
+	if (opData == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY,ERR_R_MALLOC_FAILURE);
+		return ret;
+	}
+
+	opData->k.pData  = NULL;
+	opData->xg.pData = NULL;
+	opData->yg.pData = NULL;
+	opData->a.pData  = NULL;
+	opData->b.pData  = NULL;
+	opData->q.pData  = NULL;
+
+	/* To instruct the Quickassist API not to use co-factor */
+	opData->h.pData= NULL;
+	opData->h.dataLenInBytes=0;
+
+        /* Populate the parameters required for ECDH point multiply */
+	if ((ctx = BN_CTX_new()) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY, ERR_R_MALLOC_FAILURE);
+		goto err;
+	}
+
+	BN_CTX_start(ctx);
+	if ((p = BN_CTX_get(ctx)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+	if ((a = BN_CTX_get(ctx)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+	if ((b = BN_CTX_get(ctx)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+	if ((xg = BN_CTX_get(ctx)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+	if ((yg = BN_CTX_get(ctx)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+
+	if (ecdh == NULL || (priv_key = EC_KEY_get0_private_key(ecdh)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY, ERR_R_PASSED_NULL_PARAMETER);
+		goto err;
+	}
+
+	if ((group = EC_KEY_get0_group(ecdh)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY, ERR_R_PASSED_NULL_PARAMETER);
+		goto err;
+	}
+
+	buflen = (EC_GROUP_get_degree(group) + 7)/8;
+	pResultX = (CpaFlatBuffer *)OPENSSL_malloc(sizeof(CpaFlatBuffer));
+	if (!pResultX)
+	{
+		QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY, ERR_R_MALLOC_FAILURE);
+		goto err;
+	}
+	pResultX->pData = qaeCryptoMemAlloc(buflen, __FILE__, __LINE__);
+	if (!pResultX->pData)
+	{
+		QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY, ERR_R_MALLOC_FAILURE);
+		goto err;
+	}
+	pResultX->dataLenInBytes = (Cpa32U) buflen;
+	pResultY = (CpaFlatBuffer *)OPENSSL_malloc(sizeof(CpaFlatBuffer));
+	if (!pResultY)
+	{
+		QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY, ERR_R_MALLOC_FAILURE);
+		goto err;
+	}
+	pResultY->pData = qaeCryptoMemAlloc(buflen, __FILE__, __LINE__);
+	if (!pResultY->pData)
+	{
+		QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY, ERR_R_MALLOC_FAILURE);
+		goto err;
+	}
+	pResultY->dataLenInBytes = (Cpa32U) buflen;
+
+	if ((qat_BN_to_FB(&(opData->k), (BIGNUM *)priv_key)) != 1)
+	{
+		QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+
+	if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)
+	{
+		if (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx))
+		{
+		 	QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY, ERR_R_INTERNAL_ERROR);
+		 	goto err;
+		}
+
+		if (!EC_POINT_get_affine_coordinates_GFp(group, pub_key, xg, yg, ctx))
+		{
+		 	QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY, ERR_R_INTERNAL_ERROR);
+		 	goto err;
+		}
+		opData->fieldType = CPA_CY_EC_FIELD_TYPE_PRIME;
+	}
+	else
+	{
+		if ((!EC_GROUP_get_curve_GF2m(group, p, a, b, ctx)) ||
+		    (!EC_POINT_get_affine_coordinates_GF2m(group, pub_key,
+												   xg, yg, ctx)))
+		{
+			QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY, ERR_R_INTERNAL_ERROR);
+			goto err;
+		}
+		opData->fieldType = CPA_CY_EC_FIELD_TYPE_BINARY;
+	}
+	if ((qat_BN_to_FB(&(opData->xg), xg) != 1) ||
+		(qat_BN_to_FB(&(opData->yg), yg) != 1) ||
+		(qat_BN_to_FB(&(opData->a), a) != 1))
+	{
+		QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+
+	/*
+	 * This is a special handling required for curves with 'a' co-efficient
+	 * of 0. The translation to a flatbuffer results in a zero sized field
+	 * but the Quickassist API expects a flatbuffer of size 1 with a value
+	 * of zero. As a special case we will create that manually.
+	 */
+	if (opData->a.pData == NULL && opData->a.dataLenInBytes == 0)
+	{
+		opData->a.pData = qaeCryptoMemAlloc(1, __FILE__, __LINE__);
+		opData->a.dataLenInBytes = 1;
+		if (opData->a.pData)
+		{
+			opData->a.pData[0] = 0;
+		}
+	}
+	if (( qat_BN_to_FB(&(opData->b), b) != 1) ||
+			( qat_BN_to_FB(&(opData->q), p) != 1))
+	{
+		QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+	opData->pointVerify = CPA_FALSE;
+
+	if (!cb)   /* Sync Mode */
+	{
+		initOpDone(&op_done);
+
+		/* Invoke the crypto engine API for ECDH */
+		do
+		{
+			if ((instanceHandle = get_next_inst()) == NULL)
+			{
+				QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY, ERR_R_INTERNAL_ERROR);
+				cleanupOpDone(&op_done);
+				goto err;
+			}
+
+			status = cpaCyEcdhPointMultiply(instanceHandle,
+											qat_ecdhCallbackFn,
+											&op_done,
+											opData,
+											&bEcdhStatus,
+											pResultX,
+											pResultY);
+
+			if (status == CPA_STATUS_RETRY)
+			{
+				usleep(ulPollInterval +
+					   (qatPerformOpRetries %
+						QAT_RETRY_BACKOFF_MODULO_DIVISOR));
+				qatPerformOpRetries++;
+			}
+		}
+		while(status == CPA_STATUS_RETRY &&
+			  ((qatPerformOpRetries < iMsgRetry) ||
+			   (iMsgRetry == QAT_INFINITE_MAX_NUM_RETRIES)));
+
+		if (status != CPA_STATUS_SUCCESS)
+		{
+			QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY, ERR_R_INTERNAL_ERROR);
+			cleanupOpDone(&op_done);
+			goto err;
+		}
+
+		rc = waitForOpToComplete(&op_done);
+		cleanupOpDone(&op_done);
+		if (rc)
+			goto err;
+
+		/* Invoke the key derivative function */
+		if (KDF != NULL)
+		{
+			if (KDF(pResultX->pData, pResultX->dataLenInBytes,
+					outX, &outlenX) == NULL)
+			{
+				QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY,
+					   QAT_R_ECDH_KDF_FAILED);
+				goto err;
+			}
+			ret = outlenX;
+		}
+		else
+		{
+			/* no KDF, just copy as much as we can */
+			if (outlenX > pResultX->dataLenInBytes)
+				outlenX = pResultX->dataLenInBytes;
+			memcpy(outX, pResultX->pData, outlenX);
+			ret = outlenX;
+
+			if (outY != NULL)
+			{
+				if (outlenY != pResultY->dataLenInBytes)
+				{
+					QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY, ERR_R_INTERNAL_ERROR);
+					goto err;
+				}
+				memcpy(outY, pResultY->pData, pResultY->dataLenInBytes);
+			}
+		}
+	}
+#ifdef OPENSSL_QAT_ASYNCH
+	else  /* Async mode */
+	{
+		ecdh_op_done = (ecdh_op_data_t *) OPENSSL_malloc(sizeof(ecdh_op_data_t));
+		if (ecdh_op_done == NULL)
+		{
+			QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY,ERR_R_MALLOC_FAILURE);
+			goto err;
+		}
+
+		ecdh_op_done->ctx = ctx;
+		ecdh_op_done->ecdh_mul_op_data = opData;
+		ecdh_op_done->KDF = KDF;
+		ecdh_op_done->cb_func = cb;
+		ecdh_op_done->cb_data = cb_data;
+		ecdh_op_done->ecdh = ecdh;
+		ecdh_op_done->cb_outputX = outX;
+		ecdh_op_done->cb_outputY = outY;
+		ecdh_op_done->outlenX = outlenX;
+		ecdh_op_done->outlenY = outlenX;
+
+		if ((instanceHandle = get_next_inst()) == NULL)
+		{
+			QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY,ERR_R_INTERNAL_ERROR);
+			OPENSSL_free(ecdh_op_done);
+			ret=0;
+			goto err;
+		}
+		status = cpaCyEcdhPointMultiply(instanceHandle,
+										qat_ecdhAsyncCallbackFn,
+										ecdh_op_done,
+										opData,
+										&bEcdhStatus,
+										pResultX,
+										pResultY);
+
+		if (status != CPA_STATUS_SUCCESS)
+		{
+			WARN("[%s] --- Async cpaCyEcdhPointMultiply failed, status=%d.\n", __func__, status);
+			if (status == CPA_STATUS_RETRY)
+			{
+				QATerr(QAT_F_QAT_ECDH_COMPUTE_KEY,ERR_R_RETRY);
+			}
+			OPENSSL_free(ecdh_op_done);
+			ret=0;
+			goto err;
+		}
+		return 1;
+	}
+#endif
+err:
+	if (pResultX)
+	{
+		if (pResultX->pData)
+		{
+			qaeCryptoMemFree(pResultX->pData);
+		}
+		OPENSSL_free(pResultX);
+	}
+	if (pResultY)
+	{
+		if (pResultY->pData)
+		{
+			qaeCryptoMemFree(pResultY->pData);
+		}
+		OPENSSL_free(pResultY);
+	}
+	if (opData->k.pData) qaeCryptoMemFree(opData->k.pData);
+	if (opData->xg.pData) qaeCryptoMemFree(opData->xg.pData);
+	if (opData->yg.pData) qaeCryptoMemFree(opData->yg.pData);
+	if (opData->a.pData) qaeCryptoMemFree(opData->a.pData);
+	if (opData->b.pData) qaeCryptoMemFree(opData->b.pData);
+	if (opData->q.pData) qaeCryptoMemFree(opData->q.pData);
+	if (opData) OPENSSL_free (opData);
+	if (ctx) BN_CTX_end(ctx);
+	if (ctx) BN_CTX_free(ctx);
+	return(ret);
+}
+
+static int qat_ecdh_compute_key_sync(void *out,
+									 size_t outlen,
+									 const EC_POINT *pub_key,
+									 EC_KEY *ecdh,
+									 void *(*KDF)(const void *in, size_t inlen, void *out, size_t *outlen))
+{
+	return qat_ecdh_compute_key(out, outlen, NULL, 0, pub_key, ecdh, KDF, NULL, NULL);
+}
+
+#ifdef OPENSSL_QAT_ASYNCH
+static int qat_ecdh_compute_key_async(void *out,
+									  size_t outlen,
+									  const EC_POINT *pub_key,
+									  EC_KEY *ecdh,
+									  void *(*KDF)(const void *in, size_t inlen, void *out, size_t *outlen),
+									  int (*cb)(unsigned char *res, size_t reslen,void *cb_data, int status),
+									  void *cb_data)
+{
+	if (!cb)
+	{
+		DEBUG("[%s] --- Invalid Parameter\n", __func__);
+		return 0;
+	}
+	return qat_ecdh_compute_key(out, outlen, NULL, 0, pub_key, ecdh, KDF, cb, cb_data);
+}
+#endif
+
+#ifdef OPENSSL_QAT_ASYNCH
+static int qat_ecdh_generate_key_sync(EC_KEY *ecdh)
+{
+	int ok = 0;
+	int alloc_priv = 0, alloc_pub = 0;
+	int field_size = 0;
+	BN_CTX *ctx = NULL;
+	BIGNUM *priv_key = NULL, *order = NULL, *x_bn = NULL, *y_bn = NULL, *tx_bn = NULL, *ty_bn = NULL;
+	EC_POINT *pub_key = NULL;
+	const EC_POINT *gen;
+	const EC_GROUP * group;
+	unsigned char * temp_buf = NULL;
+
+#ifdef OPENSSL_FIPS
+	if (FIPS_mode())
+		return FIPS_ec_key_generate_key(ecdh);
+#endif
+
+	if (!ecdh || !(group = EC_KEY_get0_group(ecdh)))
+	{
+		QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_SYNC, ERR_R_PASSED_NULL_PARAMETER);
+		return 0;
+	}
+
+	if (((order = BN_new()) == NULL) ||
+		((ctx = BN_CTX_new()) == NULL))
+	{
+		QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_SYNC, ERR_R_MALLOC_FAILURE);
+		goto err;
+	}
+	if ((priv_key = (BIGNUM *)EC_KEY_get0_private_key(ecdh)) == NULL)
+	{
+		priv_key = BN_new();
+		if (priv_key == NULL)
+		{
+			QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_SYNC, ERR_R_MALLOC_FAILURE);
+			goto err;
+		}
+		alloc_priv = 1;
+	}
+
+	if (!EC_GROUP_get_order(group, order, ctx))
+	{
+		QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_SYNC, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+	do
+		if (!BN_rand_range(priv_key, order))
+		{
+			QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_SYNC, ERR_R_INTERNAL_ERROR);
+			goto err;
+		}
+	while (BN_is_zero(priv_key));
+
+	if (alloc_priv)
+	{
+		if (!EC_KEY_set_private_key(ecdh, priv_key))
+		{
+			QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_SYNC, ERR_R_INTERNAL_ERROR);
+			goto err;
+		}
+	}
+
+	if ((pub_key = (EC_POINT *)EC_KEY_get0_public_key(ecdh)) == NULL)
+	{
+		pub_key = EC_POINT_new(group);
+		if (pub_key == NULL)
+		{
+			QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_SYNC, QAT_R_MEM_ALLOC_FAILED);
+			goto err;
+		}
+		alloc_pub = 1;
+	}
+
+	field_size = EC_GROUP_get_degree(group);
+	if (field_size <= 0)
+	{
+		QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_SYNC, QAT_R_FIELD_SIZE_ERROR);
+		goto err;
+	}
+	temp_buf = OPENSSL_malloc(2*((field_size+7)/8));
+	if(temp_buf == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_SYNC, QAT_R_MEM_ALLOC_FAILED);
+		goto err;
+	}
+	gen = EC_GROUP_get0_generator(group);
+
+	if (!qat_ecdh_compute_key(temp_buf,
+							  (field_size+7)/8,
+							  temp_buf+((field_size+7)/8),
+							  (field_size+7)/8,
+							  gen,
+							  ecdh,
+							  NULL,
+							  NULL,
+							  NULL))
+	{
+		/* No QATerr is raised here because errors are already handled in qat_ecdh_compute_key() */
+		goto err;
+	}
+
+	if (((x_bn = BN_new()) == NULL) ||
+		((y_bn = BN_new()) == NULL) ||
+		((tx_bn = BN_new()) == NULL) ||
+		((ty_bn = BN_new()) == NULL))
+	{
+		QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_SYNC, QAT_R_MEM_ALLOC_FAILED);
+		goto err;
+	}
+
+	x_bn = BN_bin2bn(temp_buf, (field_size+7)/8, NULL);
+	y_bn = BN_bin2bn((temp_buf+((field_size+7)/8)), (field_size+7)/8, NULL);
+	if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)
+	{
+		if (!EC_POINT_set_affine_coordinates_GFp(group, pub_key, x_bn, y_bn, ctx))
+		{
+			QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_SYNC, QAT_R_ECDH_SET_AFFINE_COORD_FAILED);
+			goto err;
+		}
+		if (!EC_POINT_get_affine_coordinates_GFp(group, pub_key, tx_bn, ty_bn, ctx))
+		{
+			QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_SYNC, QAT_R_ECDH_GET_AFFINE_COORD_FAILED);
+			goto err;
+		}
+
+		/* Check if retrieved coordinates match originals: if not values
+		 * are out of range.
+		 */
+		if (BN_cmp(x_bn, tx_bn) || BN_cmp(y_bn, ty_bn))
+		{
+			QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_SYNC, ERR_R_INTERNAL_ERROR);
+			goto err;
+		}
+		if (!EC_KEY_set_public_key(ecdh, pub_key))
+		{
+			QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_SYNC, ERR_R_INTERNAL_ERROR);
+			goto err;
+		}
+	}
+	else
+	{
+		if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_characteristic_two_field)
+		{
+			if (!EC_POINT_set_affine_coordinates_GF2m(group, pub_key, x_bn, y_bn, ctx))
+			{
+				QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_SYNC, QAT_R_ECDH_SET_AFFINE_COORD_FAILED);
+				goto err;
+			}
+			if (!EC_POINT_get_affine_coordinates_GF2m(group, pub_key, tx_bn, ty_bn, ctx))
+			{
+				QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_SYNC, QAT_R_ECDH_GET_AFFINE_COORD_FAILED);
+				goto err;
+			}
+			if (BN_cmp(x_bn, tx_bn) || BN_cmp(y_bn, ty_bn))
+			{
+				QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_SYNC, ERR_R_INTERNAL_ERROR);
+				goto err;
+			}
+			if (!EC_KEY_set_public_key(ecdh, pub_key))
+			{
+				QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_SYNC, ERR_R_INTERNAL_ERROR);
+				goto err;
+			}
+		}
+		else
+		{
+			QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_SYNC, QAT_R_ECDH_UNKNOWN_FIELD_TYPE);
+			goto err;
+		}
+	}
+	ok = 1;
+
+err:
+	if (order)
+		BN_free(order);
+	if (alloc_pub)
+		EC_POINT_free(pub_key);
+	if (alloc_priv)
+		BN_free(priv_key);
+	if (ctx != NULL)
+		BN_CTX_free(ctx);
+	if(temp_buf != NULL)
+		OPENSSL_free(temp_buf);
+	if(x_bn != NULL)
+	 	BN_free(x_bn);
+	if(y_bn != NULL)
+	 	BN_free(y_bn);
+	if(tx_bn != NULL)
+	 	BN_free(tx_bn);
+	if(ty_bn != NULL)
+	 	BN_free(ty_bn);
+	return(ok);
+}
+#endif
+
+#ifdef OPENSSL_QAT_ASYNCH
+static int qat_ecdh_generate_key_async(EC_KEY *ecdh,
+	   int (*cb)(unsigned char *res, size_t reslen,void *cb_data, int status),
+	   void *cb_data)
+{
+	int ok = 0;
+	int alloc_priv = 0, alloc_pub = 0;
+	int field_size = 0;
+	BN_CTX *ctx = NULL;
+	BIGNUM *priv_key = NULL, *order = NULL;
+	EC_POINT *pub_key = NULL;
+	const EC_POINT *gen;
+	const EC_GROUP *group;
+	char * temp_buf;
+
+#ifdef OPENSSL_FIPS
+	if (FIPS_mode())
+		return FIPS_ec_key_generate_key(ecdh);
+#endif
+
+	if (!ecdh || !(group = EC_KEY_get0_group(ecdh)))
+	{
+		QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_ASYNC, QAT_R_INVALID_INPUT_PARAMETER);
+		return 0;
+	}
+
+	if (((order = BN_new()) == NULL) ||
+		((ctx = BN_CTX_new()) == NULL))
+	{
+		QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_ASYNC, QAT_R_MEM_ALLOC_FAILED);
+		goto err;
+	}
+	if ((priv_key = (BIGNUM *)EC_KEY_get0_private_key(ecdh)) == NULL)
+	{
+		priv_key = BN_new();
+		if (priv_key == NULL)
+		{
+			QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_ASYNC, QAT_R_MEM_ALLOC_FAILED);
+			goto err;
+		}
+		alloc_priv = 1;
+	}
+
+	if (!EC_GROUP_get_order(group, order, ctx))
+	{
+		QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_ASYNC, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+	do
+		if (!BN_rand_range(priv_key, order))
+		{
+			QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_ASYNC, ERR_R_INTERNAL_ERROR);
+			goto err;
+		}
+	while (BN_is_zero(priv_key));
+
+	if (alloc_priv)
+	{
+		if (!EC_KEY_set_private_key(ecdh, priv_key))
+		{
+			QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_ASYNC, ERR_R_INTERNAL_ERROR);
+			goto err;
+		}
+	}
+
+	if ((pub_key = (EC_POINT *)EC_KEY_get0_public_key(ecdh)) == NULL)
+	{
+		pub_key = EC_POINT_new(group);
+		if (pub_key == NULL)
+		{
+			QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_ASYNC, QAT_R_MEM_ALLOC_FAILED);
+			goto err;
+		}
+		alloc_pub = 1;
+	}
+	field_size = EC_GROUP_get_degree(group);
+	if (field_size <= 0)
+	{
+		QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_ASYNC, QAT_R_FIELD_SIZE_ERROR);
+		goto err;
+	}
+	temp_buf = OPENSSL_malloc(2*((field_size+7)/8));
+	if (temp_buf == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_ASYNC, QAT_R_MEM_ALLOC_FAILED);
+		goto err;
+	}
+	gen = EC_GROUP_get0_generator(group);
+
+	if (alloc_pub)
+	{
+		if (!EC_KEY_set_public_key(ecdh, pub_key))
+		{
+			QATerr(QAT_F_QAT_ECDH_GENERATE_KEY_ASYNC, ERR_R_INTERNAL_ERROR);
+			goto err;
+		}
+	}
+	if (!qat_ecdh_compute_key(temp_buf,
+							  (field_size+7)/8,
+							  temp_buf+((field_size+7)/8),
+							  (field_size+7)/8,
+							  gen,
+							  ecdh,
+							  NULL,
+							  cb,
+							  cb_data))
+	{
+		/* No QATerr is raised here because errors are already handled in qat_ecdh_compute_key() */
+		/* In particular, if ERR_R_RETRY is raised as an error in qat_ecdh_compute_key() then it mustn't be */
+        /* 'overwritten' by raising a different QATerr here. */
+		goto err;
+	}
+	ok = 1;
+err:
+	if (order)
+		BN_free(order);
+	if (alloc_pub)
+		EC_POINT_free(pub_key);
+	if (alloc_priv)
+		BN_free(priv_key);
+	if (ctx != NULL)
+		BN_CTX_free(ctx);
+
+	return(ok);
+}
+#endif
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_ecdh.h ./engines/qat_engine/qat_ecdh.h
--- ../openssl-async/engines/qat_engine/qat_ecdh.h	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_ecdh.h	2015-03-05 12:43:44.252962000 +0000
@@ -0,0 +1,66 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+  */
+
+/*****************************************************************************
+ * @file qat_ecdh.h
+ *
+ * This file provides an interface to Elliptical Curve Diffie Hellman 
+ * operations
+ *
+ *****************************************************************************/
+
+#ifndef QAT_ECDH_H
+#define QAT_ECDH_H
+
+#include <openssl/ecdh.h>
+#include <openssl/ossl_typ.h>
+
+ECDH_METHOD *get_ECDH_methods(void);
+
+#endif //QAT_ECDH_H
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_ecdsa.c ./engines/qat_engine/qat_ecdsa.c
--- ../openssl-async/engines/qat_engine/qat_ecdsa.c	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_ecdsa.c	2015-03-05 12:43:44.254956000 +0000
@@ -0,0 +1,1132 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qat_ecdsa.c
+ *
+ * This file provides support for ECDSA
+ *
+ *****************************************************************************/
+
+#include "ecs_locl.h"
+#include <string.h>
+#include <unistd.h>
+#include <openssl/err.h>
+#include <openssl/obj_mac.h>
+#include <openssl/bn.h>
+#include "cpa.h"
+#include "cpa_types.h"
+#include "cpa_cy_ec.h"
+#include "cpa_cy_ecdsa.h"
+#include "e_qat.h"
+#include "qat_asym_common.h"
+#ifdef USE_QAT_MEM
+#include "qae_mem_utils.h"
+#endif
+#ifdef USE_QAE_MEM
+#include "qat_mem_drv_inf.h"
+#endif
+#include "e_qat_err.h"
+#include "qat_utils.h"
+#include "qat_ecdsa.h"
+
+#ifdef OPENSSL_ENABLE_QAT_ECDSA_SYNCH
+#ifdef OPENSSL_DISABLE_QAT_ECDSA_SYNCH
+#undef OPENSSL_DISABLE_QAT_ECDSA_SYNCH
+#endif
+#endif
+
+#ifdef OPENSSL_ENABLE_QAT_ECDSA_ASYNCH
+#ifdef OPENSSL_DISABLE_QAT_ECDSA_ASYNCH
+#undef OPENSSL_DISABLE_QAT_ECDSA_ASYNCH
+#endif
+#endif
+
+#ifndef OPENSSL_QAT_ASYNCH
+#define OPENSSL_DISABLE_QAT_ECDSA_ASYNCH
+#endif
+
+static ECDSA_SIG *qat_ecdsa_do_sign(const unsigned char *dgst, int dlen,
+		const BIGNUM *, const BIGNUM *, EC_KEY *eckey,
+                unsigned char *sig, unsigned int *siglen,
+                int (*cb)(unsigned char *res, size_t reslen, void *cb_data, int status),
+                void *cb_data);
+static int qat_ecdsa_do_verify(const unsigned char *dgst, int dgst_len,
+		const ECDSA_SIG *sig, EC_KEY *eckey,
+                int (*cb)(void *cb_data, int status), void *cb_data);
+
+static ECDSA_SIG *qat_ecdsa_do_sign_sync(const unsigned char *dgst, int dgst_len,
+                const BIGNUM *in_kinv, const BIGNUM *in_r, EC_KEY *eckey);
+
+#ifdef OPENSSL_QAT_ASYNCH
+static ECDSA_SIG *qat_ecdsa_do_sign_asynch(const unsigned char *dgst, int dgst_len,
+                const BIGNUM *in_kinv, const BIGNUM *in_r, EC_KEY *eckey,
+                unsigned char *sig, unsigned int *siglen,
+                int (*cb)(unsigned char *res, size_t reslen, void *cb_data, int status),
+                void *cb_data);
+#endif
+
+static int qat_ecdsa_do_verify_sync(const unsigned char *dgst, int dgst_len,
+                const ECDSA_SIG *sig, EC_KEY *eckey);
+
+#ifdef OPENSSL_QAT_ASYNCH
+static int qat_ecdsa_do_verify_asynch(const unsigned char *dgst, int dgst_len,
+                const ECDSA_SIG *sig, EC_KEY *eckey,
+                int (*cb)(void *cb_data, int status), void *cb_data);
+#endif
+
+static ECDSA_METHOD qat_ecdsa_method = {
+	"QAT ECDSA method",
+	qat_ecdsa_do_sign_sync,
+	NULL,
+	qat_ecdsa_do_verify_sync,
+#ifdef OPENSSL_QAT_ASYNCH
+        qat_ecdsa_do_sign_asynch,
+        qat_ecdsa_do_verify_asynch,
+#endif
+	0, /* flags    */
+	NULL  /* app_data */
+};
+
+ECDSA_METHOD *get_ECDSA_methods(void)
+{
+#ifdef OPENSSL_DISABLE_QAT_ECDSA_SYNCH
+#ifndef OPENSSL_DISABLE_QAT_ECDSA_ASYNCH
+	const ECDSA_METHOD* def_ecdsa_meth = ECDSA_get_default_method();
+
+        qat_ecdsa_method.ecdsa_do_sign    = def_ecdsa_meth->ecdsa_do_sign;
+        qat_ecdsa_method.ecdsa_sign_setup = def_ecdsa_meth->ecdsa_sign_setup;
+        qat_ecdsa_method.ecdsa_do_verify  = def_ecdsa_meth->ecdsa_do_verify;
+#endif
+#endif
+
+#ifdef OPENSSL_QAT_ASYNCH
+#ifndef OPENSSL_DISABLE_QAT_ECDSA_SYNCH
+#ifdef OPENSSL_DISABLE_QAT_ECDSA_ASYNCH
+        qat_ecdsa_method.ecdsa_do_sign_asynch    = NULL;
+        qat_ecdsa_method.ecdsa_do_verify_asynch  = NULL;
+#endif
+#endif
+#endif
+
+#ifdef OPENSSL_DISABLE_QAT_ECDSA_SYNCH
+#ifdef OPENSSL_DISABLE_QAT_ECDSA_ASYNCH
+	return NULL;
+#endif
+#endif
+	return &qat_ecdsa_method;
+}
+
+typedef struct ecdsa_sign_op_data
+{
+    BN_CTX *ctx;
+    unsigned char *sig;
+    unsigned int *siglen;
+    CpaCyEcdsaSignRSOpData* sign_op_data;
+    int (*cb_func)(unsigned char *res,  size_t reslen, void *cb_data, int status);
+    void *cb_data;
+} ecdsa_sign_op_data_t;
+
+typedef struct ecdsa_verify_op_data
+{
+    BN_CTX *ctx;
+    CpaCyEcdsaVerifyOpData* verify_op_data;
+    int (*cb_func)(void *cb_data, int status);
+    void *cb_data;
+} ecdsa_verify_op_data_t;
+
+/* Callback to indicate QAT sync completion of ECDSA Sign */
+void qat_ecdsaSignCallbackFn(void *pCallbackTag, CpaStatus status, void *pOpData,
+     CpaBoolean bEcdsaSignStatus, CpaFlatBuffer *pResultR, CpaFlatBuffer *pResultS)
+
+{
+        qat_crypto_callbackFn(pCallbackTag, status, CPA_CY_SYM_OP_CIPHER, pOpData,
+                        NULL, CPA_FALSE);
+}
+
+#ifdef OPENSSL_QAT_ASYNCH
+/* Callback to indicate QAT async completion of ECDSA Sign */
+void qat_ecdsaAsyncSignCallbackFn(void *pCallbackTag, CpaStatus status, void *pOpData,
+     CpaBoolean bEcdsaSignStatus, CpaFlatBuffer *pResultR, CpaFlatBuffer *pResultS)
+
+{
+	ECDSA_SIG  *ret=NULL;
+	ecdsa_sign_op_data_t* sign_async_data = (ecdsa_sign_op_data_t*) (pCallbackTag);
+	int cb_status = status == CPA_STATUS_SUCCESS ? 1 : 0;
+
+	if (!sign_async_data)
+	{
+		WARN("[%s] --- pCallbackTag NULL!\n", __func__);
+		goto err;
+	}
+
+	ret = ECDSA_SIG_new();
+	if (!ret)
+	{
+                WARN("[%s] --- ECDSA_SIG_new() failed!\n", __func__);
+		goto err;
+	}
+
+	/* Convert the flatbuffer results back to a BN */
+	BN_bin2bn(pResultR->pData, pResultR->dataLenInBytes, ret->r);
+	BN_bin2bn(pResultS->pData, pResultS->dataLenInBytes, ret->s);
+
+	*sign_async_data->siglen = i2d_ECDSA_SIG(ret, &sign_async_data->sig);
+
+	/* Invoke the user registered callback */
+	sign_async_data->cb_func(sign_async_data->sig, *sign_async_data->siglen, sign_async_data->cb_data, cb_status);
+
+err:
+	if (pResultR)
+	{
+		if (pResultR->pData)
+		{
+			qaeCryptoMemFree(pResultR->pData);
+		}
+		OPENSSL_free(pResultR);
+	}
+	if (pResultS)
+	{
+		if (pResultS->pData)
+		{
+			qaeCryptoMemFree(pResultS->pData);
+		}
+		OPENSSL_free(pResultS);
+	}
+
+	if (ret)
+		ECDSA_SIG_free(ret);
+
+	if (sign_async_data)
+	{
+		if (sign_async_data->sign_op_data)
+		{
+			if (sign_async_data->sign_op_data->k.pData) qaeCryptoMemFree(sign_async_data->sign_op_data->k.pData);
+			if (sign_async_data->sign_op_data->n.pData) qaeCryptoMemFree(sign_async_data->sign_op_data->n.pData);
+			if (sign_async_data->sign_op_data->m.pData) qaeCryptoMemFree(sign_async_data->sign_op_data->m.pData);
+			if (sign_async_data->sign_op_data->d.pData) qaeCryptoMemFree(sign_async_data->sign_op_data->d.pData);
+			if (sign_async_data->sign_op_data->xg.pData) qaeCryptoMemFree(sign_async_data->sign_op_data->xg.pData);
+			if (sign_async_data->sign_op_data->yg.pData) qaeCryptoMemFree(sign_async_data->sign_op_data->yg.pData);
+			if (sign_async_data->sign_op_data->a.pData) qaeCryptoMemFree(sign_async_data->sign_op_data->a.pData);
+			if (sign_async_data->sign_op_data->b.pData) qaeCryptoMemFree(sign_async_data->sign_op_data->b.pData);
+			if (sign_async_data->sign_op_data->q.pData) qaeCryptoMemFree(sign_async_data->sign_op_data->q.pData);
+			OPENSSL_free (sign_async_data->sign_op_data);
+		}
+
+		if (sign_async_data->ctx) BN_CTX_end(sign_async_data->ctx);
+		if (sign_async_data->ctx) BN_CTX_free(sign_async_data->ctx);
+		OPENSSL_free (sign_async_data);
+	}
+}
+#endif
+
+/* Callback to indicate QAT sync completion of ECDSA Verify */
+void qat_ecdsaVerifyCallbackFn(void *pCallbackTag, CpaStatus status, void *pOpData,
+     CpaBoolean bEcdsaVerifyStatus)
+
+{
+        qat_crypto_callbackFn(pCallbackTag, status, CPA_CY_SYM_OP_CIPHER, pOpData,
+                        NULL, bEcdsaVerifyStatus);
+}
+
+#ifdef OPENSSL_QAT_ASYNCH
+/* Callback to indicate QAT async completion of ECDSA Verify */
+void qat_ecdsaAsyncVerifyCallbackFn(void *pCallbackTag, CpaStatus status, void *pOpData,
+     CpaBoolean bEcdsaVerifyStatus)
+
+{
+	ecdsa_verify_op_data_t* verify_async_data = (ecdsa_verify_op_data_t*) (pCallbackTag);
+        int cb_status = bEcdsaVerifyStatus == CPA_TRUE ? 1 : 0;
+
+	if (!verify_async_data)
+	{
+		WARN("[%s] --- pCallbackTag NULL!\n", __func__);
+		goto err;
+	}
+
+	/* Invoke the user registered callback */
+	verify_async_data->cb_func(verify_async_data->cb_data, cb_status);
+
+err:
+	if (verify_async_data)
+	{
+		if (verify_async_data->verify_op_data)
+		{
+			if (verify_async_data->verify_op_data->r.pData) qaeCryptoMemFree(verify_async_data->verify_op_data->r.pData);
+			if (verify_async_data->verify_op_data->s.pData) qaeCryptoMemFree(verify_async_data->verify_op_data->s.pData);
+			if (verify_async_data->verify_op_data->n.pData) qaeCryptoMemFree(verify_async_data->verify_op_data->n.pData);
+			if (verify_async_data->verify_op_data->m.pData) qaeCryptoMemFree(verify_async_data->verify_op_data->m.pData);
+			if (verify_async_data->verify_op_data->xg.pData) qaeCryptoMemFree(verify_async_data->verify_op_data->xg.pData);
+			if (verify_async_data->verify_op_data->yg.pData) qaeCryptoMemFree(verify_async_data->verify_op_data->yg.pData);
+			if (verify_async_data->verify_op_data->a.pData) qaeCryptoMemFree(verify_async_data->verify_op_data->a.pData);
+			if (verify_async_data->verify_op_data->b.pData) qaeCryptoMemFree(verify_async_data->verify_op_data->b.pData);
+			if (verify_async_data->verify_op_data->q.pData) qaeCryptoMemFree(verify_async_data->verify_op_data->q.pData);
+			OPENSSL_free (verify_async_data->verify_op_data);
+		}
+
+		if (verify_async_data->ctx) BN_CTX_end(verify_async_data->ctx);
+		if (verify_async_data->ctx) BN_CTX_free(verify_async_data->ctx);
+		OPENSSL_free (verify_async_data);
+	}
+}
+#endif
+
+static ECDSA_SIG *qat_ecdsa_do_sign(const unsigned char *dgst, int dgst_len,
+		const BIGNUM *in_kinv, const BIGNUM *in_r, EC_KEY *eckey,
+                unsigned char *sig, unsigned int *siglen,
+                int (*cb)(unsigned char *res,  size_t reslen, void *cb_data, int status),
+                void *cb_data)
+{
+        int     ok = 0, i, rc = 1;
+	BIGNUM *m=NULL,*order=NULL;
+	BN_CTX     *ctx = NULL;
+	const EC_GROUP   *group;
+	ECDSA_SIG  *ret=NULL;
+	ECDSA_DATA *ecdsa;
+	const BIGNUM *priv_key;
+	BIGNUM *p=NULL, *a=NULL, *b=NULL, *k=NULL, *r=NULL;
+	BIGNUM *xg=NULL, *yg=NULL;
+	const EC_POINT *pub_key=NULL;
+
+	CpaFlatBuffer *pResultR=NULL;
+	CpaFlatBuffer *pResultS=NULL;
+	CpaInstanceHandle instanceHandle;
+	CpaCyEcdsaSignRSOpData *opData=NULL;
+	CpaBoolean bEcdsaSignStatus;
+	CpaStatus status;
+	size_t buflen;
+	struct op_done op_done;
+	int qatPerformOpRetries = 0;
+	useconds_t ulPollInterval = getQatPollInterval();
+	int iMsgRetry = getQatMsgRetryCount();
+	const EC_POINT *ec_point=NULL;
+#ifdef OPENSSL_QAT_ASYNCH
+        ecdsa_sign_op_data_t *ecdsa_op_done=NULL;
+#endif
+
+    DEBUG("[%s] --- called.\n", __func__);
+    CRYPTO_QAT_LOG("AU - %s\n", __func__);
+
+	ecdsa    = ecdsa_check(eckey);
+	group    = EC_KEY_get0_group(eckey);
+	priv_key = EC_KEY_get0_private_key(eckey);
+	pub_key  = EC_KEY_get0_public_key(eckey);
+
+	if (group == NULL || priv_key == NULL || ecdsa == NULL || pub_key == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_PASSED_NULL_PARAMETER);
+		return ret;
+	}
+
+	if ((ec_point = EC_GROUP_get0_generator(group)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_EC_LIB);
+		return ret;
+	}
+
+	opData = (CpaCyEcdsaSignRSOpData *)OPENSSL_malloc(sizeof(CpaCyEcdsaSignRSOpData));
+	if (opData == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_MALLOC_FAILURE);
+		return ret;
+	}
+
+        memset(opData, 0, sizeof(CpaCyEcdsaSignRSOpData));
+
+	ret = ECDSA_SIG_new();
+	if (!ret)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_MALLOC_FAILURE);
+		goto err;
+	}
+
+	if ((ctx = BN_CTX_new()) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_MALLOC_FAILURE);
+		goto err;
+	}
+
+	BN_CTX_start(ctx);
+
+	if ((p = BN_CTX_get(ctx)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+	if ((a = BN_CTX_get(ctx)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+	if ((b = BN_CTX_get(ctx)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+	if ((xg = BN_CTX_get(ctx)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+	if ((yg = BN_CTX_get(ctx)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+	if ((m = BN_CTX_get(ctx)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+	if ((k = BN_CTX_get(ctx)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+	if ((r = BN_CTX_get(ctx)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+	if ((order = BN_CTX_get(ctx)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+
+	if ((qat_BN_to_FB(&(opData->d), (BIGNUM *)priv_key)) != 1)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+	if (!EC_GROUP_get_order(group, order, ctx))
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_EC_LIB);
+		goto err;
+	}
+	i = BN_num_bits(order);
+
+        /* Need to truncate digest if it is too long: first truncate whole bytes. */
+	if (8 * dgst_len > i)
+		dgst_len = (i + 7)/8;
+
+	if (!BN_bin2bn(dgst, dgst_len, m))
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_BN_LIB);
+		goto err;
+	}
+
+        /* If still too long truncate remaining bits with a shift */
+	if ((8 * dgst_len > i) && !BN_rshift(m, m, 8 - (i & 0x7)))
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_BN_LIB);
+		goto err;
+	}
+
+	if ((qat_BN_to_FB(&(opData->m), (BIGNUM *)m)) != 1)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+
+	do
+		if (!BN_rand_range(k, order))
+		{
+			QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+			goto err;
+		}
+	while (BN_is_zero(k));
+
+	if (EC_METHOD_get_field_type(EC_GROUP_method_of(group))
+			== NID_X9_62_prime_field)
+	{
+		if ((!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ||
+				(!EC_POINT_get_affine_coordinates_GFp(group, ec_point,
+								      xg, yg, ctx)))
+		{
+			QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+			goto err;
+		}
+		opData->fieldType = CPA_CY_EC_FIELD_TYPE_PRIME;
+	}
+	else
+	{
+		if ((!EC_GROUP_get_curve_GF2m(group, p, a, b, ctx)) ||
+				(!EC_POINT_get_affine_coordinates_GF2m(group, ec_point,
+								       xg, yg, ctx)))
+		{
+			QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+			goto err;
+		}
+		opData->fieldType = CPA_CY_EC_FIELD_TYPE_BINARY;
+	}
+
+
+	if ((qat_BN_to_FB(&(opData->xg), xg) != 1) ||
+			(qat_BN_to_FB(&(opData->yg), yg) != 1) ||
+			(qat_BN_to_FB(&(opData->a), a) != 1))
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+
+	/*
+	 * This is a special handling required for curves with 'a' co-efficient
+	 * of 0. The translation to a flatbuffer results in a zero sized field
+	 * but the Quickassist API expects a flatbuffer of size 1 with a value
+	 * of zero. As a special case we will create that manually.
+	 */
+	if (opData->a.pData == NULL && opData->a.dataLenInBytes == 0)
+	{
+		opData->a.pData = qaeCryptoMemAlloc(1, __FILE__, __LINE__);
+		opData->a.dataLenInBytes = 1;
+		if (opData->a.pData)
+		{
+			opData->a.pData[0] = 0;
+		}
+	}
+
+	if (( qat_BN_to_FB(&(opData->b), b) != 1) ||
+			( qat_BN_to_FB(&(opData->q), p) != 1))
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+
+	if (in_kinv == NULL || in_r == NULL)
+	{
+		if ((qat_BN_to_FB(&(opData->k), (BIGNUM *)k)) != 1)
+		{
+			QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+			goto err;
+		}
+
+		if ((qat_BN_to_FB(&(opData->n), (BIGNUM *)order)) != 1)
+		{
+			QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+			goto err;
+		}
+
+	}
+	else
+	{
+		if ((qat_BN_to_FB(&(opData->k), (BIGNUM *)in_kinv)) != 1)
+		{
+			QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+			goto err;
+		}
+
+		if ((qat_BN_to_FB(&(opData->n), (BIGNUM *)in_r)) != 1)
+		{
+			QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+			goto err;
+		}
+
+	}
+
+	buflen = EC_GROUP_get_degree(group);
+	pResultR = (CpaFlatBuffer *)OPENSSL_malloc(sizeof(CpaFlatBuffer));
+	if (!pResultR)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_MALLOC_FAILURE);
+		goto err;
+	}
+	pResultR->pData = qaeCryptoMemAlloc(buflen, __FILE__, __LINE__);
+	if (!pResultR->pData)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_MALLOC_FAILURE);
+		goto err;
+	}
+	pResultR->dataLenInBytes = (Cpa32U) buflen;
+	pResultS = (CpaFlatBuffer *)OPENSSL_malloc(sizeof(CpaFlatBuffer));
+	if (!pResultS)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_MALLOC_FAILURE);
+		goto err;
+	}
+	pResultS->pData = qaeCryptoMemAlloc(buflen, __FILE__, __LINE__);
+	if (!pResultS->pData)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_MALLOC_FAILURE);
+		goto err;
+	}
+	pResultS->dataLenInBytes = (Cpa32U) buflen;
+
+        if (!cb) /* Sync Mode */
+	{
+		/* perform ECDSA sign */
+		initOpDone(&op_done);
+
+		do
+		{
+			if ((instanceHandle = get_next_inst()) == NULL)
+			{
+				QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+				cleanupOpDone(&op_done);
+				goto err;
+			}
+
+			status = cpaCyEcdsaSignRS(instanceHandle,
+					qat_ecdsaSignCallbackFn,
+					&op_done,
+					opData,
+					&bEcdsaSignStatus,
+					pResultR,
+					pResultS);
+
+			if (status == CPA_STATUS_RETRY)
+			{
+				usleep(ulPollInterval +
+						(qatPerformOpRetries %
+						 QAT_RETRY_BACKOFF_MODULO_DIVISOR));
+				qatPerformOpRetries++;
+			}
+		}
+		while(status == CPA_STATUS_RETRY &&
+				((qatPerformOpRetries < iMsgRetry) ||
+				 (iMsgRetry == QAT_INFINITE_MAX_NUM_RETRIES)));
+
+		if (status != CPA_STATUS_SUCCESS)
+		{
+			QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+			cleanupOpDone(&op_done);
+			goto err;
+		}
+
+		rc = waitForOpToComplete(&op_done);
+		cleanupOpDone(&op_done);
+		if (rc)
+			goto err;
+
+		/* Convert the flatbuffer results back to a BN */
+		BN_bin2bn(pResultR->pData, pResultR->dataLenInBytes, ret->r);
+		BN_bin2bn(pResultS->pData, pResultS->dataLenInBytes, ret->s);
+
+		ok = 1;
+	}
+#ifdef OPENSSL_QAT_ASYNCH
+        else /* Async Mode */
+	{
+		ecdsa_op_done = (ecdsa_sign_op_data_t *) OPENSSL_malloc(sizeof(ecdsa_sign_op_data_t));
+		if (ecdsa_op_done == NULL)
+		{
+			QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_MALLOC_FAILURE);
+                        goto err;
+		}
+
+		ecdsa_op_done->ctx = ctx;
+                ecdsa_op_done->sig = sig;
+                ecdsa_op_done->siglen = siglen;
+		ecdsa_op_done->sign_op_data = opData;
+		ecdsa_op_done->cb_func = cb;
+		ecdsa_op_done->cb_data = cb_data;
+
+		if ((instanceHandle = get_next_inst()) == NULL)
+		{
+			QATerr(QAT_F_QAT_ECDSA_DO_SIGN, ERR_R_INTERNAL_ERROR);
+			OPENSSL_free(ecdsa_op_done);
+                        goto err;
+		}
+
+		status = cpaCyEcdsaSignRS(instanceHandle,
+				qat_ecdsaAsyncSignCallbackFn,
+				ecdsa_op_done,
+				opData,
+				&bEcdsaSignStatus,
+				pResultR,
+				pResultS);
+
+		if (status != CPA_STATUS_SUCCESS)
+		{
+                        WARN("[%s] --- Async cpaCyEcdsaSignRS, status=%d.\n", __func__, status);
+                        if (status == CPA_STATUS_RETRY)
+                        {
+                            QATerr(QAT_F_QAT_ECDSA_DO_SIGN,ERR_R_RETRY);
+                        }
+                        OPENSSL_free(ecdsa_op_done);
+			goto err;
+		}
+		return ret;
+	}
+#endif
+
+err:
+	if (!ok)
+	{
+		ECDSA_SIG_free(ret);
+		ret = NULL;
+	}
+
+	if (pResultR)
+	{
+		if (pResultR->pData)
+		{
+			qaeCryptoMemFree(pResultR->pData);
+		}
+		OPENSSL_free(pResultR);
+	}
+	if (pResultS)
+	{
+		if (pResultS->pData)
+		{
+			qaeCryptoMemFree(pResultS->pData);
+		}
+		OPENSSL_free(pResultS);
+	}
+
+	if (opData)
+	{
+		if (opData->k.pData) qaeCryptoMemFree(opData->k.pData);
+		if (opData->n.pData) qaeCryptoMemFree(opData->n.pData);
+		if (opData->m.pData) qaeCryptoMemFree(opData->m.pData);
+		if (opData->d.pData) qaeCryptoMemFree(opData->d.pData);
+		if (opData->xg.pData) qaeCryptoMemFree(opData->xg.pData);
+		if (opData->yg.pData) qaeCryptoMemFree(opData->yg.pData);
+		if (opData->a.pData) qaeCryptoMemFree(opData->a.pData);
+		if (opData->b.pData) qaeCryptoMemFree(opData->b.pData);
+		if (opData->q.pData) qaeCryptoMemFree(opData->q.pData);
+		OPENSSL_free (opData);
+	}
+
+	if (ctx) BN_CTX_end(ctx);
+	if (ctx) BN_CTX_free(ctx);
+	return ret;
+}
+
+static ECDSA_SIG *qat_ecdsa_do_sign_sync(const unsigned char *dgst, int dgst_len,
+                const BIGNUM *in_kinv, const BIGNUM *in_r, EC_KEY *eckey)
+{
+	return qat_ecdsa_do_sign(dgst, dgst_len, in_kinv, in_r, eckey, NULL, NULL, NULL, NULL);
+
+}
+
+#ifdef OPENSSL_QAT_ASYNCH
+static ECDSA_SIG *qat_ecdsa_do_sign_asynch(const unsigned char *dgst, int dgst_len,
+                const BIGNUM *in_kinv, const BIGNUM *in_r, EC_KEY *eckey,
+                unsigned char *sig, unsigned int *siglen,
+                int (*cb)(unsigned char *res, size_t reslen, void *cb_data, int status),
+                void *cb_data)
+{
+	if (!cb)
+	{
+		DEBUG("[%s] --- Invalid Parameter\n", __func__);
+		return 0;
+	}
+
+	return qat_ecdsa_do_sign(dgst, dgst_len, in_kinv, in_r, eckey, sig, siglen, cb, cb_data);
+}
+#endif
+
+static int qat_ecdsa_do_verify(const unsigned char *dgst, int dgst_len,
+		const ECDSA_SIG *sig, EC_KEY *eckey,
+                int (*cb)(void *cb_data, int status), void *cb_data)
+{
+        int ret = -1, i, rc = 1;
+	BN_CTX   *ctx=NULL;
+	BIGNUM   *order=NULL, *m=NULL;
+	const EC_GROUP *group;
+	const EC_POINT *pub_key;
+	BIGNUM *p=NULL, *a=NULL, *b=NULL;
+	BIGNUM *xg=NULL, *yg=NULL, *xp=NULL, *yp=NULL;
+	const EC_POINT *ec_point;
+
+	CpaInstanceHandle instanceHandle;
+	CpaCyEcdsaVerifyOpData *opData=NULL;
+	CpaBoolean bEcdsaVerifyStatus;
+	CpaStatus status;
+	struct op_done op_done;
+	int qatPerformOpRetries = 0;
+	useconds_t ulPollInterval = getQatPollInterval();
+	int iMsgRetry = getQatMsgRetryCount();
+#ifdef OPENSSL_QAT_ASYNCH
+        ecdsa_verify_op_data_t *ecdsa_op_done=NULL;
+#endif
+
+	DEBUG("%s been called \n", __func__);
+	CRYPTO_QAT_LOG("AU - %s\n", __func__);
+
+	/* check input values */
+	if (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL ||
+			(pub_key = EC_KEY_get0_public_key(eckey)) == NULL || sig == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		return ret;
+	}
+
+	if ((ec_point = EC_GROUP_get0_generator(group)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_EC_LIB);
+		return ret;
+	}
+
+	opData = (CpaCyEcdsaVerifyOpData *)OPENSSL_malloc(sizeof(CpaCyEcdsaVerifyOpData));
+	if (opData == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_MALLOC_FAILURE);
+		return ret;
+	}
+
+        memset(opData, 0, sizeof(CpaCyEcdsaVerifyOpData));
+
+	if ((ctx = BN_CTX_new()) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_MALLOC_FAILURE);
+		goto err;
+	}
+
+	BN_CTX_start(ctx);
+
+	if ((p = BN_CTX_get(ctx)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+	if ((a = BN_CTX_get(ctx)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+	if ((b = BN_CTX_get(ctx)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+	if ((xg = BN_CTX_get(ctx)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+	if ((yg = BN_CTX_get(ctx)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+	if ((xp = BN_CTX_get(ctx)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+	if ((yp = BN_CTX_get(ctx)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+	if ((m = BN_CTX_get(ctx)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+	if ((order = BN_CTX_get(ctx)) == NULL)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+
+	if (!EC_GROUP_get_order(group, order, ctx))
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_EC_LIB);
+		goto err;
+	}
+
+	if (BN_is_zero(sig->r)          || BN_is_negative(sig->r) ||
+			BN_ucmp(sig->r, order) >= 0 || BN_is_zero(sig->s)  ||
+			BN_is_negative(sig->s)      || BN_ucmp(sig->s, order) >= 0)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		ret = 0;	/* signature is invalid */
+		goto err;
+	}
+	/* digest -> m */
+	i = BN_num_bits(order);
+        /* Need to truncate digest if it is too long: first truncate whole bytes. */
+	if (8 * dgst_len > i)
+		dgst_len = (i + 7)/8;
+
+	if (!BN_bin2bn(dgst, dgst_len, m))
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_BN_LIB);
+		goto err;
+	}
+        /* If still too long truncate remaining bits with a shift */
+	if ((8 * dgst_len > i) && !BN_rshift(m, m, 8 - (i & 0x7)))
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_BN_LIB);
+		goto err;
+	}
+
+	if ((qat_BN_to_FB(&(opData->m), (BIGNUM *)m)) != 1)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+
+	if (EC_METHOD_get_field_type(EC_GROUP_method_of(group))
+			== NID_X9_62_prime_field)
+	{
+		if ((!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ||
+				(!EC_POINT_get_affine_coordinates_GFp(group, ec_point,
+								      xg, yg, ctx)) ||
+				(!EC_POINT_get_affine_coordinates_GFp(group, pub_key,
+								      xp, yp, ctx)))
+		{
+			QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+			goto err;
+		}
+		opData->fieldType = CPA_CY_EC_FIELD_TYPE_PRIME;
+	}
+	else
+	{
+		if ((!EC_GROUP_get_curve_GF2m(group, p, a, b, ctx)) ||
+				(!EC_POINT_get_affine_coordinates_GF2m(group, ec_point,
+								       xg, yg, ctx)) ||
+				(!EC_POINT_get_affine_coordinates_GF2m(group, pub_key,
+								       xp, yp, ctx)))
+		{
+			QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+			goto err;
+		}
+		opData->fieldType = CPA_CY_EC_FIELD_TYPE_BINARY;
+	}
+
+	if ((qat_BN_to_FB(&(opData->xg), xg) != 1) ||
+			(qat_BN_to_FB(&(opData->yg), yg) != 1) ||
+			(qat_BN_to_FB(&(opData->a), a) != 1))
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+
+	/*
+	 * This is a special handling required for curves with 'a' co-efficient
+	 * of 0. The translation to a flatbuffer results in a zero sized field
+	 * but the Quickassist API expects a flatbuffer of size 1 with a value
+	 * of zero. As a special case we will create that manually.
+	 */
+
+	if (opData->a.pData == NULL && opData->a.dataLenInBytes == 0)
+	{
+		opData->a.pData = qaeCryptoMemAlloc(1, __FILE__, __LINE__);
+		opData->a.dataLenInBytes = 1;
+		if (opData->a.pData)
+		{
+			opData->a.pData[0] = 0;
+		}
+	}
+
+	if (( qat_BN_to_FB(&(opData->b), b) != 1) ||
+			( qat_BN_to_FB(&(opData->q), p) != 1))
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+
+	if ((qat_BN_to_FB(&(opData->n), (BIGNUM *)order)) != 1)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+
+	if ((qat_BN_to_FB(&(opData->r), (BIGNUM *)sig->r)) != 1)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+
+	if ((qat_BN_to_FB(&(opData->s), (BIGNUM *)sig->s)) != 1)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+
+	if ((qat_BN_to_FB(&(opData->xp), (BIGNUM *)xp)) != 1)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+
+	if ((qat_BN_to_FB(&(opData->yp), (BIGNUM *)yp)) != 1)
+	{
+		QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+		goto err;
+	}
+
+        if (!cb) /* Sync Mode */
+	{
+		/* perform ECDSA verify */
+		initOpDone(&op_done);
+
+		do
+		{
+			if ((instanceHandle = get_next_inst()) == NULL)
+			{
+				QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+				cleanupOpDone(&op_done);
+				goto err;
+			}
+
+			status = cpaCyEcdsaVerify(instanceHandle,
+					qat_ecdsaVerifyCallbackFn,
+					&op_done,
+					opData,
+					&bEcdsaVerifyStatus);
+
+			if (status == CPA_STATUS_RETRY)
+			{
+				usleep(ulPollInterval +
+						(qatPerformOpRetries %
+						 QAT_RETRY_BACKOFF_MODULO_DIVISOR));
+				qatPerformOpRetries++;
+			}
+		}
+		while(status == CPA_STATUS_RETRY &&
+				((qatPerformOpRetries < iMsgRetry) ||
+				 (iMsgRetry == QAT_INFINITE_MAX_NUM_RETRIES)));
+
+		if (status != CPA_STATUS_SUCCESS)
+		{
+			QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+			cleanupOpDone(&op_done);
+			goto err;
+		}
+
+		rc = waitForOpToComplete(&op_done);
+
+		if (op_done.verifyResult == CPA_TRUE)
+			ret=1;
+
+		cleanupOpDone(&op_done);
+		if (rc) {
+			ret = -1;
+			goto err;
+		}
+	}
+#ifdef OPENSSL_QAT_ASYNCH
+        else /* Async mode */
+	{
+		ecdsa_op_done = (ecdsa_verify_op_data_t *) OPENSSL_malloc(sizeof(ecdsa_verify_op_data_t));
+		if (ecdsa_op_done == NULL)
+		{
+			QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_MALLOC_FAILURE);
+                        goto err;
+		}
+
+		ecdsa_op_done->ctx = ctx;
+		ecdsa_op_done->verify_op_data = opData;
+		ecdsa_op_done->cb_func = cb;
+		ecdsa_op_done->cb_data = cb_data;
+
+		if ((instanceHandle = get_next_inst()) == NULL)
+		{
+			QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_INTERNAL_ERROR);
+			OPENSSL_free(ecdsa_op_done);
+                        goto err;
+		}
+
+		status = cpaCyEcdsaVerify(instanceHandle,
+				qat_ecdsaAsyncVerifyCallbackFn,
+				ecdsa_op_done,
+				opData,
+				&bEcdsaVerifyStatus);
+
+		if (status != CPA_STATUS_SUCCESS)
+		{
+                        WARN("[%s] --- Async cpaCyEcdsaVerify, status=%d.\n", __func__, status);
+                        if (status == CPA_STATUS_RETRY)
+			{
+				QATerr(QAT_F_QAT_ECDSA_DO_VERIFY, ERR_R_RETRY);
+			}
+			OPENSSL_free(ecdsa_op_done);
+                        ret=0;
+			goto err;
+		}
+                ret = 1;
+		return ret;
+	}
+#endif
+
+err:
+	if (opData)
+	{
+		if (opData->r.pData) qaeCryptoMemFree(opData->r.pData);
+		if (opData->s.pData) qaeCryptoMemFree(opData->s.pData);
+		if (opData->n.pData) qaeCryptoMemFree(opData->n.pData);
+		if (opData->m.pData) qaeCryptoMemFree(opData->m.pData);
+		if (opData->xg.pData) qaeCryptoMemFree(opData->xg.pData);
+		if (opData->yg.pData) qaeCryptoMemFree(opData->yg.pData);
+		if (opData->a.pData) qaeCryptoMemFree(opData->a.pData);
+		if (opData->b.pData) qaeCryptoMemFree(opData->b.pData);
+		if (opData->q.pData) qaeCryptoMemFree(opData->q.pData);
+		OPENSSL_free (opData);
+	}
+
+	if (ctx) BN_CTX_end(ctx);
+	if (ctx) BN_CTX_free(ctx);
+	return ret;
+}
+
+static int qat_ecdsa_do_verify_sync(const unsigned char *dgst, int dgst_len,
+                const ECDSA_SIG *sig, EC_KEY *eckey)
+{
+	return qat_ecdsa_do_verify(dgst, dgst_len, sig, eckey, NULL, NULL);
+}
+
+#ifdef OPENSSL_QAT_ASYNCH
+static int qat_ecdsa_do_verify_asynch(const unsigned char *dgst, int dgst_len,
+                const ECDSA_SIG *sig, EC_KEY *eckey,
+                int (*cb)(void *cb_data, int status), void *cb_data)
+{
+	if (!cb)
+	{
+		DEBUG("[%s] --- Invalid Parameter\n", __func__);
+		return 0;
+	}
+
+        return qat_ecdsa_do_verify(dgst, dgst_len, sig, eckey, cb, cb_data);
+}
+#endif
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_ecdsa.h ./engines/qat_engine/qat_ecdsa.h
--- ../openssl-async/engines/qat_engine/qat_ecdsa.h	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_ecdsa.h	2015-03-05 12:43:44.266956000 +0000
@@ -0,0 +1,64 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+  */
+
+/*****************************************************************************
+ * @file qat_ecdsa.h
+ *
+ * This file provides an interface to ECDSA operations 
+ *
+ *****************************************************************************/
+
+#ifndef QAT_ECDSA_H
+#define QAT_ECDSA_H
+
+#include <openssl/ecdsa.h>
+
+ECDSA_METHOD *get_ECDSA_methods(void);
+
+#endif /* QAT_ECDSA_H */
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_mem/LICENSE.GPL ./engines/qat_engine/qat_mem/LICENSE.GPL
--- ../openssl-async/engines/qat_engine/qat_mem/LICENSE.GPL	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_mem/LICENSE.GPL	2015-03-05 12:43:44.268956000 +0000
@@ -0,0 +1,339 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_mem/Makefile ./engines/qat_engine/qat_mem/Makefile
--- ../openssl-async/engines/qat_engine/qat_mem/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_mem/Makefile	2015-03-05 12:43:44.269957000 +0000
@@ -0,0 +1,53 @@
+# set your module name here
+# provide the following files
+#
+# MODULENAME.c	the driver
+# MODULENAME.h  the include file
+# MODULENAME_test.c	the driver test program
+# MODULENAME_test.sh	the driver test script
+#
+MODULENAME 	:= qat_mem
+### should not need to change stuff below ######################
+
+
+KDIR		:= /lib/modules/$(shell uname -r)/build
+#KDIR		:= /exports/linux-2.6.12.2/
+PWD		:= $(shell pwd)
+
+ifeq ($(shell uname -r|grep -c grsec-WR), 1)
+AUTO_CONF=/lib/modules/$(shell uname -r)/build/include/generated/autoconf.h
+else
+AUTO_CONF=/usr/src/kernels/$(shell uname -r)/include/linux/autoconf.h
+endif
+
+ifdef KERNEL_SOURCE_ROOT
+AUTO_CONF=$(KERNEL_SOURCE_ROOT)/include/linux/autoconf.h
+KDIR=$(KERNEL_SOURCE_ROOT)
+endif
+
+CC		:= gcc -Wall -imacros $(AUTO_CONF)
+
+ifeq ($(KERNELRELEASE),)
+all:	$(MODULENAME)_test
+all:
+	$(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules
+else
+  obj-m	:= $(MODULENAME).o
+endif
+
+$(MODULENAME)_test: $(MODULENAME)_test.c
+	$(CC) -g -o $(MODULENAME)_test $(MODULENAME)_test.c
+
+
+load:
+	insmod ./$(MODULENAME).ko
+
+unload:
+	rmmod $(MODULENAME)
+
+test: all
+	./$(MODULENAME)_test.sh
+
+clean:
+	rm -f *.o *.ko Modules.symvers *.mod.c .*.cmd $(MODULENAME)_test
+
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_mem/qat_mem.c ./engines/qat_engine/qat_mem/qat_mem.c
--- ../openssl-async/engines/qat_engine/qat_mem/qat_mem.c	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_mem/qat_mem.c	2015-03-05 12:43:44.270959000 +0000
@@ -0,0 +1,548 @@
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007-2014 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011,2012,2013,2014 Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/mm.h>
+#include <asm/io.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+
+#include "qat_mem.h"
+
+#define PAGE_ORDER 5
+#define MAX_MEM_ALLOC (PAGE_SIZE * (2 << PAGE_ORDER) - sizeof(qat_mem_config))
+
+static int major;
+static unsigned long bytesToPageOrder(long int memSize);
+
+module_param(major, int, S_IRUGO);
+
+/**
+ *****************************************************************************
+ * @description
+ *      This structure contains data relating to the device driver that this
+ *      file implements
+ *
+ ****************************************************************************/
+typedef struct chr_drv_info_s {
+    struct module          *owner;
+    unsigned               major;
+    unsigned               min_minor;
+    unsigned               max_minor;
+    char                   *name;
+    struct file_operations *file_ops;
+    struct cdev            drv_cdev;
+    struct class           *drv_class;
+    struct device          *drv_class_dev;
+} chr_drv_info_t;
+
+
+
+#define DEV_MEM_NAME            "qat_mem"
+#define DEV_MEM_MAJOR           0
+#define DEV_MEM_MAX_MINOR       4
+#define DEV_MEM_BASE_MINOR      0
+#define FAIL                    1
+#define SUCCESS                 0
+#define FREE(ptr) kfree(ptr)
+
+/******************************************************************************
+* function:
+*         qat_mem_read(struct file *filp, char __user *buffer, size_t length,
+*         	       loff_t *offset)
+*
+* @param filp   [IN] - unused
+* @param buffer [IN] - unused
+* @param length [IN] - unused
+* @param offset [IN] - unused
+*
+* description:
+*   Callback for read operations on the device node. We don't support them.
+*
+******************************************************************************/
+static ssize_t qat_mem_read(struct file *filp, char __user * buffer,
+                            size_t length, loff_t * offset)
+{
+    return -EIO;
+}
+
+/******************************************************************************
+* function:
+*         qat_mem_write(struct file *filp, char __user *buffer, size_t length,
+*         	       loff_t *offset)
+*
+* @param filp [IN] - unused
+* @param buff [IN] - unused
+* @param leng [IN] - unused
+* @param off  [IN] - unused
+*
+* description:
+*   Callback for write operations on the device node. We don't support them.
+*
+******************************************************************************/
+static ssize_t qat_mem_write(struct file *filp, const char __user * buff,
+                             size_t len, loff_t * off)
+{
+    return -EIO;
+}
+
+/*
+ * driver open function
+ */
+static int
+qat_mem_open(struct inode *inp, struct file *fp)
+{
+    return 0;
+}
+
+/*
+ * driver close/release function
+ */
+static int
+qat_mem_release(struct inode *inp, struct file *fp)
+{
+    return 0;
+}
+
+
+/******************************************************************************
+* function:
+*         do_ioctl(qat_mem_config *mem, unsigned int cmd, unsigned long arg)
+*
+* @param mem [IN] - pointer to mem structure
+* @param cmd [IN] - ioctl number requested 
+* @param arg [IN] - any arg needed by ioctl implementaion 
+*
+* description:
+*   Callback for ioctl operations on the device node. This is our control path.
+*   We support two ioctls, QAT_MEM_MALLOC and QAT_MEM_FREE.
+*
+******************************************************************************/
+static int do_ioctl(qat_mem_config * mem, unsigned int cmd, unsigned long arg)
+{
+
+    switch (cmd)
+    {
+        case QAT_MEM_MALLOC:
+            if (mem->length <= 0)
+            {
+                printk
+                    ("%s: invalid inputs in qat_mem_config structure!\n",
+                     __func__);
+                return -EINVAL;
+            }
+
+            if (mem->length > MAX_MEM_ALLOC)
+            {
+                printk
+                    ("%s: memory requested (%d) greater than max allocation (%ld)\n",
+                     __func__, mem->length, MAX_MEM_ALLOC);
+                return -EINVAL;
+            }
+            mem->virtualAddress =
+                (uintptr_t) __get_free_pages(GFP_KERNEL,
+                                             bytesToPageOrder(mem->length));
+            if (mem->virtualAddress == (uintptr_t) 0)
+            {
+                printk("%s: __get_free_pages() failed\n", __func__);
+                return -EINVAL;
+            }
+
+            mem->physicalAddress =
+                (uintptr_t) virt_to_phys((void *)(mem->virtualAddress));
+            mem->signature = QAT_MEM_ALLOC_SIG;
+            memcpy((unsigned char *)mem->virtualAddress, mem, sizeof(*mem));
+
+            if (copy_to_user((void *)arg, mem, sizeof(*mem)))
+            {
+                printk("%s: copy_to_user failed\n", __func__);
+                return -EFAULT;
+            }
+            break;
+
+        case QAT_MEM_FREE:
+            if ((void *)mem->virtualAddress == NULL)
+            {
+                printk
+                    ("%s: invalid inputs in qat_mem_config structure !\n",
+                     __func__);
+                return -EINVAL;
+            }
+
+            free_pages((unsigned long)mem->virtualAddress,
+                       bytesToPageOrder(mem->length));
+            break;
+
+        default:
+            printk("%s: unknown request\n", __func__);
+            return -ENOTTY;
+    }
+
+    return 0;
+
+}
+
+/******************************************************************************
+* function:
+*         qat_mem_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+*
+* @param file [IN] - unused
+* @param cmd  [IN] - ioctl number requested
+* @param arg  [IN] - any arg needed by the ioctl implementation
+*
+* description:
+*   Parameter-check the ioctl call before calling do_ioctl() to do the actual
+*   work.
+*
+* @see do_ioctl()
+*
+******************************************************************************/
+static long
+qat_mem_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+    qat_mem_config mem;
+
+    if (_IOC_SIZE(cmd) != sizeof(mem))
+    {
+        printk("%s: invalid parameter length\n", __func__);
+        return -EINVAL;
+    }
+    if (copy_from_user(&mem, (unsigned char *)arg, sizeof(mem)))
+    {
+        printk("%s: copy_from_user failed\n", __func__);
+        return -EFAULT;
+    }
+
+    return do_ioctl(&mem, cmd, arg);
+}
+
+/******************************************************************************
+* function:
+*         qat_mem_mmap(struct file *filp, struct vm_area_struct *vma)
+*
+* @param filp [IN]    - unused
+* @param vma  [INOUT] - struct containing details of the requested mmap, and
+*                       also the resulting offset
+*
+* description:
+*   Callback for mmap operations on the device node. This is identical to the
+*   /dev/kmem device on some Linux distros, but others have removed this for
+*   security reasons so we have to re-implement it.
+*
+******************************************************************************/
+static int qat_mem_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+    int ret = 0;
+    unsigned long pfn;
+    /* Convert the vm_pgoff page frame number to an address, then a physical
+       address, then convert it back to a page frame number. The final result
+       of this is to ensure that pfn is a _physical_ page frame number */
+    pfn = __pa((u64) vma->vm_pgoff << PAGE_SHIFT) >> PAGE_SHIFT;
+    if (!pfn_valid(pfn))
+    {
+        printk("%s: invalid pfn\n", __func__);
+        return -EIO;
+    }
+    vma->vm_pgoff = pfn;
+    ret = remap_pfn_range(vma,
+                          vma->vm_start,
+                          vma->vm_pgoff,
+                          vma->vm_end - vma->vm_start,
+                          vma->vm_page_prot);
+    if (ret != 0) {
+        printk("%s: remap_pfn_range failed, returned %d\n", __func__, ret);
+    }
+    return ret;
+}
+
+
+/*
+ * structure describing device function mappings
+ */
+static struct file_operations mem_ops = {
+        owner:THIS_MODULE,
+        mmap:qat_mem_mmap,
+        read:qat_mem_read,
+        write:qat_mem_write,
+        unlocked_ioctl:qat_mem_ioctl,
+        open:qat_mem_open,
+        release:qat_mem_release,
+};
+
+/*
+ * instantiation of the driver
+ */
+static chr_drv_info_t mem_drv_info = {
+        owner:THIS_MODULE,
+        major:DEV_MEM_MAJOR,
+        min_minor:DEV_MEM_BASE_MINOR,
+        max_minor:DEV_MEM_MAX_MINOR,
+        name:DEV_MEM_NAME,
+        file_ops:&mem_ops,
+};
+
+/*
+ * create the device driver class
+ */
+static int
+chr_drv_create_class(chr_drv_info_t* drv_info)
+{
+    if (NULL == drv_info)
+    {
+        printk("chr_drv_create_class(): parameter is NULL\n");
+        return FAIL;
+    }
+
+    drv_info->drv_class = class_create(THIS_MODULE, drv_info->name);
+    if (IS_ERR(drv_info->drv_class))
+    {
+        printk("class_create failed\n");
+        return FAIL;
+    }
+    return SUCCESS;
+}
+
+/*
+ * destroy the device driver class
+ */
+static void
+chr_drv_destroy_class(chr_drv_info_t* drv_info)
+{
+    if (NULL == drv_info)
+    {
+        printk("chr_drv_destroy_class(): parameter is NULL\n");
+        return; 
+    }
+    class_destroy( drv_info->drv_class );
+}
+
+/*
+ * destroy the device driver
+ */
+static void
+chr_drv_destroy_device(chr_drv_info_t *drv_info)
+{
+    if (NULL == drv_info)
+    {
+        printk("chr_drv_destroy(): parameter is NULL\n");
+        return; 
+    }
+
+    if (NULL != drv_info->drv_class_dev)
+    {
+        device_destroy(drv_info->drv_class, MKDEV(drv_info->major,
+                drv_info->min_minor));
+    }
+    cdev_del(&(drv_info->drv_cdev));
+    unregister_chrdev_region( MKDEV(drv_info->major, drv_info->min_minor),
+            drv_info->max_minor);
+}
+
+
+/*
+ * create the device driver
+ */
+static int
+chr_drv_create_device(chr_drv_info_t *drv_info)
+{
+    int ret = 0;
+    dev_t devid = 0;
+
+    if (NULL == drv_info)
+    {
+        printk("chr_drv_create_device(): parameter is NULL\n");
+        return FAIL;
+    }
+
+    ret = alloc_chrdev_region(&devid,
+            drv_info->min_minor,
+            drv_info->max_minor,
+            drv_info->name);
+
+    if (ret < 0)
+    {
+        printk("%s:%d unable to allocate chrdev region\n", __func__,__LINE__);
+        return FAIL;
+    }
+
+    drv_info->major = MAJOR(devid);
+    cdev_init(&(drv_info->drv_cdev), drv_info->file_ops);
+    drv_info->drv_cdev.owner = drv_info->owner;
+
+    ret = cdev_add(&(drv_info->drv_cdev), devid, drv_info->max_minor);
+    if (ret < 0)
+    {
+        printk("%s:%d cdev add failed\n", __func__,__LINE__);
+        chr_drv_destroy_device(drv_info);
+        return FAIL;
+    }
+
+    drv_info->drv_class_dev = device_create(drv_info->drv_class,
+            NULL, MKDEV(drv_info->major, drv_info->min_minor),
+            NULL, drv_info->name);
+
+    if( NULL == drv_info->drv_class_dev )
+    {
+        printk("%s:%d chr_drv_create_device: device_create failed\n",
+                __func__,__LINE__);
+        chr_drv_destroy_device(drv_info);
+        return FAIL;
+    }
+    return SUCCESS;
+}
+
+/*
+ * register the device driver
+ */
+int register_mem_device_driver(void)
+{
+    int ret = 0;
+
+    ret = chr_drv_create_class(&mem_drv_info);
+    if (SUCCESS != ret)
+    {
+        printk("%s:%d failed to create device driver class\n",
+                __func__,__LINE__);
+        return FAIL;
+    }
+    ret = chr_drv_create_device(&mem_drv_info);
+    if (SUCCESS != ret)
+    {
+        printk("%s:%d failed to create mem numa device driver\n",
+                __func__,__LINE__);
+        chr_drv_destroy_class(&mem_drv_info);
+        return FAIL;
+    }
+    return SUCCESS;
+}
+
+/*
+ * unregister the device driver
+ */
+
+void unregister_mem_device_driver(void)
+{
+    chr_drv_destroy_device(&mem_drv_info);
+    chr_drv_destroy_class(&mem_drv_info);
+}
+
+/******************************************************************************
+* function:
+*         bytesToPageOrder(long int memSize)
+*
+* @param memSize [IN] - number of bytes requested
+*
+* description:
+*   Return the ln2 of the number of pages needed to store memSize bytes.
+*
+******************************************************************************/
+static unsigned long bytesToPageOrder(long int memSize)
+{
+    if (memSize <= PAGE_SIZE)
+        return 0;
+    else if (memSize <= PAGE_SIZE * 1 << 1)
+        return 1;
+    else if (memSize <= PAGE_SIZE * 1 << 2)
+        return 2;
+    else if (memSize <= PAGE_SIZE * 1 << 3)
+        return 3;
+    else if (memSize <= PAGE_SIZE * 1 << 4)
+        return 4;
+    else if (memSize <= PAGE_SIZE * 1 << 5)
+        return 5;
+    else
+        return -1;
+}
+
+/*
+ * Initialization function to insmod device driver
+ */
+int qat_mem_init( void )
+{
+
+    printk( "Loading QAT MEM Module ...\n" ) ;
+    if(SUCCESS != register_mem_device_driver())
+    {
+        printk("Error loading QAT MEM Module\n");
+        return FAIL;
+    }
+    return SUCCESS;
+}
+
+/*
+ * tear down function to rmmod device driver
+ */
+void qat_mem_exit( void )
+{
+    printk("Unloading QAT MEM Module ...\n" ) ;
+    unregister_mem_device_driver();
+}
+
+
+module_init(qat_mem_init);
+module_exit(qat_mem_exit);
+MODULE_AUTHOR("Intel Corporation");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("QAT Mem");
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_mem/qat_mem.h ./engines/qat_engine/qat_mem/qat_mem.h
--- ../openssl-async/engines/qat_engine/qat_mem/qat_mem.h	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_mem/qat_mem.h	2015-03-05 12:43:44.271964000 +0000
@@ -0,0 +1,83 @@
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007-2012 Intel Corporation. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011,2012 Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+#ifndef __QAT_MEM_H
+#define __QAT_MEM_H
+
+#include <asm/ioctl.h>
+
+#ifndef __KERNEL__
+#include <stdint.h>
+#endif
+
+typedef struct _qat_mem_config {
+	uint32_t signature;
+	uintptr_t virtualAddress;
+	int length;
+	uintptr_t physicalAddress;
+} qat_mem_config;
+
+#define QAT_MEM_MAGIC    0x95
+#define QAT_MEM_ALLOC_SIG 0xDEADBEEF
+#define QAT_MEM_MALLOC  _IOWR(QAT_MEM_MAGIC, 0, qat_mem_config)
+#define QAT_MEM_FREE    _IOW(QAT_MEM_MAGIC, 2, qat_mem_config)
+
+#endif
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_mem/qat_mem_test.c ./engines/qat_engine/qat_mem/qat_mem_test.c
--- ../openssl-async/engines/qat_engine/qat_mem/qat_mem_test.c	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_mem/qat_mem_test.c	2015-03-05 12:43:44.272960000 +0000
@@ -0,0 +1,126 @@
+/***************************************************************************
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ *   redistributing this file, you may do so under either license.
+ *
+ *   GPL LICENSE SUMMARY
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011,2012,2013,2014 Intel Corporation.
+ *   All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of version 2 of the GNU General Public License as
+ *   published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *   The full GNU General Public License is included in this distribution
+ *   in the file called LICENSE.GPL.
+ *
+ *   Contact Information:
+ *   Intel Corporation
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2007,2008,2009,2010,2011,2012,2013,2014 Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ *
+ ***************************************************************************/
+#define _XOPEN_SOURCE 600
+
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+/* Linux doesn't conform to the POSIX standard here:
+ * #include <stropts.h> */
+#include <sys/ioctl.h>
+
+#include <sys/mman.h>
+#include <unistd.h>
+#include <string.h>
+#include "qat_mem.h"
+
+#define SEG_LEN 64
+
+/******************************************************************************
+* function:
+*         main(void)
+*
+* description:
+*   Entry point.
+*
+******************************************************************************/
+int main(void)
+{
+	int qat_memfd = -1;
+	qat_mem_config qmcfg;
+	void *addr = MAP_FAILED;
+	qat_mem_config *mem_to_free=NULL;
+
+	if ((qat_memfd = open("/dev/qat_mem", O_RDWR)) == -1) {
+		perror("open qat_mem");
+		goto cleanup;
+	}
+	qmcfg.length = SEG_LEN;
+	if (ioctl(qat_memfd, QAT_MEM_MALLOC, &qmcfg) == -1) {
+		perror("ioctl QAT_MEM_MALLOC");
+		goto cleanup;
+	}
+
+	if ((addr =
+	     mmap(NULL, SEG_LEN, PROT_READ | PROT_WRITE, MAP_PRIVATE, qat_memfd,
+		  qmcfg.virtualAddress)) == MAP_FAILED) {
+		perror("mmap");
+		goto cleanup;
+	}
+	mem_to_free = addr;
+        printf("seg mapped to %p, virtualAddress in seg %p, length %d\n", addr,
+               (void *)mem_to_free->virtualAddress, mem_to_free->length);
+	strcpy(addr + sizeof(qat_mem_config), "Hello World!");
+	puts(addr + sizeof(qat_mem_config));
+ cleanup:
+	if (qat_memfd != -1 && mem_to_free !=NULL 
+            && ioctl(qat_memfd, QAT_MEM_FREE, mem_to_free) == -1)
+		perror("ioctl QAT_MEM_FREE");
+	if (addr != MAP_FAILED && munmap(addr, SEG_LEN) == -1)
+		perror("munmap");
+	if (qat_memfd != -1 && close(qat_memfd) == -1)
+		perror("close qat_mem");
+	exit(EXIT_SUCCESS);
+}
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_mem_drv_inf.c ./engines/qat_engine/qat_mem_drv_inf.c
--- ../openssl-async/engines/qat_engine/qat_mem_drv_inf.c	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_mem_drv_inf.c	2015-03-05 12:43:44.273964000 +0000
@@ -0,0 +1,252 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qat_mem_drv_inf.c
+ *
+ * This file provides an interface to use a memory driver to provide contig
+ * pinned memory.
+ *
+ *****************************************************************************/
+
+#include <stdio.h>
+#include <pthread.h>
+#include <string.h>
+#include "qat_utils.h"
+#include "qat_mem_drv_inf.h"
+#include "qae_mem.h"
+
+static int mem_inited = 0;
+static int ref_count = 0;
+static pthread_mutex_t mem_mutex = PTHREAD_MUTEX_INITIALIZER;
+static CpaStatus qaeCryptoMemInit(void);
+static void qaeCryptoMemDestroy(void);
+
+#ifdef QAT_DEBUG
+#define DEBUG(...) fprintf(stderr, __VA_ARGS__)
+#else
+#define DEBUG(...)
+#endif
+
+#define ERROR(...) fprintf(stderr, __VA_ARGS__)
+
+
+#ifdef QAT_WARN
+#define WARN(...) fprintf (stderr, __VA_ARGS__)
+#else
+#define WARN(...)
+#endif
+
+void qaeCryptoMemFree(void* ptr) 
+{
+    int rc;
+
+    DEBUG("%s: Address: %p\n", __func__, ptr);
+
+    if (!mem_inited || NULL == ptr)
+    {
+        WARN("qaeCryptoMemFree trying to free NULL pointer or Memory Driver not initialised.\n");
+	return;
+    }
+
+    DEBUG("%s: pthread_mutex_lock\n", __func__);
+    if ((rc = pthread_mutex_lock(&mem_mutex)) != 0) {
+	    ERROR("pthread_mutex_lock: %s\n", strerror(rc));
+	    return;
+    }
+
+    qaeMemFreeNUMA(&ptr);
+    ref_count--;
+
+    if (0 == ref_count)
+    {
+	    qaeCryptoMemDestroy();
+    }
+
+    if ((rc = pthread_mutex_unlock(&mem_mutex)) != 0) {
+	    ERROR("pthread_mutex_unlock: %s\n", strerror(rc));
+	    return;	
+    }
+    DEBUG("%s: pthread_mutex_unlock\n", __func__);
+}
+
+void *qaeCryptoMemAlloc(size_t memsize, const char *file, int line)
+{
+    CpaStatus status = CPA_STATUS_SUCCESS;
+    int rc;
+    void *pAddress=NULL;
+
+    DEBUG("%s: pthread_mutex_lock\n", __func__);
+    if ((rc = pthread_mutex_lock(&mem_mutex)) != 0) {
+	    ERROR("pthread_mutex_lock: %s\n", strerror(rc));
+	    return NULL;
+    }
+
+    if (!mem_inited)
+    {
+	    status = qaeCryptoMemInit();
+	    if (CPA_STATUS_SUCCESS != status)
+	    {
+		    WARN("qaeCryptoMemAlloc failed, status=%d\n", status);
+                    if ((rc = pthread_mutex_unlock(&mem_mutex)) != 0) {
+	               ERROR("pthread_mutex_unlock: %s\n", strerror(rc));
+	               return NULL;	
+	            }
+                    return NULL;
+            }
+    }
+
+    ref_count++;
+
+    pAddress = qaeMemAllocNUMA(memsize, 0, QAT_BYTE_ALIGNMENT);
+    DEBUG("%s: Address: %p Size: %d File: %s:%d\n", __func__, pAddress, memsize, file, line);
+    if ((rc = pthread_mutex_unlock(&mem_mutex)) != 0) {
+	    ERROR("pthread_mutex_unlock: %s\n", strerror(rc));
+    }
+    DEBUG("%s: pthread_mutex_unlock\n", __func__);
+    return pAddress;
+}
+
+void *qaeCryptoMemRealloc(void *ptr, size_t memsize, const char *file, int line) 
+{
+    void *nptr;
+
+    nptr = copyAllocPinnedMemory(ptr, memsize, file, line);
+    if (nptr) 
+    {
+        qaeCryptoMemFree(ptr);
+    }
+    return nptr;
+}
+
+void *qaeCryptoMemReallocClean(void *ptr, size_t memsize, size_t original_size, const char *file, int line)
+{
+    void *nptr;
+
+    if (original_size > memsize)
+       return NULL;
+
+    nptr = copyAllocPinnedMemoryClean(ptr, memsize, original_size, file, line);
+    if (nptr)
+    {
+        qaeCryptoMemFree(ptr);
+    }
+    return nptr;
+}
+
+void *copyAllocPinnedMemory(void *ptr, size_t size, const char *file, int line)
+{
+    void *nptr;
+
+    if ((nptr = qaeCryptoMemAlloc(size, file, line)) == NULL)
+    {
+        WARN("%s: pinned memory allocation failure\n", __func__);
+        return NULL;
+    }
+    memcpy (nptr, ptr, size);
+    return nptr;
+}
+
+void *copyAllocPinnedMemoryClean(void *ptr, size_t size, size_t original_size, const char *file, int line)
+{
+    void *nptr;
+
+    if ((nptr = qaeCryptoMemAlloc(size, file, line)) == NULL)
+    {
+        WARN("%s: pinned memory allocation failure\n", __func__);
+        return NULL;
+    }
+    memcpy (nptr, ptr, original_size);
+    return nptr;
+}
+
+void copyFreePinnedMemory(void *uptr, void *kptr, int size)
+{
+    memcpy (uptr, kptr, size);
+    qaeCryptoMemFree(kptr);
+}
+
+CpaPhysicalAddr qaeCryptoMemV2P(void *v)
+{
+    return qaeVirtToPhysNUMA(v);
+}
+
+void qaeCryptoAtFork()
+{
+    qaeAtFork();
+}
+
+
+/* Note: these functions are internal and not part of the interface.
+   Ensure they are called from within a locked mutex as they do not
+   implement locking themselves. */ 
+
+
+static CpaStatus qaeCryptoMemInit(void)
+{
+    CpaStatus status=CPA_STATUS_SUCCESS;
+
+    if (!mem_inited)
+    {
+	    mem_inited = 1;
+            ref_count = 0;
+            status = qaeMemInit();
+    }
+
+    return status;
+}
+
+static void qaeCryptoMemDestroy(void)
+{
+    if (mem_inited)
+    {
+	    mem_inited = 0;
+	    qaeMemDestroy();
+    }
+}
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_mem_drv_inf.h ./engines/qat_engine/qat_mem_drv_inf.h
--- ../openssl-async/engines/qat_engine/qat_mem_drv_inf.h	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_mem_drv_inf.h	2015-03-05 12:43:44.274962000 +0000
@@ -0,0 +1,74 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qat_mem_drv_inf.h
+ *
+ * This file provides an interface to a memory driver that supplies contig
+ * pinned memory.
+ *
+ *****************************************************************************/
+
+#ifndef QAT_MEM_DRV_INF_H
+#define QAT_MEM_DRV_INF_H
+
+#include <stdio.h>
+#include <pthread.h>
+#include "cpa.h"
+void qaeCryptoMemFree(void* ptr);
+void* qaeCryptoMemAlloc(size_t memsize, const char *file, int line);
+void* qaeCryptoMemRealloc(void *ptr, size_t memsize, const char *file, int line);
+void *qaeCryptoMemReallocClean(void *ptr, size_t memsize, size_t original_size, const char *file, int line);
+CpaPhysicalAddr qaeCryptoMemV2P(void *v);
+void qaeCryptoAtFork();
+void* copyAllocPinnedMemory(void *ptr, size_t size, const char *file, int line);
+void *copyAllocPinnedMemoryClean(void *ptr, size_t size, size_t original_size, const char *file, int line);
+void copyFreePinnedMemory(void *uptr, void *kptr, int size);
+
+#endif /*QAT_MEM_DRV_INF_H*/
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_parseconf.c ./engines/qat_engine/qat_parseconf.c
--- ../openssl-async/engines/qat_engine/qat_parseconf.c	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_parseconf.c	2015-03-05 12:43:44.276956000 +0000
@@ -0,0 +1,398 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+ 
+#include "qat_parseconf.h"
+#include <stdio.h>
+#include <string.h>
+#include <dirent.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include "qat_utils.h"
+/*==========================================================*/
+static char * confRemoveChar(char * inputStr, const char * charToRemove)
+{
+    char * endStr = NULL;
+    char * startStr = inputStr;
+
+    if (NULL == startStr || strlen(startStr) < 1) {
+        return startStr;
+    }
+
+    while (*startStr && (strncmp(startStr, charToRemove, 1) == 0)) {
+        startStr++;
+    }
+
+    if(strlen(startStr) < 1)
+        return startStr;
+
+    endStr = (char *)( startStr + (strlen(startStr)-1));
+
+    while (*endStr && (strncmp(endStr, charToRemove, 1) == 0)) {
+        *endStr='\0';
+        endStr--;
+    }
+    return startStr;
+}
+
+
+/*==========================================================*/
+static char * confRemoveWhiteSpace(char * inputStr)
+{
+    return confRemoveChar(inputStr, " ");
+}
+
+
+/*==========================================================*/
+static char * confRemoveDoubleQuotes(char * inputStr)
+{
+    return confRemoveChar(inputStr, "\"");
+}
+
+
+/*==========================================================*/
+static char * confRemoveStartingSquareBracket(char * inputStr)
+{
+    return confRemoveChar(inputStr, "[");
+}
+
+
+/*==========================================================*/
+static int confRemoveEndSquareBracket(char * inputStr)
+{
+    char * scannedInputStr = NULL;
+    if (NULL == inputStr) 
+        return 0;
+
+    scannedInputStr = strchr(inputStr, ']');
+    if (NULL == scannedInputStr) {
+        return 0;
+    }
+    else {
+        *scannedInputStr = '\0';
+    }
+    return 1;
+}
+
+
+/*==========================================================*/
+static int confIsLineASectionName(char * inputStr)
+{
+    /*Assumption: line has been stripped of leading/trailing 
+      white space already */
+    if (NULL == inputStr)
+        return 0;
+
+    if (strncmp(inputStr, "[", 1) == 0) {
+       if (strchr(inputStr, ']') != NULL) {;
+           return 1;
+       }
+    }
+ 
+    return 0;
+}
+
+
+/*==========================================================*/
+static int confParseSectionName(char * inputStr, char * sectionName)
+{
+    /*Assumption: line has been stripped of leading/trailing
+      whitespace already */
+    /*Assumption: It has already been determined that the 
+      input string is a Section Name by calling:
+      confIsLineASectionName */
+    char * strippedInputStr = confRemoveStartingSquareBracket(inputStr);
+
+    if (!confRemoveEndSquareBracket(strippedInputStr)) 
+        return 0;
+ 
+    if (NULL == strippedInputStr)
+        return 0;
+
+    if (strncmp(sectionName, strippedInputStr, strlen(sectionName)) == 0) {
+        return 1;
+    } 
+
+    return 0;
+}
+
+
+/*==========================================================*/
+static int confParseParameter(char * inputStr, char * keyName,
+                              char * keyValue, size_t keyValueSize)
+{
+    char tempKeyName[CONF_MAX_LINE_LENGTH] = {0};
+    char tempKeyValue[CONF_MAX_LINE_LENGTH] = {0};
+    char * strippedKeyName = NULL;
+    char * strippedKeyValue = NULL;
+    char * doubleQuoteStrippedKeyValue = NULL;
+    int tempKeyNameLen = 0;
+    int tempKeyValueLen = 0;
+
+    /* Check input parameters */
+    if (NULL == inputStr)
+        return 0;
+
+    if ((strlen(keyName) > (CONF_MAX_LINE_LENGTH - 1)) ||
+        (strlen(inputStr) > (CONF_MAX_LINE_LENGTH - 1)))
+        return 0;
+
+    /* Separate the key name and value pair using the same method as the
+       ia driver does for consistency */
+    if (sscanf(inputStr, "%[^=] = %[^#\n]", tempKeyName, tempKeyValue) !=
+        CONF_PARAM_EXP_NUM_ARGS) {
+        return 0;
+    }
+
+    /* Check the strings are not too long - they should not be as we
+       checked inputStr earlier*/
+    tempKeyNameLen = strlen(tempKeyName);
+    tempKeyValueLen = strlen(tempKeyValue);
+    if ((tempKeyNameLen > (CONF_MAX_LINE_LENGTH - 1)) ||
+        (tempKeyValueLen > (CONF_MAX_LINE_LENGTH - 1)))
+        return 0;
+
+    /* Strip whitespace and quotes as appropriate */
+    strippedKeyName = confRemoveWhiteSpace(tempKeyName);
+    strippedKeyValue = confRemoveWhiteSpace(tempKeyValue);
+    doubleQuoteStrippedKeyValue = confRemoveDoubleQuotes(strippedKeyValue);
+
+    if (NULL == strippedKeyName || NULL == doubleQuoteStrippedKeyValue)
+        return 0;
+
+    if (strncmp(keyName, strippedKeyName, strlen(keyName)) != 0)
+        return 0;
+
+    if (keyValueSize < strlen(doubleQuoteStrippedKeyValue))
+        return 0;
+
+    strncpy(keyValue, doubleQuoteStrippedKeyValue, strlen(doubleQuoteStrippedKeyValue));
+    return 1;
+}
+
+
+/*==========================================================*/
+int confCryptoFindKeyValue(char * fileName, 
+                     char * sectionName, char * keyName,
+                     char * keyValue, size_t keyValueSize)
+{
+    FILE * conffile;
+    int inSection = 0;
+    int found = 0;
+    int sectionFound = 0;
+    char lineBuffer[CONF_MAX_LINE_LENGTH] = {0};
+    int lineBufferLength = 0;
+    char * strippedLineBuffer = NULL;
+
+    if (strlen(fileName) > CONF_MAX_PATH) {
+        fprintf(stderr, "Invaid Configuration File Name Length\n"); 
+        return 0; 
+    }
+    if ((conffile = fopen( fileName, "r" )) != NULL) {
+        while (! feof( conffile )) {
+            if (fgets(lineBuffer, CONF_MAX_LINE_LENGTH, conffile) != NULL) {
+                 lineBufferLength = strlen(lineBuffer);
+                 if (lineBufferLength > 0) {
+
+                     /* Remove any leading or trailing whitespace before trying
+                        to process further. It is okay to pass a NULL string to
+                        the confRemoveWhiteSpace function */
+                     strippedLineBuffer = confRemoveWhiteSpace(lineBuffer);
+
+                     /* We didn't get a valid line, lets continue to next line*/
+                     if (NULL == strippedLineBuffer) 
+                         continue;
+
+                     /* We got a comment or empty line, ignore and continue to
+                        next line */
+                     if (('#' == *strippedLineBuffer) || (0 == *strippedLineBuffer))
+                         continue;
+
+                     /* Check whether line is a section name */
+                     if (confIsLineASectionName(strippedLineBuffer)) {
+                         /* Are we already in the desired section?*/
+                         if (inSection) {
+                             /* We are so we must have finished that section lets
+                                the flag so do not continue to process parameters
+                                within other sections */
+                             inSection = 0;
+                         }
+                         else {
+                             /* We aren't in the section already lets check whether
+                                this is the section we want */
+                             if (confParseSectionName(strippedLineBuffer, sectionName)) {
+                                 /* It is the section we want so set the flag */
+                                 inSection = 1;
+                                 sectionFound =1;
+                             }
+                         }
+                     }
+                     else { /* It's not a section name so assume it is a parameter */
+                         /* Are we in the correct section of the config file? */
+                         if (inSection) {
+                             /* We are so parse the parameter and deal with it 
+                                as appropriate */
+                             if (confParseParameter(strippedLineBuffer, keyName, 
+                                 keyValue, keyValueSize)) {
+                             /* Found the parameter we are looking for set flag
+                                and break out of loop*/
+                                 found=1;
+                                 break;
+                             }
+                         }
+                     }
+                 }
+            }
+        }
+        fclose(conffile);
+    }
+    else
+    {
+        fprintf(stderr, "Unable to open file %s\n", fileName);
+    }
+    return found + sectionFound;
+}
+
+#define DH89XXCC_NAME "dh89xxcc"
+#define DH895XCC_NAME "dh895xcc"
+#define C2XXX_NAME "c2xxx"
+
+#define DH89XXCC_INDEX 0
+#define DH895XCC_INDEX 1
+#define C2XXX_INDEX 2
+
+#define NUM_DEVICES_TYPES 3
+#define MAX_NUM_DEVICES 32
+
+int getDevices(unsigned int dev_mask[])
+{
+    DIR * proc;
+    struct dirent * child;
+    char * tmp;
+    int dev_index;
+    int found = 0;
+    proc = opendir("/proc");
+    if (!proc){
+        WARN("No /proc directory or it cannot be opened\n");
+        return 0;
+    }
+    while ((child = readdir(proc)) != NULL){
+        if (!strncmp(child->d_name, "icp_",4)){
+            /* there is a /proc/icp_* directory */
+				DEBUG("looking for dir %s\n", child->d_name);
+            if (strstr(child->d_name, DH89XXCC_NAME)){
+                //it is a Cave Creek device
+                dev_index = DH89XXCC_INDEX;
+
+            }
+            else if (strstr(child->d_name, DH895XCC_NAME)){
+                //it is Coleto Creek device
+                dev_index = DH895XCC_INDEX;
+            }
+            else if (strstr(child->d_name, C2XXX_NAME)){
+                //it is Rangeley device
+                dev_index = C2XXX_INDEX;
+            }
+            else continue;
+            if ((tmp = strstr(child->d_name, "dev")) != NULL){
+                if (isdigit(tmp[3])){
+                    int a = atoi(tmp + 3);
+                    if ((a >= 0) && (a < MAX_NUM_DEVICES)){
+                        dev_mask[dev_index] |= 1 << a;
+                        found = 1;
+                    }
+                }
+            }
+        }
+    }
+    closedir(proc);
+    if (!found){
+        WARN("No running QA devices detected \n");
+        return 0;
+    }
+    return 1;
+}
+
+int checkLimitDevAccessValue(int * limitDevAccess, char * section_name)
+{
+    unsigned int devmasks[] = {0, 0, 0};
+    char * dev_names[] = {DH89XXCC_NAME, DH895XCC_NAME, C2XXX_NAME};
+    char configFilePath[CONF_MAX_PATH];
+    char configKeyValue[CONF_MAX_LINE_LENGTH] = {0};
+    int configKeyValueSize = CONF_MAX_LINE_LENGTH;
+    int status;
+	int i,j;
+    if (!getDevices(devmasks)){
+        *limitDevAccess = 0;
+        return 0;
+    }
+    for (j = 0; j < NUM_DEVICES_TYPES; j++)
+        for (i = 0; i < MAX_NUM_DEVICES; i++) {
+            if ((devmasks[j] & (1 << i))) {
+                sprintf(configFilePath, "/etc/%s_qa_dev%d.conf", dev_names[j],
+                        i);
+            }
+            else continue;
+            DEBUG("looking in %s\n", configFilePath);
+            status = confCryptoFindKeyValue(configFilePath, section_name,
+                    "LimitDevAccess", configKeyValue, configKeyValueSize);
+            if (status == CONF_FIND_KEY_SECTION_FOUND) {
+                // if the SHIM section was found in the config file but no LimitDevAccess setting,
+                // LimitDevAccess is set to 0
+                *limitDevAccess = 0;
+                return 1;
+            } else if (status == CONF_FIND_KEY_KEY_FOUND) {
+                if (isdigit(configKeyValue[0])) {
+                    *limitDevAccess = atoi(configKeyValue);
+                    return 1;
+                }
+            }
+        }
+    *limitDevAccess = 0;
+    return 0;
+}
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_parseconf.h ./engines/qat_engine/qat_parseconf.h
--- ../openssl-async/engines/qat_engine/qat_parseconf.h	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_parseconf.h	2015-03-05 12:43:44.277956000 +0000
@@ -0,0 +1,147 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+#ifndef QATPARSECONF_H
+#define QATPARSECONF_H
+
+#include <stdio.h>
+
+/* The maximum amount of characters allowed per line in the 
+   config file*/
+#define CONF_MAX_LINE_LENGTH 160
+
+/* The number of arguments when we split a line of the form: 
+   "<arg1> = <arg2>" */
+#define CONF_PARAM_EXP_NUM_ARGS 2
+
+/* The maximum length of the path and filename to where the driver
+   configuration file is stored */ 
+#define CONF_MAX_PATH 1024
+
+
+#define CONF_FIND_KEY_KEY_FOUND 2
+#define CONF_FIND_KEY_SECTION_FOUND 1
+#define CONF_FIND_KEY_FAILED 0
+/***********************************************************************
+ * function:
+ *         confCryptoFindKeyValue(char * filename
+ *                          char * sectionName, char * keyName
+ *                          char * keyValue, size_t keyValueSize)
+ * @description
+ *     This function will open the config file at the supplied path.
+ *     Parse the config file for the specified section and then parse
+ *     for the specified key name. If the key name is found then the
+ *     function will return 1 and copy the associated key value into
+ *     the string supplied as the keyValue parameter. If the key
+ *     name is not found then the function will return 0 and the
+ *     keyValue string will not be populated.
+ * @param[in] filename - a string containing the path and filename of
+ *                       the config file to parse.
+ * @param[in] sectionName - a string containing the section name to
+ *                          match.
+ * @param[in] keyName - a string containing the key name we are 
+ *                      trying to match.
+ * @param[in, out] keyValue - This parameter should be passed in as
+ *                            an allocated string. If a match is found
+ *                            for the sectionName and keyName then the
+ *                            key value associated with the key name
+ *                            will be copied into this string.
+ * @param[in] keyValueSize - the size of the allocated string passed
+ *                           in as keyValue. This allows size checking
+ *                           so we don't try and copy a key value that
+ *                           is too large into the keyValue string.
+ * @retval int - Return 2 if a key value was found.
+ *               Return 1 if the section was found
+ *               Return 0 if the key value nor section was not found or any errors occured.
+ *
+ **********************************************************************/
+int confCryptoFindKeyValue(char * fileName, 
+                     char * sectionName, char * keyName,
+                    char * keyValue, size_t keyValueSize);
+
+ /***********************************************************************
+  * function:
+  *         checkLimitDevAccessValue(int * limitDevAccess,
+  *                                  char * section_name);
+  * @description
+  *     This function will go through config files of running QA devices
+  *     and look for value of LimitDevAccess parameter in the section, whose name
+  *     is given in the section_name parameter. The value of LimitDevAccess found
+  *     in first config file that contains section_name section. If the first config
+  *     file that contains section_name section does not have LimitDevAccess set, then
+  *     it is assumed that LimitDevAccess=1
+  * @param[out] limitDevAccess - pointer to where the returned LimitDevAccess value
+  *                             will be stored
+  * @param[in] sectionName - a string containing the section name to
+  *                          match.
+  * @retval int - Return 1 the LimitDevAccess value was found.
+  *               Return 0 the LimitDevAccess could not be found, zero is returned in
+  *                         limitDevAccess
+  *
+  **********************************************************************/
+int checkLimitDevAccessValue(int * limitDevAccess, char * section_name);
+
+ /***********************************************************************
+  * function:
+  *         getDevices(unsigned int dev_mask[])
+  *                                  
+  * @description
+  *     This function will check the availability of Acceleration devices
+  *     and if found, it will set the corresponding index to 1. 
+  *
+  * @param[out] dev_mask - Corresponding dev index will be set to 1.
+  *                             
+  * @param[in] dev_mask - An empty array with all the values set to 0. 
+  *                          
+  * @retval int - Return 1 The acceleration devices are found
+  *               Return 0 No Acceleration device is found
+  *
+  **********************************************************************/
+int getDevices(unsigned int dev_mask[]);
+#endif /* QATPARSECONF_H */
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_prf.c ./engines/qat_engine/qat_prf.c
--- ../openssl-async/engines/qat_engine/qat_prf.c	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_prf.c	2015-03-05 12:43:44.278956000 +0000
@@ -0,0 +1,618 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qat_prf.c
+ *
+ * This file provides an implementaion of the PRF operations for an
+ * OpenSSL engine
+ *
+ *****************************************************************************/
+
+/*To avoid including PRF Offload in QAT SYNCH Baseline*/
+#ifdef OPENSSL_QAT_ASYNCH
+
+#include <string.h>
+
+#include "openssl/ossl_typ.h"
+#include "openssl/prf.h"
+#include "openssl/evp.h"
+#include "openssl/tls1.h"
+
+#include "evp_locl.h"
+#include "qat_prf.h"
+#include "qat_utils.h"
+#include "qat_asym_common.h"
+#include "e_qat.h"
+#include "e_qat_err.h"
+
+#ifdef USE_QAT_MEM
+#include "qae_mem_utils.h"
+#endif
+#ifdef USE_QAE_MEM
+#include "qat_mem_drv_inf.h"
+#endif
+
+#include "cpa.h"
+#include "cpa_types.h"
+#include "cpa_cy_key.h"
+
+
+#ifdef OPENSSL_ENABLE_QAT_PRF_SYNCH
+#ifdef OPENSSL_DISABLE_QAT_PRF_SYNCH
+#undef OPENSSL_DISABLE_QAT_PRF_SYNCH
+#endif
+#endif
+
+/* PRF methods */
+static EVP_PKEY_METHOD *qat_prf_pmeth = NULL;
+
+/* PRF nid */ 
+int qat_prf_nids[] = {
+    EVP_PKEY_PRF
+};
+#ifndef OPENSSL_DISABLE_QAT_PRF_SYNCH
+static int qat_prf_pmeth_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *olen);
+#endif
+
+/******************************************************************************
+* function:
+*         qat_prf_cleanup()
+*
+* description:
+*   To clear the qat_prf_pmeth. Invoked while destroying the engine
+******************************************************************************/
+void qat_prf_cleanup()
+{
+    qat_prf_pmeth = NULL;
+}
+/******************************************************************************
+* function:
+*         qat_register_prf_pmeths()
+*
+* description:
+*   Helper function for registration of PRF methods
+******************************************************************************/
+static int qat_register_prf_pmeths()
+{
+    const EVP_PKEY_METHOD *pmeth;
+
+    pmeth = EVP_PKEY_meth_find(EVP_PKEY_PRF);
+    if(!pmeth)
+    {
+        QATerr(QAT_F_QAT_REGISTER_PRF_PMETHS, EVP_R_UNSUPPORTED_ALGORITHM);
+        return 0;
+    }
+
+    qat_prf_pmeth = EVP_PKEY_meth_new(EVP_PKEY_PRF, 0);
+    if(!qat_prf_pmeth)
+    {
+        QATerr(QAT_F_QAT_REGISTER_PRF_PMETHS, ERR_R_MALLOC_FAILURE);
+        return 0;
+    }
+
+    EVP_PKEY_meth_copy(qat_prf_pmeth, pmeth);
+
+#ifndef OPENSSL_DISABLE_QAT_PRF_SYNCH
+    DEBUG("Registering the method\n");
+    EVP_PKEY_meth_set_derive(qat_prf_pmeth, pmeth->derive_init, qat_prf_pmeth_derive);
+#endif
+
+#ifndef OPENSSL_DISABLE_QAT_PRF_ASYNCH
+    /* TODO add asynch 
+     * EVP_PKEY_meth_set_derive_asynch(qat_prf_pmeth, qat_prf_pmeth_derive_asynch);
+     */
+#endif
+
+    return 1;
+}
+
+/******************************************************************************
+* function:
+*         qat_prf_pkey_meths(ENGINE *e,
+*                     const EVP_PKEY_METHOD **pmeth,
+*                     const int **nids,
+*                     int nid)
+*
+* @param e      [IN] - OpenSSL engine pointer
+* @param pmeth  [IN] - PRF methods structure pointer
+* @param nids   [IN] - PRF functions nids
+* @param nid    [IN] - PRF operation id
+*
+* description:
+*   Qat engine digest operations registrar
+******************************************************************************/
+int qat_prf_pkey_meths(ENGINE *e, EVP_PKEY_METHOD **pmeth,
+        const int **nids, int nid)
+{
+    if(!pmeth)
+    {
+        *nids=qat_prf_nids;
+        return 1;
+    }
+
+    if(!qat_prf_pmeth)
+        qat_register_prf_pmeths();
+
+    if(pmeth)
+        *pmeth=qat_prf_pmeth;
+
+    return 1;
+}
+
+#ifndef OPENSSL_DISABLE_QAT_PRF_SYNCH /* In future include OR OPENSSL_DISABLE_QAT_PRF_ASYNCH*/
+/******************************************************************************
+* function:
+*         void qat_prf_cb(
+*                   void *pCallbackTag, 
+*                   CpaStatus status,
+*                   void *pOpdata, 
+*                   CpaFlatBuffer *pOut)
+*
+* @param pCallbackTag   [IN]  - Pointer to user data
+* @param status         [IN]  - Status of the operation
+* @param pOpData        [IN]  - Pointer to operation data of the request
+* @param out            [IN]  - Pointer to the output buffer
+*
+* description:
+*   Callback to indicate the completion of PRF (sync case)
+******************************************************************************/
+void qat_prf_cb(void *pCallbackTag, CpaStatus status, 
+        void *pOpData, CpaFlatBuffer *pOut)
+{
+    qat_crypto_callbackFn(pCallbackTag, status, CPA_CY_SYM_OP_CIPHER, pOpData,
+            NULL, CPA_FALSE);
+}
+
+/******************************************************************************
+* function:
+*         qat_get_hash_algorithm(
+*                   PRF *qat_prf_ctx
+*                   CpaCySymHashAlgorithm *hash_algorithm)
+*
+* @param qat_prf_ctx    [IN]  - PRF context
+* @param hash_algorithm [OUT] - Ptr to hash algorithm in CPA format 
+*
+* description:
+*   Retrieve the hash algorithm from the prf context and convert it to
+*   the CPA format
+******************************************************************************/
+static int qat_get_hash_algorithm(PRF *qat_prf_ctx, CpaCySymHashAlgorithm *hash_algorithm)
+{
+    if (!qat_prf_ctx || !hash_algorithm) {
+        WARN("[%s] Error: NULL input variables\n", __func__);
+        return 0;
+    }
+
+    int ssl_version = qat_prf_ctx->version;
+    if (ssl_version < TLS1_2_VERSION)
+    {
+        return 1;
+    }
+
+    const EVP_MD *md;
+    md = *(qat_prf_ctx->md);
+    if (!md)
+    {
+        WARN("[%s] --- md is NULL.\n", __func__);
+        return 0;
+    }
+
+    switch (EVP_MD_type(md))
+    {
+        case NID_sha1:
+            *hash_algorithm = CPA_CY_SYM_HASH_SHA1;
+            break;
+        case NID_sha224:
+            *hash_algorithm = CPA_CY_SYM_HASH_SHA224;
+            break;
+        case NID_sha256:
+            *hash_algorithm = CPA_CY_SYM_HASH_SHA256;
+            break;
+        case NID_sha384:
+            *hash_algorithm = CPA_CY_SYM_HASH_SHA384;
+            break;
+        case NID_sha512:
+            *hash_algorithm = CPA_CY_SYM_HASH_SHA512;
+            break;
+        case NID_md5:
+            *hash_algorithm = CPA_CY_SYM_HASH_MD5;
+            break;
+        default:
+            WARN("[%s] --- Unsupported PRF hash type\n", __func__);
+            return 0;   
+    }
+    
+    return 1;
+}
+
+#ifdef QAT_DEBUG
+void print_prf_op_data(const char *func, CpaCyKeyGenTlsOpData *prf_op_data) {
+    if (!prf_op_data || !func) {
+        DEBUG("[%s] Error: null pointer\n", func);
+        return;
+    }
+    
+    DEBUG("[%s] ----- PRF Op Data -----\n", func);
+    
+    if (prf_op_data->tlsOp == CPA_CY_KEY_TLS_OP_MASTER_SECRET_DERIVE)
+        DEBUG("tlsOp: MASTER_SECRET_DERIVE\n");
+    else if (prf_op_data->tlsOp == CPA_CY_KEY_TLS_OP_KEY_MATERIAL_DERIVE)
+        DEBUG("tlsOp: KEY_MATERIAL_DERIVE\n");
+    else if (prf_op_data->tlsOp == CPA_CY_KEY_TLS_OP_CLIENT_FINISHED_DERIVE)
+        DEBUG("tlsOp: CLIEN_FINISHED_DERIVE\n");
+    else if (prf_op_data->tlsOp == CPA_CY_KEY_TLS_OP_SERVER_FINISHED_DERIVE)
+        DEBUG("tlsOp: SERVER_FINISHED_DERIVE\n");
+    else if (prf_op_data->tlsOp == CPA_CY_KEY_TLS_OP_USER_DEFINED)
+        DEBUG("tlsOp: USER_DEFINED:\n");
+
+    DUMPL("Secret", prf_op_data->secret.pData, prf_op_data->secret.dataLenInBytes);
+    DUMPL("Seed", prf_op_data->seed.pData, prf_op_data->seed.dataLenInBytes);
+    DUMPL("User Label", prf_op_data->userLabel.pData, prf_op_data->userLabel.dataLenInBytes);
+    DEBUG("---");
+
+}
+#define DEBUG_PRF_OP_DATA(prf) print_prf_op_data(__func__,prf)
+#else
+#define DEBUG_PRF_OP_DATA(...)
+#endif
+
+/******************************************************************************
+* function:
+*         build_tls_prf_op_data(
+*                   PRF *qat_prf_ctx,
+*                   CpaCyKeyGenTlsOpData *prf_op_data)
+*
+* @param qat_prf_ctx    [IN]  - PRF context
+* @param prf_op_data    [OUT] - Ptr to TlsOpData used as destination 
+*
+* description:
+*   Build the TlsOpData based on the values stored in the PRF context
+*   Note: prf_op_data must be allocated outside this function
+******************************************************************************/
+static int build_tls_prf_op_data(PRF *qat_prf_ctx, CpaCyKeyGenTlsOpData *prf_op_data)
+{
+    /* TODO: The check on the inputs could be removed becuase this function is 
+     * called only from this file and the input variables are never NULL... */
+    if (!qat_prf_ctx || !prf_op_data) {
+        WARN("[%s] Error: NULL input variables\n", __func__);
+        return 0;
+    }
+
+    /* Allocate and copy the secret data */
+    prf_op_data->secret.pData = (Cpa8U*) copyAllocPinnedMemory((void*) qat_prf_ctx->sec, qat_prf_ctx->sec_len, __FILE__, __LINE__);
+    if (NULL == prf_op_data->secret.pData)
+    {
+        WARN("[%s] --- Secret data malloc failed!\n", __func__);
+        return 0;
+    }
+    prf_op_data->secret.dataLenInBytes = qat_prf_ctx->sec_len;
+
+
+    /* The label is stored in seed1 as a string
+     * Conversion from string to CPA constant  */
+    const void *label = qat_prf_ctx->seed1;
+    DEBUG("Value of label = %s\n", label);
+
+    prf_op_data->userLabel.pData = NULL;
+    prf_op_data->userLabel.dataLenInBytes = 0;
+
+    if (0 == strncmp(label, TLS_MD_MASTER_SECRET_CONST, TLS_MD_MASTER_SECRET_CONST_SIZE))
+    {
+        prf_op_data->tlsOp = CPA_CY_KEY_SSL_OP_MASTER_SECRET_DERIVE;
+    }
+    else if (0 == strncmp(label, TLS_MD_KEY_EXPANSION_CONST, TLS_MD_KEY_EXPANSION_CONST_SIZE))
+    {
+        prf_op_data->tlsOp = CPA_CY_KEY_TLS_OP_KEY_MATERIAL_DERIVE;
+    }
+    else if (0 == strncmp(label, TLS_MD_CLIENT_FINISH_CONST, TLS_MD_CLIENT_FINISH_CONST_SIZE))
+    {
+        prf_op_data->tlsOp = CPA_CY_KEY_TLS_OP_CLIENT_FINISHED_DERIVE;
+    }
+    else if (0 == strncmp(label, TLS_MD_SERVER_FINISH_CONST, TLS_MD_SERVER_FINISH_CONST_SIZE))
+    {
+        prf_op_data->tlsOp = CPA_CY_KEY_TLS_OP_SERVER_FINISHED_DERIVE;
+    }
+    else
+    {
+        /* Allocate and copy the user label contained in seed1 */
+        /* TODO we must test this case to see if it works OK */
+        DEBUG("Using USER_DEFINED label");
+        prf_op_data->tlsOp = CPA_CY_KEY_TLS_OP_USER_DEFINED;
+        prf_op_data->userLabel.pData = (Cpa8U*) copyAllocPinnedMemory((void*) qat_prf_ctx->seed1, qat_prf_ctx->seed1_len, __FILE__, __LINE__);
+        if (NULL == prf_op_data->userLabel.pData)
+        {
+            WARN("[%s] --- User label malloc failed!\n", __func__);
+            return 0;
+        }
+        prf_op_data->userLabel.dataLenInBytes = qat_prf_ctx->seed1_len;
+    }
+
+    /* The seed for prf_op_data is obtained by concatenating seed2...5 in the context */
+    int total_seed_len = qat_prf_ctx->seed2_len + qat_prf_ctx->seed3_len + qat_prf_ctx->seed4_len + qat_prf_ctx->seed5_len;
+    prf_op_data->seed.pData = qaeCryptoMemAlloc(total_seed_len, __FILE__, __LINE__);
+    if (NULL == prf_op_data->seed.pData)
+    {
+        WARN("[%s] --- Seed data malloc failed!\n", __func__);
+        return 0;
+    }
+
+    prf_op_data->seed.dataLenInBytes = total_seed_len;
+
+    int accum_len = 0;
+    /* TODO the client and server randoms are reversed on the QAT API for Key Derive.
+     * This shouldn't be a problem because OpenSSL calls the function with the variables in the correct order 
+     */
+    if (qat_prf_ctx->seed2_len)
+    {
+        memcpy(prf_op_data->seed.pData, qat_prf_ctx->seed2, qat_prf_ctx->seed2_len);
+        accum_len += qat_prf_ctx->seed2_len;
+    }
+    if (qat_prf_ctx->seed3_len)
+    {
+        memcpy((prf_op_data->seed.pData) + accum_len, qat_prf_ctx->seed3, qat_prf_ctx->seed3_len);
+        accum_len += qat_prf_ctx->seed3_len;
+    }
+    if (qat_prf_ctx->seed4_len)
+    {
+        memcpy((prf_op_data->seed.pData) + accum_len, qat_prf_ctx->seed4, qat_prf_ctx->seed4_len);
+        accum_len += qat_prf_ctx->seed4_len;
+    }
+    if (qat_prf_ctx->seed5_len)
+    {
+        memcpy((prf_op_data->seed.pData) + accum_len, qat_prf_ctx->seed5, qat_prf_ctx->seed5_len);
+    }
+
+    return 1;
+}
+
+
+/******************************************************************************
+* function:
+*         qat_prf_tls_derive(
+*                   PRF *qat_prf_ctx,
+*                   unsigned char *key,
+*                   size_t *olen)
+*
+* @param qat_prf_ctx    [IN]  - PRF context
+* @param key            [OUT] - Ptr to the key that will be generated
+* @param olen           [IN]  - Length of the key
+*
+* description:
+*   PRF derive function for sync TLS case 
+******************************************************************************/
+static int qat_prf_tls_derive(PRF *qat_prf_ctx, unsigned char *key, size_t *olen)
+{
+    int ret = 0;
+    CpaCyKeyGenTlsOpData *prf_op_data = NULL;
+    CpaFlatBuffer* generated_key = NULL;
+
+    if (NULL == qat_prf_ctx || NULL == key || NULL == olen)
+    {
+        WARN("[%s] --- Input parameters cannot be NULL\n", __func__);
+        goto err;
+    }
+
+    /* ---- Hash algorithm ---- */  
+    CpaCySymHashAlgorithm hash_algo;
+    int ssl_version = qat_prf_ctx->version;
+
+    /* Only required for TLS1.2 as previous versions always use MD5 and SHA-1 */
+    if (TLS1_2_VERSION == ssl_version)
+    {
+        if (!qat_get_hash_algorithm(qat_prf_ctx, &hash_algo))
+        {
+            WARN("[%s] --- Cannot obtain hash algorithm\n", __func__);
+            goto err;
+        }
+    }
+
+    /* ---- Tls Op Data ---- */
+    prf_op_data = OPENSSL_malloc(sizeof(CpaCyKeyGenTlsOpData));
+    if (NULL == prf_op_data)
+    {
+        WARN("[%s] --- PRF OP data structure malloc failed\n", __func__);
+        goto err;
+    }
+    memset(prf_op_data, 0, sizeof(CpaCyKeyGenTlsOpData));
+
+    if (!build_tls_prf_op_data(qat_prf_ctx, prf_op_data))
+    {
+        WARN("[%s] --- Failed to build prf_op_data\n", __func__);
+        goto err;
+    }
+
+    /* ---- Generated Key ---- */
+    int key_length = *olen;
+    prf_op_data->generatedKeyLenInBytes = key_length;
+    
+    generated_key = (CpaFlatBuffer*)qaeCryptoMemAlloc(sizeof(CpaFlatBuffer), __FILE__, __LINE__);
+    if (NULL == generated_key)
+    {
+        WARN("[%s] --- Generated Key malloc failed!\n", __func__);
+        goto err;
+    }
+
+    generated_key->pData = (Cpa8U*)qaeCryptoMemAlloc(key_length, __FILE__, __LINE__);
+    if (NULL == generated_key->pData)
+    {
+        WARN("[%s] --- Generated Key Data malloc failed!\n", __func__);
+        goto err;
+    }
+    generated_key->dataLenInBytes = key_length;
+
+    /* ---- Perform the operation ---- */
+    CpaInstanceHandle instance_handle = NULL;
+    if(NULL == (instance_handle = get_next_inst()))
+    {
+        WARN("instance Handle is NULL\n");
+        goto err;
+    }
+
+    CpaStatus status = CPA_STATUS_FAIL;
+    struct op_done op_done;
+    int qatPerformOpRetries = 0;
+    int iMsgRetry = getQatMsgRetryCount();
+    unsigned long int ulPollInterval = getQatPollInterval();
+
+    DEBUG_PRF_OP_DATA(prf_op_data);
+
+    initOpDone(&op_done);
+
+    do
+    {
+        /* Call the function of CPA according the to the version of TLS */
+        if (TLS1_2_VERSION == ssl_version)
+        {
+            DEBUG("Calling cpaCyKeyGenTls2\n");
+            status = cpaCyKeyGenTls2(instance_handle, qat_prf_cb, &op_done,
+                    prf_op_data, hash_algo, generated_key);
+        }
+        else
+        {
+            DEBUG("Calling cpaCyKeyGenTls\n");
+            status = cpaCyKeyGenTls(instance_handle, qat_prf_cb, &op_done,
+                    prf_op_data, generated_key);
+        }
+
+        if (CPA_STATUS_RETRY == status)
+        {
+            usleep(ulPollInterval + 
+                    (qatPerformOpRetries % QAT_RETRY_BACKOFF_MODULO_DIVISOR));
+            qatPerformOpRetries++;
+        }
+    } 
+    while (status == CPA_STATUS_RETRY &&
+            ((qatPerformOpRetries < iMsgRetry) || 
+             (iMsgRetry == QAT_INFINITE_MAX_NUM_RETRIES)));
+
+    if (CPA_STATUS_SUCCESS != status)
+    {
+        QATerr(QAT_F_QAT_PRF_TLS_DERIVE, ERR_R_INTERNAL_ERROR);
+        cleanupOpDone(&op_done);
+        goto err;
+    }
+   
+    int rc = waitForOpToComplete(&op_done);
+    cleanupOpDone(&op_done);
+
+    if (rc)
+    {
+        goto err;
+    }
+
+    DUMPL("Generated key", generated_key->pData, key_length);
+    memcpy(key, generated_key->pData, key_length);
+    ret = 1;
+
+err:
+    /* ----- Free memory ----- */
+    if (NULL != prf_op_data)
+    {
+        if (NULL != prf_op_data->secret.pData)
+            qaeCryptoMemFree(prf_op_data->secret.pData);
+        if (NULL != prf_op_data->seed.pData)
+            qaeCryptoMemFree(prf_op_data->seed.pData);
+        if (NULL != prf_op_data->userLabel.pData)
+            qaeCryptoMemFree(prf_op_data->userLabel.pData);
+        OPENSSL_free(prf_op_data);
+    }
+    if (NULL != generated_key)
+    {
+        if (NULL != generated_key->pData)
+            qaeCryptoMemFree(generated_key->pData);
+        qaeCryptoMemFree(generated_key);
+    }
+    return ret;
+}
+
+/******************************************************************************
+* function:
+*         qat_prf_pmeth_derive(
+*                   PRF *qat_prf_ctx,
+*                   unsigned char *key,
+*                   size_t *olen)
+*
+* @param qat_prf_ctx    [IN]  - PRF context
+* @param key            [OUT] - Ptr to the key that will be generated
+* @param olen           [IN]  - Length of the key
+*
+* description:
+*   PRF derive function for sync case 
+******************************************************************************/
+static int qat_prf_pmeth_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *olen)
+{
+    if (!ctx || !key || !olen)
+    {
+        WARN("[%s] --- Invalid input parameters.\n", __func__);
+        return 0;
+    }
+
+    PRF *qat_prf_ctx = ctx->data;
+    if(!qat_prf_ctx)
+    {
+        WARN("[%s] --- qat_prf_ctx is NULL.\n", __func__);
+        return 0;
+    }
+
+    if (qat_prf_ctx->version >= TLS1_VERSION)
+    {
+        return qat_prf_tls_derive(qat_prf_ctx, key, olen);
+    }
+    else
+    {
+        /* TODO: add SSL case */
+        WARN("[%s] --- SSL case is not supported\n", __func__);
+        return 0;
+    }
+}
+#endif
+
+
+#endif
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_prf.h ./engines/qat_engine/qat_prf.h
--- ../openssl-async/engines/qat_engine/qat_prf.h	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_prf.h	2015-03-05 12:43:44.279959000 +0000
@@ -0,0 +1,70 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qat_prf.h
+ *
+ * This file provides an interface for PRF operation
+ *
+ *****************************************************************************/
+
+/*To avoid including PRF offload support in QAT Synch Baseline*/
+#ifdef OPENSSL_QAT_ASYNCH
+
+#ifndef QAT_PRF_H
+#define QAT_PRF_H
+
+#include <openssl/engine.h>
+#include <openssl/prf.h>
+
+int qat_prf_pkey_meths(ENGINE *e, EVP_PKEY_METHOD **pmeth, const int **nids, int nid);
+void qat_prf_cleanup();
+
+#endif //QAT_PRF_H
+#endif
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_rand.c ./engines/qat_engine/qat_rand.c
--- ../openssl-async/engines/qat_engine/qat_rand.c	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_rand.c	2015-03-05 12:43:44.280960000 +0000
@@ -0,0 +1,903 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qat_rand.c
+ *
+ * This file contains the engine implementation for random bit generation
+ *
+ * The implementation includes a Deterministic Random Bit Generator part (DRBG)
+ * and a Non-Deterministic Random Bit Generator part (NRBG). The NRBG is used
+ * to ensure high entropy is achieved when requesting random data via DRBG
+ *
+ * Note: to optimise driver interaction, qat_rand will use a 'cache' of random
+ * data, accessible through the qat_rand_bytes interface. The initialisation
+ * will generate a synchronous op to the driver to populate the pool with 
+ * QAT_RAND_BLOCK_SIZE bytes of data. qat_rand_bytes will perform 
+ * a memcpy from the pool. When the pool is all used a synchronous call is made 
+ * to replenish the pool.
+ *
+ *****************************************************************************/
+
+#include <openssl/crypto.h>
+#include <pthread.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "cpa.h"
+#include "cpa_cy_im.h"
+#include "cpa_cy_nrbg.h"
+#include "cpa_cy_drbg.h"
+#include "icp_sal_drbg_impl.h"
+
+#include "qat_rand.h"
+#ifdef USE_QAT_MEM
+#include "qae_mem_utils.h"
+#endif
+#ifdef USE_QAE_MEM
+#include "qat_mem_drv_inf.h"
+#endif
+#include "qat_utils.h"
+#include "e_qat.h"
+
+/* Random data pool size */
+#define QAT_RAND_BLOCK_SIZE (63 * 1024) /* max DRBG single request */
+
+
+#ifdef OPENSSL_ENABLE_QAT_OFFLOAD_RAND
+#ifdef OPENSSL_DISABLE_QAT_OFFLOAD_RAND
+#undef OPENSSL_DISABLE_QAT_OFFLOAD_RAND
+#endif
+#endif
+
+/* The max number of times we try to remove the session */
+#define QAT_RAND_CLEANUP_RETRY_COUNT 10
+/* This is the amount of time we wait between remove session re-tries */
+#define QAT_RAND_CLEANUP_WAIT_TIME_NS 1000000
+
+typedef struct qat_nrbg_callback_data_s {
+    CpaCyNrbgOpData opData;
+    /* NRBG client information */
+    IcpSalDrbgGetEntropyInputCbFunc pClientCbFunc;
+    void *pClientCallbackTag;
+    void *pClientOpData;
+} qat_nrbg_callback_data_t;
+
+/* NOTE: There is one random data cache of DRBG data per process address space.
+ * One instance and one session used for all call requests from all threads
+ * in this process */
+/* Instance handle */
+static CpaInstanceHandle instanceHandle = CPA_INSTANCE_HANDLE_SINGLE;
+/* Session handle */
+static CpaCyDrbgSessionHandle sessionHandle = NULL;
+/* Pointer to cache of random data */
+static Cpa8U *pDrbgData = NULL;
+/* index to next available random data */
+static int indexDrbgData = 0;
+static CpaBoolean qat_rand_inited = CPA_FALSE;
+static pthread_mutex_t qat_rand_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+/* Previously set GetEntropy function pointer - used to unregister */
+static IcpSalDrbgGetEntropyInputFunc pPrevGetEntropyInputFunc = NULL;
+/* Previously set GetNonce function pointer - used to unregister */
+static IcpSalDrbgGetNonceFunc pPrevGetNonceFunc = NULL;
+/* Previously set IsDFReq function pointer - used to unregister */
+static IcpSalDrbgIsDFReqFunc pPrevDrbgIsDFReqFunc = NULL;
+
+/* Qat engine rand methods declaration */
+static int  qat_rand_bytes(unsigned char *buf, int num);
+static void qat_rand_cleanup(void);
+static int  qat_pseudorand_bytes(unsigned char *buf, int num);
+static int  qat_rand_status(void);
+
+static RAND_METHOD qat_rand_method =
+{
+    /* "QAT RAND method", */
+    NULL, /* seed */
+    qat_rand_bytes,
+    qat_rand_cleanup,
+    NULL, /*add */
+    qat_pseudorand_bytes,
+    qat_rand_status
+};
+
+RAND_METHOD *get_RAND_methods(void)
+{
+    return &qat_rand_method;
+}
+
+/******************************************************************************
+* function:
+*         qatNrbgCallback(void *pCallbackTag, CpaStatus status, void *pOpdata,
+*                                 CpaFlatBuffer *pOut)
+*
+* @param pCallbackTag[IN]  - pointer to callback data
+* @param status      [IN]  - return status of the driver operation perform
+* @param pOpdata     [IN]  - pointer to operational data
+* @param pOut        [IN]  - pointer containing perform op output
+*
+*
+* description:
+*    NRBG callback - following call to nrbgGetEntropy
+******************************************************************************/
+static void qatNrbgCallback(void *pCallbackTag, CpaStatus status, void *pOpdata,
+                            CpaFlatBuffer *pOut)
+{
+    qat_nrbg_callback_data_t *pNrbgData = NULL;
+    IcpSalDrbgGetEntropyInputCbFunc pClientCb = NULL;
+    void *pClientCallbackTag = NULL;
+    void *pClientOpData = NULL;
+    Cpa32U lengthReturned = 0;
+
+    DEBUG("[%s] --- Entry\n", __func__);
+
+    if (NULL == pCallbackTag)
+    {
+        WARN("[%s] --- pCallbackTag is null", __func__);
+        return;
+    }
+
+    pNrbgData = (qat_nrbg_callback_data_t *)pCallbackTag;
+
+    if (CPA_STATUS_SUCCESS == status)
+    {
+        lengthReturned = pNrbgData->opData.lengthInBytes;
+    }
+
+    pClientCb = pNrbgData->pClientCbFunc;
+    pClientCallbackTag = pNrbgData->pClientCallbackTag;
+    pClientOpData = pNrbgData->pClientOpData;
+
+    OPENSSL_free(pNrbgData);
+
+    if (pClientCb)
+    {
+        pClientCb(pClientCallbackTag, status, pClientOpData, 
+                  lengthReturned, pOut);
+    }
+}
+
+/* Internal function to populate/replenish the random data pool */
+static CpaStatus qat_drbgPerformOp(void)
+{
+    CpaStatus status = CPA_STATUS_SUCCESS;
+    CpaCyDrbgGenOpData *pOpData = NULL;
+    struct op_done *opDone = NULL;
+    CpaFlatBuffer *pDrbgOut = NULL;
+    int qatPerformOpRetries = 0;
+    int iMsgRetry = getQatMsgRetryCount();
+    useconds_t ulPollInterval = getQatPollInterval();
+
+    DEBUG("[%s]: --- Entry\n", __func__);
+    /* pDrbgOut will hold the pool address to populate and the size requested */
+    pDrbgOut = OPENSSL_malloc(sizeof(CpaFlatBuffer));
+    if (NULL == pDrbgOut)
+    {
+        WARN("[%s]: --- failed to allocate memory\n", __func__);
+        return CPA_STATUS_FAIL;
+    }
+
+    pOpData = OPENSSL_malloc(sizeof(CpaCyDrbgGenOpData));
+    if (NULL == pOpData)
+    {
+        WARN("[%s]: --- failed to allocate memory\n", __func__);
+        OPENSSL_free(pDrbgOut);
+        return CPA_STATUS_FAIL;
+    }
+
+    pDrbgOut->pData = pDrbgData;
+    pDrbgOut->dataLenInBytes = QAT_RAND_BLOCK_SIZE;
+
+    pOpData->sessionHandle = sessionHandle;
+    pOpData->lengthInBytes = QAT_RAND_BLOCK_SIZE;
+    pOpData->secStrength = CPA_CY_RBG_SEC_STRENGTH_256;
+    pOpData->predictionResistanceRequired = CPA_FALSE;
+    pOpData->additionalInput.dataLenInBytes = 0;
+    pOpData->additionalInput.pData = NULL;
+    do
+    {
+        status = cpaCyDrbgGen(instanceHandle,
+                              (void *)opDone, /* data sent as is to the callback function*/
+                              pOpData,        /* operational data struct */
+                              pDrbgOut);      /* dst buffer struct */
+        if (CPA_STATUS_RETRY == status)
+        {
+            usleep(ulPollInterval + (qatPerformOpRetries % QAT_RETRY_BACKOFF_MODULO_DIVISOR));
+            qatPerformOpRetries++;
+        }
+    }
+    while (CPA_STATUS_RETRY == status &&
+              ((qatPerformOpRetries < iMsgRetry) || (iMsgRetry == QAT_INFINITE_MAX_NUM_RETRIES)));
+
+    if (CPA_STATUS_SUCCESS != status)
+    {
+        WARN("[%s]: --- failed to generate, status = %d\n", __func__, status);
+        OPENSSL_free(pDrbgOut);
+        OPENSSL_free(pOpData);
+        return CPA_STATUS_FAIL;
+    }
+
+    OPENSSL_free(pDrbgOut);
+    OPENSSL_free(pOpData);
+    
+    return status;
+}
+
+/******************************************************************************
+* function:
+*         nrbgGetEntropy(IcpSalDrbgGetEntropyInputCbFunc pCb,
+*                         void * pCallbackTag,
+*                         icp_sal_drbg_get_entropy_op_data_t *pOpData,
+*                         CpaFlatBuffer *pBuffer,
+*                         Cpa32U *pLengthReturned)
+*
+* @param pCb            [IN]  - pointer to client callback function to be executed in this cb
+* @param pCallbackTag   [IN]  - callback data passed to the perform
+* @param pOpdata        [IN]  - pointer to operational data
+* @param pBuffer        [IN]  - pointer to receive perform data
+* @param pLengthReturned[IN]  - pointer to len received
+*
+* @retval CPA_STATUS_INVALID_PARAM - invalid parameter passed  
+* @retval CPA_STATUS_FAIL - function failed  
+* @retval CPA_STATUS_SUCCESS - function passed  
+*
+* description:
+*   NRBG interface to ensure high entropy when making DRBG calls. 
+*   This will be called by the driver on registration and subsequently during 
+*   a DRBG request when the seed life defined in the driver expires
+******************************************************************************/
+static CpaStatus nrbgGetEntropy(IcpSalDrbgGetEntropyInputCbFunc pCb,
+                                void * pCallbackTag,
+                                icp_sal_drbg_get_entropy_op_data_t *pOpData,
+                                CpaFlatBuffer *pBuffer,
+                                Cpa32U *pLengthReturned)
+{
+    CpaStatus status = CPA_STATUS_SUCCESS;
+    CpaCyGenFlatBufCbFunc pNrbgCbFunc = NULL;
+    qat_nrbg_callback_data_t *pNrbgData = NULL;
+    int qatPerformOpRetries = 0;
+    int iMsgRetry = getQatMsgRetryCount();
+    useconds_t ulPollInterval = getQatPollInterval();
+
+    DEBUG("[%s]: --- Entry\n", __func__);
+
+    if (NULL == pOpData)
+    {
+        WARN("[%s]: --- Invalid parameter pOpData\n", __func__);
+        return CPA_STATUS_INVALID_PARAM;
+    }
+
+    if (NULL == pLengthReturned)
+    {
+        WARN("[%s]: --- Invalid parameter pLengthReturned\n", __func__);
+        return CPA_STATUS_INVALID_PARAM;
+    }
+
+    pNrbgData = OPENSSL_malloc(sizeof(qat_nrbg_callback_data_t));
+    if (NULL == pNrbgData)
+    {
+        WARN("[%s]: --- Failed to allocate pNrbgData\n", __func__);
+        return CPA_STATUS_FAIL;
+    }
+
+    /* number of bytes to be generated */
+    pNrbgData->opData.lengthInBytes = pOpData->maxLength;
+
+    /* store client information */
+    pNrbgData->pClientCbFunc = pCb;
+    pNrbgData->pClientCallbackTag = pCallbackTag;
+    pNrbgData->pClientOpData = (void *)pOpData;
+
+    /* use local callback function on asynchronous operation */
+    if (NULL != pCb) /* want to call this callback in qatNrbgCallback */
+    {
+        pNrbgCbFunc = qatNrbgCallback;
+    }
+
+    do {
+        status = cpaCyNrbgGetEntropy(instanceHandle,
+                                     pNrbgCbFunc, pNrbgData, 
+                                     &(pNrbgData->opData), pBuffer);
+        if (CPA_STATUS_RETRY == status)
+        {
+            usleep(ulPollInterval + (qatPerformOpRetries % QAT_RETRY_BACKOFF_MODULO_DIVISOR));
+            qatPerformOpRetries++;
+        }
+    }
+    while (CPA_STATUS_RETRY == status &&
+              ((qatPerformOpRetries < iMsgRetry) || (iMsgRetry == QAT_INFINITE_MAX_NUM_RETRIES)));
+
+    if (CPA_STATUS_SUCCESS != status)
+    {
+        status = (CPA_STATUS_INVALID_PARAM == status)? status: CPA_STATUS_FAIL;
+        WARN("[%s]: --- cpaCyNrbgGetEntropy failed, status = %d\n", __func__, status);
+        OPENSSL_free(pNrbgData);
+        return status;
+    }
+
+    if (NULL == pCb)
+    {
+        *pLengthReturned = pNrbgData->opData.lengthInBytes;
+        OPENSSL_free(pNrbgData);
+    }
+
+    return CPA_STATUS_SUCCESS;
+}
+
+/******************************************************************************
+* function:
+*         nrbgGetNonce(icp_sal_drbg_get_entropy_op_data_t *pOpData,
+*                         CpaFlatBuffer *pBuffer,
+*                         Cpa32U *pLengthReturned)
+*
+* @param pOpdata        [IN]  - pointer to operational data
+* @param pBuffer        [IN]  - pointer to receive perform data
+* @param pLengthReturned[IN]  - pointer to len received
+*
+* @retval CpaStatus - function return status  
+*
+* description:
+*   NRBG interface to ensure high entropy when making DRBG calls. 
+******************************************************************************/
+static CpaStatus nrbgGetNonce(icp_sal_drbg_get_entropy_op_data_t *pOpData,
+                              CpaFlatBuffer *pBuffer,
+                              Cpa32U *pLengthReturned)
+{
+    CpaStatus status = CPA_STATUS_SUCCESS;
+
+    DEBUG("[%s] --- Entry\n", __func__);
+
+    status = nrbgGetEntropy(NULL, NULL, pOpData, pBuffer, pLengthReturned);
+    if (CPA_STATUS_SUCCESS != status)
+    {
+        WARN("[%s] --- nrbgGetEntropy failed, status = %d\n", __func__, status);
+    }
+
+    return status;
+}
+
+/******************************************************************************
+* function:
+*         nrbgIsDFRequired()
+*
+* @retval CPA_TRUE - is required  
+* @retval CPA_FALSE - is not required  
+*
+* description:
+*   NRBG interface to ensure high entropy when making DRBG calls. 
+******************************************************************************/
+static CpaBoolean nrbgIsDFRequired(void)
+{
+    DEBUG("[%s] --- Entry\n", __func__);
+    return CPA_FALSE;
+}
+
+/******************************************************************************
+* function:
+*         nrbgRegisterDrbgImplFunctions()
+*
+* description:
+*   NRBG interface to register nrbg functions
+******************************************************************************/
+void nrbgRegisterDrbgImplFunctions(void)
+{
+    DEBUG("[%s] --- Entry\n", __func__);
+
+    pPrevGetEntropyInputFunc =
+        icp_sal_drbgGetEntropyInputFuncRegister(nrbgGetEntropy);
+    pPrevGetNonceFunc =
+        icp_sal_drbgGetNonceFuncRegister(nrbgGetNonce);
+    pPrevDrbgIsDFReqFunc =
+        icp_sal_drbgIsDFReqFuncRegister(nrbgIsDFRequired);
+}
+
+/******************************************************************************
+* function:
+*         nrbgRegisterDrbgImplFunctions()
+*
+* description:
+*   NRBG interface to unregister nrbg interfaces
+******************************************************************************/
+void nrbgUnregisterDrbgImplFunctions(void)
+{
+    DEBUG("[%s] --- Entry\n", __func__);
+
+    icp_sal_drbgGetEntropyInputFuncRegister(pPrevGetEntropyInputFunc);
+    icp_sal_drbgGetNonceFuncRegister(pPrevGetNonceFunc);
+    icp_sal_drbgIsDFReqFuncRegister(pPrevDrbgIsDFReqFunc);
+}
+
+size_t OPENSSL_ia32_rdrand(void);
+
+/******************************************************************************
+* function:
+*         rdrand_random_bytes(unsigned char *buf, int num)
+* @param buf    [IN]  - pointer to buffer
+* @param num    [IN]  - number of bytes to generate
+* @retval 1 - success
+* @retval 0 - fail
+*
+* description:
+*   Function that generates random bytes using RDRAND cpu instruction
+******************************************************************************/
+static int rdrand_random_bytes (unsigned char *buf, int num)
+{
+    size_t rnd;
+
+    while (num>=(int)sizeof(size_t)) {
+        if ((rnd = OPENSSL_ia32_rdrand()) == 0) return 0;
+
+        *((size_t *)buf) = rnd;
+        buf += sizeof(size_t);
+        num -= sizeof(size_t);
+    }
+    if (num) {
+        if ((rnd = OPENSSL_ia32_rdrand()) == 0) return 0;
+
+        memcpy (buf,&rnd,num);
+    }
+
+    return 1;
+}
+#define RDRAND_MASK     0x40000000
+
+/******************************************************************************
+ * function:
+ *          getCpuidRdrand()
+ * @retval 0 - no rdrand support
+ * @retval 1 - rdrand support present
+ *
+ * check the 30th bit of the ecx register after calling cpuid.
+ *
+  ******************************************************************************/
+int getCpuidRdrand()
+{
+        int reg[4] = {0, 0, 0, 0};
+
+         asm volatile(
+#ifndef __x86_64__
+                 "mov %%ebx, %%edi;"
+                 "cpuid;"
+                 "xchgl %%ebx, %%edi;"
+                 :"=a"(reg[0]),
+                  "=D"(reg[1]),
+#else
+                  "cpuid"
+                  :"=a"(reg[0]),
+                   "=b"(reg[1]),
+#endif
+                  "=c"(reg[2]),
+                  "=d"(reg[3]):
+                  "a"(1));
+
+         if ((reg[2] & RDRAND_MASK) == RDRAND_MASK)
+                 return 1;
+         else
+                 return 0;
+}
+
+/******************************************************************************
+* function:
+*         qat_rand_initialise(void)
+*
+* @retval 1 - success 
+* @retval 0 - fail 
+*
+* description:
+*   External interface to initialise random number generator.If the CPU supports
+*   RDRAND instruction it will be used for random number generation, if not the initialision
+*   tries to get an NRBG capable crypto instance, initialises a session and sets up
+*   the random number data cache via a synchronous call to the QAT driver. If on NRBG
+*   capable instances are found the default openssl software rand inmplementation
+*   will be used.
+******************************************************************************/
+int qat_rand_initialise(void)
+{
+    CpaStatus status = CPA_STATUS_SUCCESS;
+    CpaCyCapabilitiesInfo cap = {0};
+    CpaCyDrbgSessionSetupData sessionSetupData = { 0 };
+    Cpa32U sessionSize = 0;
+    Cpa32U seedLen = 0;
+    Cpa16U num_instances = 0;
+
+    RAND_METHOD * rand_meth;
+
+    DEBUG("[%s] --- Entry\n", __func__);
+
+
+    pthread_mutex_lock(&qat_rand_mutex);
+    if (CPA_TRUE == qat_rand_inited)
+    {
+        WARN("[%s]: --- already initialised\n", __func__);
+        pthread_mutex_unlock(&qat_rand_mutex);
+        return 0;
+    }
+    
+    /* Check if CPU has rdrand, if yes use rdrand */
+    if (getCpuidRdrand())
+    {
+        qat_rand_method.seed = NULL;
+        qat_rand_method.bytes = rdrand_random_bytes;
+        qat_rand_method.cleanup = NULL;
+        qat_rand_method.add = NULL;
+        qat_rand_method.pseudorand = rdrand_random_bytes;
+        qat_rand_method.status = qat_rand_status;
+        pthread_mutex_unlock(&qat_rand_mutex);
+        return 1;
+    }
+#ifdef OPENSSL_DISABLE_QAT_OFFLOAD_RAND
+    else
+    {
+	/* Currently there is an issue with DRBG operations being run
+           in the context of the callback thread. As a temporary measure
+           we are defaulting DRBG to use software unless the cpu has
+           on core rd_rand functionality in which case use that */ 
+        WARN("[%s]: Using default SW rand implementation\n", __func__);
+        rand_meth = RAND_SSLeay();
+        if (rand_meth)
+        {
+            qat_rand_method.seed = rand_meth->seed;
+            qat_rand_method.bytes = rand_meth->bytes;
+            qat_rand_method.cleanup = rand_meth->cleanup;
+            qat_rand_method.add = rand_meth->add;
+            qat_rand_method.pseudorand = rand_meth->pseudorand;
+            qat_rand_method.status = rand_meth->status;
+            pthread_mutex_unlock(&qat_rand_mutex);
+            return 1;
+        }
+        pthread_mutex_unlock(&qat_rand_mutex);
+        return 0;
+    }
+#endif
+
+    status = cpaCyGetNumInstances(&num_instances);
+    if(CPA_STATUS_SUCCESS != status)
+    {
+        WARN("[%s]: --- unable to get number of QAT instances, status = %d\n", 
+             __func__, status);
+        pthread_mutex_unlock(&qat_rand_mutex);
+        return 0;
+    }
+
+    DEBUG("[%s] --- %d QAT instances detected\n", __func__, num_instances);
+
+    instanceHandle = get_next_inst();
+    /* Verify that the instance has NRBG capabilities - not all CY instances do */
+    status = cpaCyQueryCapabilities(instanceHandle, &cap);
+    if(CPA_STATUS_SUCCESS != status)
+    {
+        WARN("[%s]: --- unable to get instance capabilities, status = %d\n", 
+             __func__, status);
+        pthread_mutex_unlock(&qat_rand_mutex);
+        return 0;
+    }
+
+    while(cap.nrbgSupported != CPA_TRUE && --num_instances > 0)
+    {
+        DEBUG("[%s]: --- QAT instance does not support NRBG, trying another\n", __func__);
+        instanceHandle = get_next_inst();
+        status = cpaCyQueryCapabilities(instanceHandle, &cap);
+        if(CPA_STATUS_SUCCESS != status)
+        {
+            WARN("[%s]: --- unable to get instance capabilities, status = %d\n", 
+                 __func__, status);
+            pthread_mutex_unlock(&qat_rand_mutex);
+            return 0;
+        }
+    }
+    
+    if (0 == num_instances)
+    {
+        WARN("[%s]: --- unable to get instance with NRBG capabilities\n", __func__);
+        WARN("[%s]: Using default SW rand implementation\n", __func__);
+        rand_meth = RAND_SSLeay();
+        if (rand_meth)
+        {
+            qat_rand_method.seed = rand_meth->seed;
+            qat_rand_method.bytes = rand_meth->bytes;
+            qat_rand_method.cleanup = rand_meth->cleanup;
+            qat_rand_method.add = rand_meth->add;
+            qat_rand_method.pseudorand = rand_meth->pseudorand;
+            qat_rand_method.status = rand_meth->status;
+            pthread_mutex_unlock(&qat_rand_mutex);
+            return 1;
+        }
+        pthread_mutex_unlock(&qat_rand_mutex);
+        return 0;
+    }
+
+    /* Register get entropy functions - these will be called during InitSession */
+    nrbgRegisterDrbgImplFunctions();
+
+    /* initialise session data */
+    sessionSetupData.predictionResistanceRequired = CPA_TRUE;
+    sessionSetupData.secStrength = CPA_CY_RBG_SEC_STRENGTH_256;
+    sessionSetupData.personalizationString.dataLenInBytes = 0;
+    sessionSetupData.personalizationString.pData = NULL;
+	
+    /* Determine size of session to allocate */
+    status = cpaCyDrbgSessionGetSize(instanceHandle,
+                                     &sessionSetupData, &sessionSize);
+
+    if (CPA_STATUS_SUCCESS != status)
+    {
+        WARN("[%s]: --- unable to get session size\n", __func__);
+        nrbgUnregisterDrbgImplFunctions();
+        pthread_mutex_unlock(&qat_rand_mutex);
+        return 0;
+    }
+    else
+    {
+        /* Allocate memory for the session */
+        sessionHandle = (CpaCyDrbgSessionHandle) qaeCryptoMemAlloc(sessionSize, __FILE__, __LINE__);
+    }
+
+    if (NULL == sessionHandle)
+    {
+        WARN("[%s]: --- unable to allocate memory for session\n", __func__);
+        nrbgUnregisterDrbgImplFunctions();
+        pthread_mutex_unlock(&qat_rand_mutex);
+        return 0;
+    }
+        
+    /* Initialise the session */
+    status = cpaCyDrbgInitSession(instanceHandle,
+                                  NULL,                /* synchronous */
+                                  NULL,                /* callback function for reseed */
+                                  &sessionSetupData,   /* session setup data */
+                                  sessionHandle,
+                                  &seedLen);
+
+    if (status != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s]: --- failed to start session\n", __func__);
+        nrbgUnregisterDrbgImplFunctions();
+        qaeCryptoMemFree(sessionHandle);
+        pthread_mutex_unlock(&qat_rand_mutex);
+        return 0;
+    }
+
+    /* request memory for random data cache */
+    pDrbgData = (Cpa8U *) qaeCryptoMemAlloc(QAT_RAND_BLOCK_SIZE, __FILE__, __LINE__);
+    if (NULL == pDrbgData)
+    {
+        WARN("[%s]: --- failed to allocate memory\n", __func__);
+        pthread_mutex_unlock(&qat_rand_mutex);
+        qat_rand_cleanup();
+        return 0;
+    }
+
+    /* need to initialise the whole cache of random data - synchronously */
+    status = qat_drbgPerformOp();
+    if (status != CPA_STATUS_SUCCESS)
+    {
+        pthread_mutex_unlock(&qat_rand_mutex);
+        qat_rand_cleanup();
+        return 0;
+    }
+
+    qat_rand_inited = CPA_TRUE;
+    pthread_mutex_unlock(&qat_rand_mutex);
+
+    return 1;
+}
+
+/******************************************************************************
+* function:
+*         qat_rand_bytes(unsigned char *buf, int num)
+*
+* @param buf  [OUT] - pointer to client allocated buffer to place random bytes in
+* @param num  [IN]  - the number of random bytes requested
+*
+* @retval 1      function succeeded
+* @retval 0      function failed
+*
+* description:
+*    This function is called via the EVP interface to request random bytes
+*
+******************************************************************************/
+static int qat_rand_bytes(unsigned char *buf, int num)
+{
+    CpaStatus status = CPA_STATUS_SUCCESS;
+    
+    DEBUG("[%s] --- Entry, buf [%p], num [%d] - index [%d]\n", __func__, 
+          buf, num, indexDrbgData);
+
+    if (NULL == buf)
+    {
+        WARN("[%s]: --- NULL pointer passed\n", __func__);
+        return 0; /* fail */
+    }
+    
+    if (num <= 0 || num > QAT_RAND_BLOCK_SIZE)
+    {
+        WARN("[%s]: --- requested %d bytes, while range is 1 to %d\n",
+               __func__, num, QAT_RAND_BLOCK_SIZE);
+        return 0; /* fail */
+    }
+
+    pthread_mutex_lock(&qat_rand_mutex);
+
+    if (CPA_FALSE == qat_rand_inited)
+    {
+        WARN("[%s]: --- QAT RAND not initialised\n",__func__);
+        pthread_mutex_unlock(&qat_rand_mutex);
+        return 0;
+    }
+
+    /* check if we are near the end - replenish */
+    if ((QAT_RAND_BLOCK_SIZE - indexDrbgData) <= num)
+    {
+        /* jump to start - perform synchronous replenish */
+        indexDrbgData = 0;
+        /* replenish pool of random data */
+        status = qat_drbgPerformOp();
+        if (CPA_STATUS_SUCCESS != status)
+        {
+            WARN("[%s]: --- failed to PerformOp\n", __func__);
+            pthread_mutex_unlock(&qat_rand_mutex);
+            return 0;
+        }
+    }
+
+    /* copy output to client buffer */
+    DEBUG("[%s]: --- copying index[%d]\n", __func__, indexDrbgData);
+    memcpy (buf, pDrbgData + indexDrbgData, num);
+
+    /* adjust index to random data cache */
+    indexDrbgData = indexDrbgData + num;
+
+    pthread_mutex_unlock(&qat_rand_mutex);
+    return 1;
+}
+
+/******************************************************************************
+* function:
+*         qat_rand_cleanup(void)
+*
+* description:
+*    This function is called via the EVP interface to clean up
+*
+******************************************************************************/
+static void qat_rand_cleanup(void)
+{
+    CpaStatus status = CPA_STATUS_SUCCESS;
+    unsigned int count = 0;
+    struct timespec reqTime = {0};
+	struct timespec remTime = {0};
+
+    DEBUG("[%s] --- Entry\n", __func__);
+
+    pthread_mutex_lock(&qat_rand_mutex);
+    if (qat_rand_inited && instanceHandle && sessionHandle)
+    {
+        /* Remove Session - retry if necessary */
+        status = cpaCyDrbgRemoveSession(instanceHandle, sessionHandle);
+        while ((CPA_STATUS_RETRY == status) && (count < QAT_RAND_CLEANUP_RETRY_COUNT)) 
+        {
+            /* Wait a while before retry */
+            count++;
+            reqTime.tv_nsec = QAT_RAND_CLEANUP_WAIT_TIME_NS;
+            do 
+            {
+                nanosleep(&reqTime, &remTime);
+				reqTime.tv_sec = remTime.tv_sec;
+                reqTime.tv_nsec = remTime.tv_nsec;
+                if((errno < 0) && (EINTR != errno))
+                {
+                    WARN("[%s]: --- nanosleep system call failed: errno %i\n", 
+                         __func__, errno);
+                    break;
+                }
+            } while (EINTR == errno);
+
+            status = cpaCyDrbgRemoveSession(instanceHandle, sessionHandle);
+        }
+
+        if (CPA_STATUS_SUCCESS != status)
+        {
+            WARN("[%s]: --- failed to remove session\n", __func__);
+        }
+
+        /* Free up memory */
+        qaeCryptoMemFree(sessionHandle);
+    }
+
+    /* Free up memory */
+    if (NULL != pDrbgData)
+    {
+        qaeCryptoMemFree(pDrbgData);
+        pDrbgData = NULL;
+    }
+
+    nrbgUnregisterDrbgImplFunctions();
+
+    qat_rand_inited = CPA_FALSE;
+
+    pthread_mutex_unlock(&qat_rand_mutex);
+}
+
+/******************************************************************************
+* function:
+*         qat_pseudorand_bytes(unsigned char *buf, int num)
+*
+* @param buf  [OUT] - pointer to client allocated buffer to place random bytes in
+* @param num  [IN]  - the number of random bytes requested
+*
+* @retval 1      function succeeded
+* @retval 0      function failed
+*
+* description:
+*    This function is called via the EVP interface to request pseudo random bytes
+*
+******************************************************************************/
+static int qat_pseudorand_bytes(unsigned char *buf, int num)
+{
+    DEBUG("[%s] --- Entry, buf [%p] and num [%d]\n", __func__, buf, num);
+
+    return qat_rand_bytes (buf, num);
+}
+
+/******************************************************************************
+* function:
+*         qat_rand_status(void)
+*
+* @retval 1      function succeeded
+*
+* description:
+*    This function is called via the EVP interface to request status of entropy
+*    Since this is something we manage internally, always return ok
+*
+******************************************************************************/
+static int qat_rand_status(void)
+{
+    DEBUG("[%s] --- Entry\n", __func__);
+
+    return 1;
+}
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_rand.h ./engines/qat_engine/qat_rand.h
--- ../openssl-async/engines/qat_engine/qat_rand.h	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_rand.h	2015-03-05 12:43:44.281962000 +0000
@@ -0,0 +1,65 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qat_rand.h
+ *
+ * This file provides a random number generator interface for an OpenSSL engine
+ *
+ *****************************************************************************/
+
+#ifndef QAT_RAND_H
+#define QAT_RAND_H
+
+#include <openssl/rand.h>
+
+int qat_rand_initialise (void);
+RAND_METHOD *get_RAND_methods(void);
+
+#endif //QAT_RAND_H
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_rsa.c ./engines/qat_engine/qat_rsa.c
--- ../openssl-async/engines/qat_engine/qat_rsa.c	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_rsa.c	2015-03-05 12:43:44.283957000 +0000
@@ -0,0 +1,1526 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qat_rsa.c
+ *
+ * This file contains the engine implementations for RSA operations
+ *
+ *****************************************************************************/
+
+/* macros defined to allow use of the cpu get and set affinity functions */
+#define _GNU_SOURCE
+#define __USE_GNU
+
+#include <openssl/rsa.h>
+#include <string.h>
+#include <pthread.h>
+#include <unistd.h>
+#ifdef USE_QAT_MEM
+#include "qae_mem_utils.h"
+#endif
+#ifdef USE_QAE_MEM
+#include "qat_mem_drv_inf.h"
+#endif
+#include "qat_utils.h"
+#include "e_qat.h"
+
+#include "cpa.h"
+#include "cpa_types.h"
+
+#include "cpa_cy_rsa.h"
+#include "qat_rsa.h"
+#include "qat_asym_common.h"
+#include "e_qat_err.h"
+
+#ifdef OPENSSL_ENABLE_QAT_RSA_SYNCH
+#ifdef OPENSSL_DISABLE_QAT_RSA_SYNCH
+#undef OPENSSL_DISABLE_QAT_RSA_SYNCH
+#endif
+#endif
+
+#ifdef OPENSSL_ENABLE_QAT_RSA_ASYNCH
+#ifdef OPENSSL_DISABLE_QAT_RSA_ASYNCH
+#undef OPENSSL_DISABLE_QAT_RSA_ASYNCH
+#endif
+#endif
+
+#ifndef OPENSSL_QAT_ASYNCH
+#define OPENSSL_DISABLE_QAT_RSA_ASYNCH
+#define RSA_FLAG_ASYNCH 0
+#endif
+
+#define QAT_RSA_PERFORMOP_RETRIES_SYNC 3
+#define QAT_RSA_PERFORMOP_RETRIES_ASYNC 0
+
+/* Callback to indicate QAT completion of RSA. */
+void qat_rsaCallbackFn(void *pCallbackTag,
+                       CpaStatus status, void *pOpData, CpaFlatBuffer * pOut);
+
+static RSA_METHOD qat_rsa_method = {
+    "QAT RSA method",           /* name */
+    qat_rsa_pub_enc_synch,            /* rsa_pub_enc */
+    qat_rsa_pub_dec_synch,            /* rsa_pub_dec */
+    qat_rsa_priv_enc_synch,           /* rsa_priv_enc */
+    qat_rsa_priv_dec_synch,           /* rsa_priv_dec */
+    NULL,                       /* rsa_mod_exp */
+    NULL,                       /* bn_mod_exp */
+    NULL,                       /* init */
+    NULL,                       /* finish */
+    RSA_FLAG_ASYNCH,            /* flags */
+    NULL,                       /* app_data */
+    NULL,                       /* rsa_sign */
+    NULL,                       /* rsa_verify */
+    NULL,                       /* rsa_keygen */
+#ifdef OPENSSL_QAT_ASYNCH
+    qat_rsa_pub_enc_asynch,     /* rsa_pub_enc_asynch */
+    qat_rsa_pub_dec_asynch,     /* rsa_pub_dec_asynch */
+    qat_rsa_priv_enc_asynch,    /* rsa_priv_enc_asynch */
+    qat_rsa_priv_dec_asynch     /* rsa_priv_dec_asynch */
+#endif
+};
+
+RSA_METHOD *get_RSA_methods(void)
+{
+#ifdef OPENSSL_DISABLE_QAT_RSA_SYNCH
+#ifndef OPENSSL_DISABLE_QAT_RSA_ASYNCH
+    const RSA_METHOD* def_rsa_meth = RSA_get_default_method();
+
+    qat_rsa_method.rsa_pub_enc  = def_rsa_meth->rsa_pub_enc;
+    qat_rsa_method.rsa_pub_dec  = def_rsa_meth->rsa_pub_dec;
+    qat_rsa_method.rsa_priv_enc = def_rsa_meth->rsa_priv_enc;
+    qat_rsa_method.rsa_priv_dec = def_rsa_meth->rsa_priv_dec;
+    qat_rsa_method.rsa_mod_exp  = def_rsa_meth->rsa_mod_exp;
+    qat_rsa_method.bn_mod_exp   = def_rsa_meth->bn_mod_exp;
+    qat_rsa_method.init         = def_rsa_meth->init;
+    qat_rsa_method.finish       = def_rsa_meth->finish;
+#endif
+#endif
+
+#ifdef OPENSSL_QAT_ASYNCH
+#ifndef OPENSSL_DISABLE_QAT_RSA_SYNCH
+#ifdef OPENSSL_DISABLE_QAT_RSA_ASYNCH
+    qat_rsa_method.flags = 0;
+    qat_rsa_method.rsa_pub_enc_asynch = NULL;
+    qat_rsa_method.rsa_pub_dec_asynch = NULL;
+    qat_rsa_method.rsa_priv_enc_asynch = NULL;
+    qat_rsa_method.rsa_priv_dec_asynch = NULL;
+#endif
+#endif
+#endif
+
+#ifdef OPENSSL_DISABLE_QAT_RSA_SYNCH
+#ifdef OPENSSL_DISABLE_QAT_RSA_ASYNCH
+    return NULL;
+#endif
+#endif
+    return &qat_rsa_method;
+}
+
+/******************************************************************************
+* function:
+*         qat_alloc_pad(unsigned char *in,
+*                       int len,
+*                       int rLen,
+*                       int sign)
+*
+* @param in   [IN] - pointer to Flat Buffer
+* @param len  [IN] - length of input data (hash)
+* @param rLen [IN] - length of RSA
+* @param sign [IN] - 1 for sign operation and 0 for decryption
+*
+* description:
+*   This function is used to add PKCS#1 padding into input data buffer
+*   before it pass to cpaCyRsaDecrypt() function.
+*   The function returns a pointer to unsigned char buffer
+******************************************************************************/
+static unsigned char *qat_alloc_pad(unsigned char *in, int len,
+                                    int rLen, int sign)
+{
+    int i = 0;
+
+    /* out data buffer should have fix length */
+    unsigned char *out = qaeCryptoMemAlloc(rLen, __FILE__, __LINE__);
+
+    if (NULL == out)
+    {
+        WARN("[%s] --- out buffer malloc failed.\n", __func__);
+        return NULL;
+    }
+
+    /* First two char are (0x00, 0x01) or (0x00, 0x02) */
+    out[0] = 0x00;
+
+    if(sign)
+    {
+        out[1] = 0x01;
+    }
+    else
+    {
+        out[1] = 0x02;
+    }
+
+    /* Fill 0xff and end up with 0x00 in out buffer until the length of
+       actual data space left */
+    for (i = 2; i < (rLen - len - 1); i++)
+    {
+        out[i] = 0xff;
+    }
+    /* i has been incremented on beyond the last padding byte to exit for loop */
+    out[i] = 0x00;
+
+    /* shift actual data to the end of out buffer */
+    memcpy((out + rLen - len), in, len);
+
+    return out;
+}
+
+/******************************************************************************
+* function:
+*         qat_data_len(unsigned char *in
+*                      int  rLen, int sign)
+*
+* @param in   [IN] - pointer to Flat Buffer
+* @param rLen [IN] - length of RSA
+* @param sign [IN] - 1 for sign operation and 0 for decryption
+*
+* description:
+*   This function is used to calculate the length of actual data
+*   and padding size inside of outputBuffer returned from cpaCyRsaEncrypt() function.
+*   The function counts the padding length (i) and return the length
+*   of actual data (dLen) contained in the outputBuffer
+******************************************************************************/
+static int qat_data_len(unsigned char *in, int rLen, int sign)
+{
+    /* first two bytes are 0x00, 0x01 */
+    int i = 0;
+    int dLen = 0;
+    int pLen = 0;
+
+    /* First two char of padding should be 0x00, 0x01 */
+    if(sign)
+    {
+        /* First two char of padding should be 0x00, 0x01 */
+        if(in[0] != 0x00 || in[1] != 0x01)
+        {
+            WARN("[%s] --- [%d] Padding format unknown!\n", __func__, sign);
+            return 0;
+        }
+    }
+    else
+    {
+        /* First two char of padding should be 0x00, 0x02 for decryption */
+        if(in[0] != 0x00 || in[1] != 0x02)
+        {
+            WARN("[%s] --- [%d] Padding format unknown!\n", __func__, sign);
+            return 0;
+        }
+    }
+
+    /* while loop is design to reach the 0x00 value and count all the 0xFF
+       value where filled by PKCS#1 padding */
+    while (in[i + 2] != 0x00 && i < rLen)
+           i++;
+
+    /* padding length = 2 + length of 0xFF + 0x00 */
+    pLen = 2 + i + 1;
+    dLen = rLen - pLen;
+
+    return dLen;
+}
+
+/******************************************************************************
+* function:
+*         qat_remove_pad(unsigned char *in,
+*                        int len,
+*                        int rLen,
+*                        int sign)
+*
+* @param in   [IN] - pointer to Flat Buffer
+* @param len  [IN] - length of output buffer
+* @param rLen [IN] - length of RSA
+* @param sign [IN] - 1 for sign operation and 0 for decryption
+*
+* description:
+*   This function is used to remove PKCS#1 padding from outputBuffer
+*   after cpaCyRsaEncrypt() function during RSA verify.
+******************************************************************************/
+static int qat_remove_pad(unsigned char *out, unsigned char *in,
+                          int r_len, int* out_len, int sign)
+{
+    int p_len = 0;
+    int d_len = 0;
+
+    if (0 == (d_len = qat_data_len(in, r_len, sign)))
+    {
+        return 0;
+    }
+    p_len = r_len - d_len;
+
+    /* shift actual data to the beginning of out buffer */
+    memcpy(out, in + p_len, d_len);
+    *out_len = d_len;
+
+    return 1;
+}
+
+/******************************************************************************
+* function:
+*         qat_rsaCallbackFn(void *pCallbackTag, CpaStatus status,
+*                           void *pOpData, CpaFlatBuffer * pOut)
+*
+* @param instanceHandle [IN]  - Instance handle.
+* @param pRsaEncryptCb  [IN]  - Pointer to callback function to be invoked
+*                               when the operation is complete.
+* @param pCallbackTag   [IN]  - Opaque User Data for this specific call. Will
+*                               be returned unchanged in the callback.
+* @param pEncryptOpData [IN]  - Structure containing all the data needed to
+*                               perform the RSA encryption operation.
+* @param pOutputData    [Out] - Pointer to structure into which the result of
+*                               the RSA encryption primitive is written.
+* description:
+*   Callback function used by cpaCyRsaEncrypt to indicate completion.
+*   Calls back to qat_crypto_callbackFn().
+*
+******************************************************************************/
+void qat_rsaCallbackFn(void *pCallbackTag, CpaStatus status, void *pOpData,
+                       CpaFlatBuffer * pOut)
+{
+    qat_crypto_callbackFn(pCallbackTag, status, CPA_CY_SYM_OP_CIPHER, pOpData,
+                   NULL, CPA_FALSE);
+}
+
+typedef struct rsa_op_data
+{
+    CpaCyRsaPublicKey*  cpa_pub_key;
+    CpaCyRsaDecryptOpData* dec_op_data;
+    CpaCyRsaEncryptOpData* enc_op_data;
+    CpaFlatBuffer* output_buffer;
+    int rsa_len;
+    int padding;
+    unsigned char* cb_output;
+    int (*cb_func)(unsigned char *res, size_t reslen,
+                                  void *cb_data, int status);
+    void *cb_data;
+} rsa_op_data_t;
+
+#define NO_PADDING 0
+#define PADDING    1
+
+static void
+rsa_decrypt_op_buf_free(CpaCyRsaDecryptOpData* dec_op_data, CpaFlatBuffer* out_buf, int padding)
+{
+    if (dec_op_data)
+    {
+        if (dec_op_data->inputData.pData && (!isZeroCopy() || padding))
+            qaeCryptoMemFree(dec_op_data->inputData.pData);
+
+        if (dec_op_data->pRecipientPrivateKey)
+        {
+            if (dec_op_data->pRecipientPrivateKey->privateKeyRep2.prime1P.pData)
+                qaeCryptoMemFree(dec_op_data->pRecipientPrivateKey->privateKeyRep2.prime1P.pData);
+
+            if (dec_op_data->pRecipientPrivateKey->privateKeyRep2.prime2Q.pData)
+                qaeCryptoMemFree(dec_op_data->pRecipientPrivateKey->privateKeyRep2.prime2Q.pData);
+
+            if (dec_op_data->pRecipientPrivateKey->privateKeyRep2.exponent1Dp.pData)
+                qaeCryptoMemFree(dec_op_data->pRecipientPrivateKey->privateKeyRep2.exponent1Dp.pData);
+
+            if (dec_op_data->pRecipientPrivateKey->privateKeyRep2.exponent2Dq.pData)
+                qaeCryptoMemFree(dec_op_data->pRecipientPrivateKey->privateKeyRep2.exponent2Dq.pData);
+
+            if (dec_op_data->pRecipientPrivateKey->privateKeyRep2.coefficientQInv.pData)
+                qaeCryptoMemFree(dec_op_data->pRecipientPrivateKey->privateKeyRep2.coefficientQInv.pData);
+
+         OPENSSL_free(dec_op_data->pRecipientPrivateKey);
+        }
+        OPENSSL_free(dec_op_data);
+    }
+
+    if (out_buf)
+    {
+    if (!isZeroCopy() && out_buf->pData)
+        qaeCryptoMemFree (out_buf->pData);
+    OPENSSL_free (out_buf);
+    }
+}
+
+#ifdef OPENSSL_QAT_ASYNCH
+void
+qat_rsaDecryptAsynchCallbackFn(void *pCallbackTag, CpaStatus status, void *pOpData,
+                       CpaFlatBuffer * pOut)
+{
+    rsa_op_data_t* rsa_op_data = (rsa_op_data_t*)(pCallbackTag);
+    int cb_status = status == CPA_STATUS_SUCCESS ? 1 : 0;
+    int output_len = 0;
+
+    if (!rsa_op_data)
+    {
+        WARN("[%s] --- pCallbackTag NULL!\n",
+             __func__);
+        return;
+    }
+    else if (rsa_op_data->padding)
+    {
+        /* Copy output to output buffer */
+        if(qat_remove_pad(rsa_op_data->cb_output, pOut->pData, rsa_op_data->rsa_len,
+            &output_len, 0) != 1)
+        {
+            WARN("[%s] --- pData remove padding detected an error!\n",
+                 __func__);
+            cb_status = 0;
+        }
+    } else
+    {
+        if (!isZeroCopy())
+            memcpy (rsa_op_data->cb_output, rsa_op_data->output_buffer->pData,
+            rsa_op_data->rsa_len);
+    output_len = rsa_op_data->rsa_len;
+    }
+
+    /* Free all the memory allocated for this operation */
+    rsa_decrypt_op_buf_free(rsa_op_data->dec_op_data, pOut, !(rsa_op_data->padding) );
+
+    if (1 != cb_status)
+    {
+        /* set output all 0xff if failed */
+        DEBUG("[%s] --- cpaCyRsaDecrypt failed! \n", __func__);
+        memset(rsa_op_data->cb_output, 0xff, rsa_op_data->rsa_len);
+    }
+    else
+        DEBUG("[%s] --- cpaCyRsaDecrypt finished! \n", __func__);
+
+    /* Execute the user registered callback */
+    /* Return 128 bytes message buffer */
+    rsa_op_data->cb_func(rsa_op_data->cb_output, output_len,
+            rsa_op_data->cb_data, cb_status);
+    OPENSSL_free(rsa_op_data);
+}
+#endif
+
+int
+qat_rsa_decrypt(CpaCyRsaDecryptOpData *dec_op_data, CpaFlatBuffer *output_buf)
+{
+    struct op_done op_done;
+    CpaStatus sts = CPA_STATUS_FAIL;
+    int qatPerformOpRetries = 0;
+    CpaInstanceHandle instanceHandle = NULL;
+
+    int iMsgRetry = getQatMsgRetryCount();
+    useconds_t ulPollInterval = getQatPollInterval();
+    int rc = 1;
+
+    initOpDone(&op_done);
+
+    /* cpaCyRsaDecrypt() is the function called for RSA verify in API, the
+     * DecOpData [IN] contains both private key value and input file (hash)
+     * value, the outputBuffer [OUT] stores the signature as the output
+     * message, the sts value return 0 if successful */
+    do
+    {
+        if (NULL == (instanceHandle = get_next_inst()))
+        {
+            WARN("instanceHandle is NULL\n");
+			QATerr(QAT_F_QAT_RSA_DECRYPT, ERR_R_INTERNAL_ERROR);
+            cleanupOpDone(&op_done);
+            return 0;
+        }
+        sts = cpaCyRsaDecrypt(instanceHandle, qat_rsaCallbackFn, &op_done,
+                              dec_op_data, output_buf);
+        if (sts == CPA_STATUS_RETRY)
+        {
+            usleep(ulPollInterval + (qatPerformOpRetries % QAT_RETRY_BACKOFF_MODULO_DIVISOR));
+            qatPerformOpRetries++;
+        }
+    }
+    while (sts == CPA_STATUS_RETRY &&
+              ((qatPerformOpRetries < iMsgRetry) || (iMsgRetry == QAT_INFINITE_MAX_NUM_RETRIES)));
+
+    if (sts != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCyRsaDecrypt failed, sts=%d.\n", __func__, sts);
+		QATerr(QAT_F_QAT_RSA_DECRYPT, ERR_R_INTERNAL_ERROR);
+        cleanupOpDone(&op_done);
+        return 0;
+    }
+
+    rc = waitForOpToComplete(&op_done);
+    cleanupOpDone(&op_done);
+    if (rc) {
+        WARN("[%s] --- cpaCyRsaDecrypt timed out.\n", __func__);
+	    return 0;
+	}
+    return 1;
+}
+
+#ifdef OPENSSL_QAT_ASYNCH
+int
+qat_rsa_decrypt_asynch(CpaCyRsaDecryptOpData *dec_op_data,
+            CpaFlatBuffer* int_output, int length,
+            unsigned char* cb_output,
+             int (*cb)(unsigned char *res, size_t reslen,
+                                  void *cb_data, int status),
+                        void *cb_data,
+            int padding)
+{
+    CpaStatus sts = 1;
+    CpaInstanceHandle instanceHandle = NULL;
+    int qatPerformOpRetries = 0;
+
+    rsa_op_data_t *rsa_op_done = OPENSSL_malloc(sizeof(rsa_op_data_t));
+    if (NULL == rsa_op_done)
+    {
+        WARN("[%s] ---RSA OP DATA malloc failed!\n", __func__);
+        return 0;
+    }
+
+    rsa_op_done->dec_op_data = dec_op_data;
+    rsa_op_done->output_buffer = int_output;
+    rsa_op_done->rsa_len = length;
+    rsa_op_done->cb_output = cb_output;
+    rsa_op_done->cb_func = cb;
+    rsa_op_done->cb_data = cb_data;
+    rsa_op_done->padding = padding;
+
+    if (NULL == (instanceHandle = get_next_inst()))
+    {
+        WARN("instanceHandle is NULL\n");
+    OPENSSL_free(rsa_op_done);
+        return 0;
+    }
+
+    /* cpaCyRsaDecrypt() is the function called for RSA verify in API, the
+       DecOpData [IN] contains both private key value and input file (hash)
+       value, the outputBuffer [OUT] stores the signature as the output
+       message, the sts value return 0 if successful */
+    sts = cpaCyRsaDecrypt(instanceHandle, qat_rsaDecryptAsynchCallbackFn, rsa_op_done,
+                              dec_op_data, int_output);
+    if (sts != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCyRsaDecrypt failed, sts=%d.\n", __func__, sts);
+        if (sts == CPA_STATUS_RETRY)
+        {
+            qatPerformOpRetries++;
+            QATerr(QAT_F_QAT_RSA_DECRYPT_ASYNCH, ERR_R_RETRY);
+        }
+        OPENSSL_free(rsa_op_done);
+        return 0;
+    }
+
+    return 1;
+}
+#endif
+
+static int
+build_decrypt_op_buf(int flen, const unsigned char *from, unsigned char *to,
+                 RSA* rsa, int padding,
+         CpaCyRsaDecryptOpData** dec_op_data, CpaFlatBuffer** output_buffer,
+         int alloc_pad)
+{
+    int rsa_len = 0;
+    CpaCyRsaPrivateKey* cpa_prv_key = NULL;
+
+    cpa_prv_key =
+        (CpaCyRsaPrivateKey *) OPENSSL_malloc(sizeof(CpaCyRsaPrivateKey));
+    if (NULL == cpa_prv_key)
+    {
+        WARN("[%s] --- Private Key malloc failed!\n", __func__);
+        return 0;
+    }
+
+    DEBUG("[%s] --- flen =%d, padding = %d \n", __func__, flen, padding);
+    /* output signature should have same length as RSA(128) */
+    rsa_len = RSA_size(rsa);
+
+    /* output and input data MUST allocate memory for sign process */
+    /* memory allocation for DecOpdata[IN] */
+    *dec_op_data = OPENSSL_malloc (sizeof(CpaCyRsaDecryptOpData));
+    if (NULL == *dec_op_data)
+    {
+        WARN("[%s] --- OpData malloc failed!\n", __func__);
+        OPENSSL_free(cpa_prv_key);
+        return 0;
+    }
+
+    /* Setup the DecOpData structure */
+    (*dec_op_data)->pRecipientPrivateKey = cpa_prv_key;
+
+    /* Padding check */
+    if (padding != RSA_PKCS1_PADDING)
+    {
+        DEBUG("[%s] --- Unknown Padding!\n", __func__);
+        return 0;
+    }
+
+    cpa_prv_key->version = CPA_CY_RSA_VERSION_TWO_PRIME;
+
+    /* Setup the private key rep type 2 structure */
+    cpa_prv_key->privateKeyRepType = CPA_CY_RSA_PRIVATE_KEY_REP_TYPE_2;
+    if (qat_BN_to_FB(&cpa_prv_key->privateKeyRep2.prime1P, rsa->p) != 1 ||
+        qat_BN_to_FB(&cpa_prv_key->privateKeyRep2.prime2Q, rsa->q) != 1 ||
+        qat_BN_to_FB(&cpa_prv_key->privateKeyRep2.exponent1Dp, rsa->dmp1) != 1 ||
+        qat_BN_to_FB(&cpa_prv_key->privateKeyRep2.exponent2Dq, rsa->dmq1) != 1 ||
+        qat_BN_to_FB(&cpa_prv_key->privateKeyRep2.coefficientQInv, rsa->iqmp) != 1)
+    {
+        WARN("[%s] --- qat_BN_to_FB failed for privateKeyRep2 elements\n", __func__);
+        return 0;
+    }
+
+    if (alloc_pad)
+    {
+        (*dec_op_data)->inputData.pData = qat_alloc_pad((Cpa8U *) from, flen, rsa_len, 1);
+    } else if (isZeroCopy())
+    {
+        (*dec_op_data)->inputData.pData = (Cpa8U *) from;
+    } else
+    {
+        (*dec_op_data)->inputData.pData = (Cpa8U *) copyAllocPinnedMemory ((void*) from, flen, __FILE__, __LINE__);
+    }
+
+    if (NULL == (*dec_op_data)->inputData.pData)
+    {
+        WARN("[%s] --- InputData malloc failed!\n", __func__);
+        return 0;
+    }
+
+    if(alloc_pad)
+        (*dec_op_data)->inputData.dataLenInBytes = rsa_len;
+    else
+        (*dec_op_data)->inputData.dataLenInBytes = flen;
+
+    *output_buffer = OPENSSL_malloc(sizeof(CpaFlatBuffer));
+    if (NULL == *output_buffer)
+    {
+        WARN("[%s] --- OutputBuffer malloc failed!\n", __func__);
+        return 0;
+    }
+
+    if (isZeroCopy())
+    {
+        /* Assign outputBuffer to output pointer */
+        (*output_buffer)->pData = (Cpa8U *) to;
+    }
+    else
+    {
+        /* Memory allocation for DecOpdata[IN] the size of outputBuffer should big
+         * enough to contain RSA_size */
+        (*output_buffer)->pData = (Cpa8U *) qaeCryptoMemAlloc(rsa_len, __FILE__, __LINE__);
+    }
+
+    if (NULL == (*output_buffer)->pData)
+    {
+      WARN("[%s] --- OutputBuffer Data malloc failed!\n", __func__);
+    return 0;
+    }
+    (*output_buffer)->dataLenInBytes = rsa_len;
+
+    return 1;
+}
+
+static void
+rsa_encrypt_op_buf_free(CpaCyRsaEncryptOpData* enc_op_data, CpaFlatBuffer* out_buf, int padding)
+{
+    if (enc_op_data)
+    {
+        if (enc_op_data->pPublicKey)
+        {
+            if (enc_op_data->pPublicKey->modulusN.pData)
+                qaeCryptoMemFree(enc_op_data->pPublicKey->modulusN.pData);
+            if (enc_op_data->pPublicKey->publicExponentE.pData)
+                qaeCryptoMemFree(enc_op_data->pPublicKey->publicExponentE.pData);
+            OPENSSL_free(enc_op_data->pPublicKey);
+        }
+        if ((!isZeroCopy() || padding)  && enc_op_data->inputData.pData)
+            qaeCryptoMemFree(enc_op_data->inputData.pData);
+        OPENSSL_free(enc_op_data);
+    }
+
+    if (out_buf)
+    {
+        if (!isZeroCopy() && out_buf->pData)
+            qaeCryptoMemFree(out_buf->pData);
+        OPENSSL_free(out_buf);
+    }
+}
+
+
+#ifdef OPENSSL_QAT_ASYNCH
+void
+qat_rsaEncryptAsynchCallbackFn(void *pCallbackTag, CpaStatus status, void *pOpData,
+                           CpaFlatBuffer *pOut)
+{
+    rsa_op_data_t* rsa_op_data = (rsa_op_data_t*)(pCallbackTag);
+    int cb_status = status == CPA_STATUS_SUCCESS ? 1 : 0;
+    int output_len = 0;
+
+    if (!rsa_op_data)
+    {
+        WARN("[%s] --- pCallbackTag NULL!\n",
+             __func__);
+        return;
+    }
+    else if (rsa_op_data->padding)
+    {
+        /* remove the padding from outputBuffer */
+        /* only RSA_PKCS1_PADDING scheme supported by qat engine */
+        if (1 == cb_status &&
+            qat_remove_pad(rsa_op_data->cb_output, pOut->pData,
+            pOut->dataLenInBytes, &output_len, 1) != 1)
+        {
+            WARN("[%s] --- pData remove padding detected an error!\n", __func__);
+            cb_status = 0;
+        }
+    } else
+    {
+        if (!isZeroCopy())
+            memcpy(rsa_op_data->cb_output, pOut->pData, rsa_op_data->rsa_len);
+    output_len = rsa_op_data->rsa_len;
+    }
+
+    /* Free all the memory allocated for this operation */
+    rsa_encrypt_op_buf_free(rsa_op_data->enc_op_data, pOut, !(rsa_op_data->padding));
+
+    if(1 != cb_status)
+    {
+    memset(rsa_op_data->cb_output, 0xff, rsa_op_data->rsa_len);
+    }
+    rsa_op_data->cb_func(rsa_op_data->cb_output, output_len,
+                        rsa_op_data->cb_data, cb_status);
+    OPENSSL_free(rsa_op_data);
+}
+#endif
+
+int
+qat_rsa_encrypt(CpaCyRsaEncryptOpData *enc_op_data, CpaFlatBuffer *output_buf)
+{
+    struct op_done op_done;
+    CpaStatus sts = CPA_STATUS_FAIL;
+    int qatPerformOpRetries = 0;
+    CpaInstanceHandle instanceHandle = NULL;
+
+    int iMsgRetry = getQatMsgRetryCount();
+    useconds_t ulPollInterval = getQatPollInterval();
+    int rc = 1;
+
+    initOpDone(&op_done);
+
+    /* cpaCyRsaDecrypt() is the function called for RSA verify in API, the
+     * DecOpData [IN] contains both private key value and input file (hash)
+     * value, the outputBuffer [OUT] stores the signature as the output
+     * message, the sts value return 0 if successful */
+    do
+    {
+        if (NULL == (instanceHandle = get_next_inst()))
+        {
+            WARN("instanceHandle is NULL\n");
+			QATerr(QAT_F_QAT_RSA_ENCRYPT, ERR_R_INTERNAL_ERROR);
+            cleanupOpDone(&op_done);
+            return 0;
+        }
+
+        sts = cpaCyRsaEncrypt(instanceHandle, qat_rsaCallbackFn, &op_done,
+                              enc_op_data, output_buf);
+        if (sts == CPA_STATUS_RETRY)
+        {
+            usleep(ulPollInterval + (qatPerformOpRetries % QAT_RETRY_BACKOFF_MODULO_DIVISOR));
+            qatPerformOpRetries++;
+        }
+    }
+	while (sts == CPA_STATUS_RETRY &&
+		   ((qatPerformOpRetries < iMsgRetry) || (iMsgRetry == QAT_INFINITE_MAX_NUM_RETRIES)));
+
+    if (sts != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCyRsaEncrypt failed, sts=%d.\n", __func__, sts);
+		QATerr(QAT_F_QAT_RSA_ENCRYPT, ERR_R_INTERNAL_ERROR);
+        cleanupOpDone(&op_done);
+        return 0;
+    }
+
+    rc = waitForOpToComplete(&op_done);
+    cleanupOpDone(&op_done);
+    if (rc ) {
+        WARN("[%s] --- cpaCyRsaEncrypt timed out.\n", __func__);
+	    return 0;
+	}
+    return 1;
+}
+
+
+#ifdef OPENSSL_QAT_ASYNCH
+int
+qat_rsa_encrypt_asynch(CpaCyRsaEncryptOpData *enc_op_data,
+                        CpaFlatBuffer* int_output, int length,
+                        unsigned char* cb_output,
+                        int (*cb)(unsigned char *res, size_t reslen,
+                                  void *cb_data, int status),
+                        void *cb_data,
+                        int padding)
+{
+    CpaStatus sts = 1;
+    CpaInstanceHandle instanceHandle = NULL;
+    int qatPerformOpRetries = 0;
+
+    rsa_op_data_t *rsa_op_done = OPENSSL_malloc(sizeof(rsa_op_data_t));
+    if (NULL == rsa_op_done)
+    {
+        WARN("[%s] ---RSA OP DATA malloc failed!\n", __func__);
+        return 0;
+    }
+
+    rsa_op_done->enc_op_data = enc_op_data;
+    rsa_op_done->output_buffer = int_output;
+    rsa_op_done->rsa_len = length;
+    rsa_op_done->cb_output = cb_output;
+    rsa_op_done->cb_func = cb;
+    rsa_op_done->cb_data = cb_data;
+    rsa_op_done->padding = padding;
+
+    if (NULL == (instanceHandle = get_next_inst()))
+    {
+        WARN("instandHandle is NULL\n");
+        OPENSSL_free(rsa_op_done);
+        return 0;
+    }
+    /* cpaCyRsaDecrypt() is the function called for RSA verify in API, the
+     * DecOpData [IN] contains both private key value and input file (hash)
+     * value, the outputBuffer [OUT] stores the signature as the output
+     * message, the sts value return 0 if successful */
+    sts = cpaCyRsaEncrypt(instanceHandle, qat_rsaEncryptAsynchCallbackFn, rsa_op_done,
+                          enc_op_data, int_output);
+    if (sts != CPA_STATUS_SUCCESS)
+    {
+        WARN("[%s] --- cpaCyRsaDecrypt failed, sts=%d.\n", __func__, sts);
+        if (sts == CPA_STATUS_RETRY)
+        {
+            qatPerformOpRetries++;
+            QATerr(QAT_F_QAT_RSA_ENCRYPT_ASYNCH, ERR_R_RETRY);
+        }
+
+        OPENSSL_free(rsa_op_done);
+        return 0;
+    }
+
+    return 1;
+}
+#endif
+
+static int
+build_encrypt_op(int flen, const unsigned char *from, unsigned char *to,
+                 RSA * rsa, int padding,
+         CpaCyRsaEncryptOpData** enc_op_data, CpaFlatBuffer** output_buffer,
+         int alloc_pad)
+{
+    CpaCyRsaPublicKey* cpa_pub_key = NULL;
+    int rsa_len = 0;
+
+    cpa_pub_key = OPENSSL_malloc(sizeof(CpaCyRsaPublicKey));
+    if (NULL == cpa_pub_key)
+    {
+        WARN("[%s] --- Public Key malloc failed!\n", __func__);
+        return 0;
+    }
+
+    rsa_len = RSA_size(rsa);
+
+    /* Output and input data MUST allocate memory for RSA verify process */
+    /* Memory allocation for EncOpData[IN] */
+    *enc_op_data = OPENSSL_malloc(sizeof(CpaCyRsaEncryptOpData));
+    if (NULL == *enc_op_data)
+    {
+        WARN("[%s] --- OpData malloc failed!\n", __func__);
+        OPENSSL_free(cpa_pub_key);
+        return 0;
+    }
+
+    /* Setup the Encrypt operation Data structure */
+    (*enc_op_data)->pPublicKey = cpa_pub_key;
+
+    if (padding != RSA_PKCS1_PADDING)
+    {
+        WARN("[%s] --- Unknown Padding!\n", __func__);
+        return 0;
+    }
+
+    DEBUG("[%s] --- flen=%d padding=%d\n", __func__, flen, padding);
+
+    /* Passing Public key from big number format to big endian order binary */
+    if (qat_BN_to_FB(&cpa_pub_key->modulusN, rsa->n) != 1 ||
+        qat_BN_to_FB(&cpa_pub_key->publicExponentE, rsa->e) != 1)
+    {
+        WARN("[%s] --- qat_BN_to_FB failed for cpa_pub_key elements\n", __func__);
+        return 0;
+    }
+
+    if (alloc_pad)
+    {
+            (*enc_op_data)->inputData.pData = qat_alloc_pad((Cpa8U *) from, flen, rsa_len, 0);
+    }
+    else if (isZeroCopy())
+    {
+        (*enc_op_data)->inputData.pData = (Cpa8U *) from;
+    }
+    else
+    {
+        (*enc_op_data)->inputData.pData = (Cpa8U *) copyAllocPinnedMemory ((void*) from, flen, __FILE__, __LINE__);
+    }
+
+    if(NULL == (*enc_op_data)->inputData.pData)
+    {
+        WARN("[%s] --- Input buffer assignment failed!\n", __func__);
+        return 0;
+    }
+
+    if(alloc_pad)
+        (*enc_op_data)->inputData.dataLenInBytes = rsa_len;
+    else
+    (*enc_op_data)->inputData.dataLenInBytes = flen;
+
+    /* Memory allocation for outputBuffer[OUT] OutputBuffer size initialize
+     * as the size of rsa size */
+    (*output_buffer) = (CpaFlatBuffer *) OPENSSL_malloc(sizeof(CpaFlatBuffer));
+    if (NULL == (*output_buffer))
+    {
+        WARN("[%s] --- OutputBuffer malloc failed!\n", __func__);
+        return 0;
+    }
+
+    /* outputBuffer size should large enough to hold the Hash value but
+     * smaller than (RSA_size(rsa)-11) */
+    (*output_buffer)->dataLenInBytes = rsa_len;
+    (*output_buffer)->pData = qaeCryptoMemAlloc(rsa_len, __FILE__, __LINE__);
+    if (NULL == (*output_buffer)->pData)
+    {
+        WARN("[%s] --- OutputBuffer pData malloc failed!\n", __func__);
+        return 0;;
+    }
+
+    return 1;
+}
+
+
+/******************************************************************************
+* function:
+*         qat_rsa_priv_enc (int flen,
+*                                  const unsigned char *from,
+*                                  unsigned char *to,
+*                                  RSA *rsa,
+*                                  int padding,
+*                                  int (*cb)(unsigned char *res, int reslen,
+*                                            void *cb_data, int status),
+*                                  void *cb_data)
+*
+* @param flen    [IN]  - length in bytes of input file (hash value)
+* @param from    [IN]  - pointer to the input file
+* @param to      [OUT] - pointer to output signature
+* @param rsa     [IN]  - pointer to private key structure
+* @param padding [IN]  - Padding scheme
+* @param cb      [IN]  - callback function
+* @param cb_data [IN]  - data to sent in the callback
+*
+* description:
+******************************************************************************/
+static int
+qat_rsa_priv_enc(int flen, const unsigned char *from, unsigned char *to,
+                        RSA * rsa, int padding,
+            int (*cb)(unsigned char *res, size_t reslen,
+                                  void *cb_data, int status),
+            void *cb_data)
+{
+    int rsa_len = 0;
+    CpaCyRsaDecryptOpData *dec_op_data = NULL;
+    CpaFlatBuffer *output_buffer = NULL;
+    int sts = 1;
+
+    DEBUG("[%s] --- called.\n", __func__);
+    CRYPTO_QAT_LOG("RSA - %s\n", __func__);
+
+    /* Parameter Checking */
+    /* The input message length should less than RSA size and also have
+     * minimum space of PKCS1 padding(4 bytes) */
+    if (!rsa || !from || !to || (flen > ((rsa_len = RSA_size(rsa)) - 4)) || flen == 0)
+    {
+        DEBUG("[%s] --- Invalid Parameter\n", __func__);
+        goto exit;
+    }
+
+    if (1 != build_decrypt_op_buf(flen, from, to, rsa, padding,
+                 &dec_op_data, &output_buffer, PADDING))
+    {
+        sts = 0;
+        goto exit;
+    }
+
+    if(!cb) /*Sync Mode */
+    {
+        if (1 != qat_rsa_decrypt(dec_op_data, output_buffer))
+        {
+            /* set output all 0xff if failed */
+            DEBUG("[%s] --- cpaCyRsaDecrypt failed! \n", __func__);
+            sts = 0;
+            goto exit;
+        }
+        if (!isZeroCopy())
+            memcpy (to, output_buffer->pData, rsa_len);
+
+        DEBUG("[%s] --- cpaCyRsaDecrypt finished! \n", __func__);
+
+        rsa_decrypt_op_buf_free(dec_op_data, output_buffer, PADDING);
+    }
+#ifdef OPENSSL_QAT_ASYNCH
+    else   /*Async Mode*/
+    {
+        if(1 != qat_rsa_decrypt_asynch(dec_op_data,
+                                       output_buffer, rsa_len,
+                                       to, cb, cb_data, NO_PADDING))
+        {
+            WARN("[%s] --- RsaDecrypt failed.\n", __func__);
+            sts = 0;
+            goto exit;
+        }
+    }
+#endif
+    return rsa_len;
+
+  exit:
+
+    /* Free all the memory allocated in this function */
+    rsa_decrypt_op_buf_free(dec_op_data, output_buffer, PADDING);
+    if(!sts)
+        memset(to, 0xff, rsa_len);
+
+    /* Return an error */
+    return 0;
+}
+
+/******************************************************************************
+* function:
+*         qat_rsa_priv_dec(int flen, const unsigned char *from,
+*                          unsigned char *to, RSA * rsa, int padding)
+*
+* description:
+*   Wrapper around the default OpenSSL RSA rsa_priv_dec() function to avoid
+*   a null function pointer.
+*   See the OpenSSL documentation for parameters.
+******************************************************************************/
+static int qat_rsa_priv_dec(int flen, const unsigned char *from,
+                            unsigned char *to, RSA * rsa, int padding,
+                int (*cb)(unsigned char *res, size_t reslen,
+                                  void *cb_data, int status),
+                        void *cb_data)
+{
+    int rsa_len = 0;
+    int output_len = 0;
+    int sts = 1;
+    CpaCyRsaDecryptOpData *dec_op_data = NULL;
+    CpaFlatBuffer *output_buffer = NULL;
+
+    DEBUG("[%s] --- called.\n", __func__);
+    CRYPTO_QAT_LOG("RSA - %s\n", __func__);
+
+    /* parameter checks */
+    if(!rsa || !from || !to || (flen != (rsa_len = RSA_size(rsa))))
+    {
+        WARN("[%s] --- Invalid Parameter\n", __func__);
+        return 0;
+    }
+
+    if (1 != build_decrypt_op_buf(flen, from, to, rsa, padding,
+                 &dec_op_data, &output_buffer, NO_PADDING))
+    {
+        sts = 0;
+        goto exit;
+    }
+
+    if(!cb) /* Sync Mode Only */
+    {
+        if(1 != qat_rsa_decrypt(dec_op_data, output_buffer))
+        {
+            WARN("[%s] --- RsaDecrypt failed.\n", __func__);
+            sts = 0;
+            goto exit;
+        }
+        /* Copy output to output buffer */
+        if(qat_remove_pad(to, output_buffer->pData, rsa_len, &output_len, 0) != 1)
+        {
+            /* set output all 0xff if failed */
+            WARN("[%s] --- pData remove padding detected an error!\n", __func__);
+            DEBUG("[%s] --- cpaCyRsaDecrypt failed! \n", __func__);
+            sts = 0;
+            goto exit;
+        }
+
+        rsa_decrypt_op_buf_free(dec_op_data, output_buffer, NO_PADDING);
+        DEBUG("[%s] --- cpaCyRsaDecrypt finished! \n", __func__);
+        return output_len;
+    }
+#ifdef OPENSSL_QAT_ASYNCH
+    else
+    {
+        if(1 != qat_rsa_decrypt_asynch(dec_op_data,
+                                   output_buffer, rsa_len,
+                                   to, cb, cb_data, PADDING))
+        {
+            WARN("[%s] --- RsaDecrypt failed.\n", __func__);
+            goto exit;
+        }
+        return rsa_len;
+    }
+#endif
+
+  exit:
+    /* Free all the memory allocated in this function */
+    rsa_decrypt_op_buf_free(dec_op_data, output_buffer,NO_PADDING);
+    if(!sts && to && !cb) /* Only in Sync Mode */
+        memset(to, 0xff, rsa_len);
+    return 0;
+}
+
+/******************************************************************************
+* function:
+*         qat_rsa_pub_enc(int flen,const unsigned char *from,
+*                         unsigned char *to,
+*                         RSA *rsa,int padding)
+*
+* description:
+*   Wrapper around the default OpenSSL RSA qat_rsa_pub_enc() function to avoid
+*   a null function pointer.
+*   See the OpenSSL documentation for parameters.
+******************************************************************************/
+static int qat_rsa_pub_enc(int flen, const unsigned char *from,
+                           unsigned char *to, RSA * rsa, int padding,
+               int (*cb)(unsigned char *res, size_t reslen,
+                            void *cb_data, int status),
+                       void *cb_data)
+{
+    int rsa_len = 0;
+    CpaCyRsaEncryptOpData *enc_op_data = NULL;
+    CpaFlatBuffer *output_buffer = NULL;
+    int sts = 1;
+
+    DEBUG("[%s] --- called.\n", __func__);
+    CRYPTO_QAT_LOG("RSA - %s\n", __func__);
+
+    /* parameter checks */
+    if(!rsa || !from || !to || (flen > (rsa_len = RSA_size(rsa)) - 11))
+    {
+        WARN("[%s] --- Invalid Parameter\n", __func__);
+        goto exit;
+    }
+
+    if (1 != build_encrypt_op(flen, from, to, rsa, padding,
+        &enc_op_data, &output_buffer, PADDING))
+    {
+        sts = 0;
+        goto exit;
+    }
+
+    if(!cb) /* Sync Mode only*/
+    {
+        if (1 != qat_rsa_encrypt(enc_op_data, output_buffer))
+        {
+            /* set output all 0xff if failed */
+            DEBUG("[%s] --- cpaCyRsaEncrypt failed! \n", __func__);
+            sts = 0;
+            goto exit;
+
+        }
+        else
+        {
+            DEBUG("[%s] --- cpaCyRsaEncrypt finished! \n", __func__);
+            memcpy(to, output_buffer->pData, output_buffer->dataLenInBytes);
+        }
+        rsa_encrypt_op_buf_free(enc_op_data, output_buffer,PADDING);
+        return rsa_len;
+    }
+#ifdef OPENSSL_QAT_ASYNCH
+    else
+    {
+        if (1 != qat_rsa_encrypt_asynch(enc_op_data,
+                            output_buffer, rsa_len,
+                            to, cb, cb_data, NO_PADDING))
+        {
+            WARN("[%s] --- RsaEncrypt failed.\n", __func__);
+            sts = 0;
+            goto exit;
+        }
+        return rsa_len;
+    }
+#endif
+  exit:
+    /* Free all the memory allocated in this function */
+    rsa_encrypt_op_buf_free(enc_op_data, output_buffer,PADDING);
+
+    /* set output all 0xff if failed */
+    DEBUG("[%s] --- cpaCyRsaEncrypt failed! \n", __func__);
+    if (!sts)
+        memset(to, 0xff, rsa_len);
+    return 0;
+}
+
+
+/******************************************************************************
+* function:
+*         qat_rsa_pub_dec(int flen,
+*                         const unsigned char *from,
+*                         unsigned char *to,
+*                         RSA *rsa,
+*                         int padding)
+*
+* @param flen    [IN]  - size in bytes of input signature
+* @param from    [IN]  - pointer to the signature file
+* @param to      [OUT] - pointer to output data
+* @param rsa     [IN]  - pointer to public key structure
+* @param padding [IN]  - Padding scheme
+*
+* description:
+*   This function is rewrite of OpenSSL RSA_pub_dec() function for RSA verify process.
+*   All the inputs are pass form the above OpenSSL layer to the corresponding API
+*   RSA verify function cpaCyRsaEncrypt().
+*   The function returns the RSA recovered message output.
+******************************************************************************/
+static int
+qat_rsa_pub_dec(int flen, const unsigned char *from, unsigned char *to,
+                    RSA * rsa, int padding,
+            int (*cb)(unsigned char *res, size_t reslen,
+                            void *cb_data, int status),
+                    void *cb_data)
+{
+    int rsa_len = 0;
+    int output_len = 0;
+    CpaCyRsaEncryptOpData *enc_op_data = NULL;
+    CpaFlatBuffer *output_buffer = NULL;
+    int sts = 1;
+
+    DEBUG("[%s] --- called.\n", __func__);
+    CRYPTO_QAT_LOG("RSA - %s\n", __func__);
+
+    /* parameter checking */
+    if (!rsa || !from || !to || (flen != (rsa_len = RSA_size(rsa))))
+    {
+        WARN("[%s] --- Invalid Parameter flen = %d, rsa_len = %d\n", __func__, flen, rsa_len);
+        goto exit;
+    }
+
+    if (1 != build_encrypt_op(flen, from, to, rsa, padding,
+                &enc_op_data, &output_buffer, NO_PADDING))
+    {
+        sts = 0;
+        goto exit;
+    }
+
+    if(!cb) /*Sync Mode*/
+    {
+        if (1 != qat_rsa_encrypt(enc_op_data, output_buffer))
+        {
+            WARN("[%s] --- RsaEncrypt failed.\n", __func__);
+            sts = 0;
+            goto exit;
+        }
+
+        /* remove the padding from outputBuffer */
+        /* only RSA_PKCS1_PADDING scheme supported by qat engine */
+        if (qat_remove_pad(to, output_buffer->pData, rsa_len, &output_len, 1) != 1)
+        {
+            WARN("[%s] --- pData remove padding detected an error!\n", __func__);
+            sts = 0;
+            goto exit;
+        }
+
+        rsa_encrypt_op_buf_free(enc_op_data, output_buffer,NO_PADDING);
+        return output_len;
+
+    }
+#ifdef OPENSSL_QAT_ASYNCH
+    else /*Asynch Mode*/
+    {
+        if (1 != qat_rsa_encrypt_asynch(enc_op_data,
+                            output_buffer, rsa_len,
+                            to, cb, cb_data, PADDING))
+        {
+            WARN("[%s] --- RsaEncrypt failed.\n", __func__);
+            sts = 0;
+            goto exit;
+        }
+        return rsa_len;
+    }
+#endif
+
+  exit:
+    /* Free all the memory allocated in this function */
+    rsa_encrypt_op_buf_free(enc_op_data, output_buffer,NO_PADDING);
+
+    /* set output all 0xff if failed */
+    DEBUG("[%s] --- cpaCyRsaEncrypt failed! \n", __func__);
+    if (!sts)
+        memset(to, 0xff, rsa_len);
+    return 0;
+}
+
+
+
+/******************************************************************************
+* function:
+*         qat_rsa_priv_enc_synch (int flen,
+*                           const unsigned char *from,
+*                           unsigned char *to,
+*                           RSA *rsa,
+*                           int padding)
+*
+* @param flen    [IN]  - length in bytes of input file (hash value)
+* @param from    [IN]  - pointer to the input file
+* @param to      [OUT] - pointer to output signature
+* @param rsa     [IN]  - pointer to private key structure
+* @param padding [IN]  - Padding scheme
+*
+* description:
+*   This function is rewrite of OpenSSL RSA_priv_enc() function for RSA sign process.
+*   All the inputs are pass form the above OpenSSL layer to the corresponding API
+*   RSA sign function cpaCyRsaDecrypt().
+*   The function returns the RSA signature output.
+******************************************************************************/
+int
+qat_rsa_priv_enc_synch(int flen, const unsigned char *from, unsigned char *to,
+                 RSA * rsa, int padding)
+{
+    return qat_rsa_priv_enc( flen, from, to, rsa, padding,NULL,NULL);
+}
+
+/******************************************************************************
+* function:
+*         qat_rsa_priv_dec_synch(int flen, const unsigned char *from,
+*                          unsigned char *to, RSA * rsa, int padding)
+*
+* description:
+*   Wrapper around the default OpenSSL RSA rsa_priv_dec() function to avoid
+*   a null function pointer.
+*   See the OpenSSL documentation for parameters.
+******************************************************************************/
+int qat_rsa_priv_dec_synch(int flen, const unsigned char *from,
+                            unsigned char *to, RSA * rsa, int padding)
+{
+    return qat_rsa_priv_dec(flen, from, to, rsa, padding, NULL,NULL);
+}
+
+/******************************************************************************
+* function:
+*         qat_rsa_pub_enc_synch(int flen,const unsigned char *from,
+*                         unsigned char *to,
+*                         RSA *rsa,int padding)
+*
+* description:
+*   Wrapper around the default OpenSSL RSA qat_rsa_pub_enc() function to avoid
+*   a null function pointer.
+*   See the OpenSSL documentation for parameters.
+******************************************************************************/
+int qat_rsa_pub_enc_synch(int flen, const unsigned char *from,
+                           unsigned char *to, RSA * rsa, int padding)
+{
+    return qat_rsa_pub_enc(flen, from, to, rsa, padding, NULL,NULL);
+}
+
+/******************************************************************************
+* function:
+*         qat_rsa_pub_dec_synch(int flen,
+*                         const unsigned char *from,
+*                         unsigned char *to,
+*                         RSA *rsa,
+*                         int padding)
+*
+* @param flen    [IN]  - size in bytes of input signature
+* @param from    [IN]  - pointer to the signature file
+* @param to      [OUT] - pointer to output data
+* @param rsa     [IN]  - pointer to public key structure
+* @param padding [IN]  - Padding scheme
+*
+* description:
+*   This function is rewrite of OpenSSL RSA_pub_dec() function for RSA verify process.
+*   All the inputs are pass form the above OpenSSL layer to the corresponding API
+*   RSA verify function cpaCyRsaEncrypt().
+*   The function returns the RSA recovered message output.
+******************************************************************************/
+int
+qat_rsa_pub_dec_synch(int flen, const unsigned char *from, unsigned char *to,
+                RSA * rsa, int padding)
+{
+    return qat_rsa_pub_dec( flen, from, to, rsa, padding, NULL, NULL);
+}
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*         qat_rsa_priv_enc_asynch (int flen,
+*                                  const unsigned char *from,
+*                                  unsigned char *to,
+*                                  RSA *rsa,
+*                                  int padding,
+*                                  int (*cb)(unsigned char *res, int reslen,
+*                                            void *cb_data, int status),
+*                                  void *cb_data)
+*
+* @param flen    [IN]  - length in bytes of input file (hash value)
+* @param from    [IN]  - pointer to the input file
+* @param to      [OUT] - pointer to output signature
+* @param rsa     [IN]  - pointer to private key structure
+* @param padding [IN]  - Padding scheme
+* @param cb      [IN]  - callback function
+* @param cb_data [IN]  - data to sent in the callback
+*
+* description:
+******************************************************************************/
+int
+qat_rsa_priv_enc_asynch(int flen, const unsigned char *from, unsigned char *to,
+                        RSA * rsa, int padding,
+            int (*cb)(unsigned char *res, size_t reslen,
+                                  void *cb_data, int status),
+            void *cb_data)
+{
+    if (!cb)
+    {
+        DEBUG("[%s] --- Invalid Parameter\n", __func__);
+        return 0;
+    }
+    return qat_rsa_priv_enc(flen, from, to, rsa, padding,cb,cb_data);
+}
+#endif
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*         qat_rsa_priv_dec_asynch(int flen, const unsigned char *from,
+*                          unsigned char *to, RSA * rsa, int padding)
+*
+* description:
+*   Wrapper around the default OpenSSL RSA rsa_priv_dec() function to avoid
+*   a null function pointer.
+*   See the OpenSSL documentation for parameters.
+******************************************************************************/
+int qat_rsa_priv_dec_asynch(int flen, const unsigned char *from,
+                            unsigned char *to, RSA * rsa, int padding,
+                int (*cb)(unsigned char *res, size_t reslen,
+                                  void *cb_data, int status),
+                        void *cb_data)
+{
+    /* parameter checks */
+    if( !cb )
+    {
+        WARN("[%s] --- Invalid Parameter\n", __func__);
+        return 0;
+    }
+    return qat_rsa_priv_dec( flen, from, to, rsa, padding,cb, cb_data);
+}
+#endif
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*         qat_rsa_pub_enc_async(int flen,const unsigned char *from,
+*                         unsigned char *to,
+*                         RSA *rsa,int padding)
+*
+* description:
+*   Wrapper around the default OpenSSL RSA qat_rsa_pub_enc() function to avoid
+*   a null function pointer.
+*   See the OpenSSL documentation for parameters.
+******************************************************************************/
+int qat_rsa_pub_enc_asynch(int flen, const unsigned char *from,
+                           unsigned char *to, RSA * rsa, int padding,
+               int (*cb)(unsigned char *res, size_t reslen,
+                            void *cb_data, int status),
+                       void *cb_data)
+{
+    /* parameter checks */
+    if(!cb)
+    {
+        WARN("[%s] --- Invalid Parameter\n", __func__);
+        return 0;
+    }
+
+    return qat_rsa_pub_enc( flen, from, to, rsa, padding, cb, cb_data);
+}
+#endif
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*         qat_rsa_pub_dec_async(int flen,
+*                         const unsigned char *from,
+*                         unsigned char *to,
+*                         RSA *rsa,
+*                         int padding)
+*
+* @param flen    [IN]  - size in bytes of input signature
+* @param from    [IN]  - pointer to the signature file
+* @param to      [OUT] - pointer to output data
+* @param rsa     [IN]  - pointer to public key structure
+* @param padding [IN]  - Padding scheme
+*
+* description:
+*   This function is rewrite of OpenSSL RSA_pub_dec() function for RSA verify process.
+*   All the inputs are pass form the above OpenSSL layer to the corresponding API
+*   RSA verify function cpaCyRsaEncrypt().
+*   The function returns the RSA recovered message output.
+******************************************************************************/
+int
+qat_rsa_pub_dec_asynch(int flen, const unsigned char *from, unsigned char *to,
+                    RSA * rsa, int padding,
+            int (*cb)(unsigned char *res, size_t reslen,
+                            void *cb_data, int status),
+                    void *cb_data)
+{
+    /* parameter checking */
+    if (!cb)
+    {
+        WARN("[%s] --- Invalid Parameter\n", __func__);
+        return 0;
+    }
+
+    return qat_rsa_pub_dec( flen, from, to, rsa, padding, cb, cb_data);
+}
+#endif
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_rsa.h ./engines/qat_engine/qat_rsa.h
--- ../openssl-async/engines/qat_engine/qat_rsa.h	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_rsa.h	2015-03-05 12:43:44.284962000 +0000
@@ -0,0 +1,99 @@
+
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qat_rsa.h
+ *
+ * This file provides an RSA interface for an OpenSSL engine
+ *
+ *****************************************************************************/
+
+#ifndef QAT_RSA_H
+#define QAT_RSA_H
+
+#include <openssl/rsa.h>
+
+/* Qat engine RSA methods declaration */
+int qat_rsa_priv_enc_synch(int flen, const unsigned char *from, 
+                     unsigned char *to, RSA * rsa, int padding);
+int qat_rsa_pub_dec_synch(int flen, const unsigned char *from, 
+                    unsigned char *to, RSA * rsa, int padding);
+int qat_rsa_priv_dec_synch(int flen, const unsigned char *from, 
+                     unsigned char *to, RSA * rsa, int padding);
+int qat_rsa_mod_exp(BIGNUM * r0, const BIGNUM * I, RSA * rsa, BN_CTX * ctx);
+int qat_bn_mod_exp(BIGNUM * r, const BIGNUM * a, const BIGNUM * p,
+                   const BIGNUM * m, BN_CTX * ctx, BN_MONT_CTX * m_ctx);
+int qat_rsa_pub_enc_synch(int flen, const unsigned char *from, unsigned char *to, 
+                    RSA * rsa, int padding);
+
+int qat_rsa_priv_enc_asynch(int flen, const unsigned char *from, unsigned char *to,
+                        RSA * rsa, int padding,
+                        int (*cb)(unsigned char *res, size_t reslen,
+                                  void *cb_data, int status),
+                        void *cb_data);
+int qat_rsa_priv_dec_asynch(int flen, const unsigned char *from,
+                            unsigned char *to, RSA * rsa, int padding,
+                            int (*cb)(unsigned char *res, size_t reslen,
+                                      void *cb_data, int status),
+                            void *cb_data);
+int qat_rsa_pub_enc_asynch(int flen, const unsigned char *from,
+                           unsigned char *to, RSA * rsa, int padding,
+                           int (*cb)(unsigned char *res, size_t reslen,
+                                void *cb_data, int status),
+                           void *cb_data);
+int qat_rsa_pub_dec_asynch(int flen, const unsigned char *from, unsigned char *to,
+                        RSA * rsa, int padding,
+                        int (*cb)(unsigned char *res, size_t reslen,
+                                void *cb_data, int status),
+                        void *cb_data);
+
+RSA_METHOD *get_RSA_methods(void);
+
+#endif //QAT_RSA_H
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_sym_common.c ./engines/qat_engine/qat_sym_common.c
--- ../openssl-async/engines/qat_engine/qat_sym_common.c	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_sym_common.c	2015-03-05 12:43:44.286956000 +0000
@@ -0,0 +1,615 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qat_sym_common.c
+ *
+ * This file provides an implementation of Symmetric common functions
+ *
+ *****************************************************************************/
+
+#include <openssl/evp.h>
+#include "cpa.h"
+#include "cpa_cy_sym.h"
+
+#include "qat_sym_common.h"
+#include "qat_utils.h"
+#ifdef USE_QAT_MEM
+#include "qae_mem_utils.h"
+#endif
+#ifdef USE_QAE_MEM
+#include "qat_mem_drv_inf.h"
+#endif
+#include "e_qat.h"
+
+#include "string.h"
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*         alloc_req_phys( Cpa32U meta_size,
+*                          unsigned int req_len,
+*                          unsigned int iv_len,
+*                          unsigned int digest_len,
+*                          AGG_REQ_PHYS* req_phys,
+*                          unsigned int first_blk_size )
+*
+* @param meta_size  [IN] - size of the metadata to be allocated
+* @param req_len    [IN] - length of the request data
+* @param iv_len     [IN] - length of the iv
+* @param digest_len [IN] - length of the digest
+* @param req_phys   [IN] - Pointer to the required physical structure
+* @param first_blk_size [IN] - length of the first block before the iv
+* @retval int - Return 1 on success. 
+*               Return 0 on failure.
+*
+* description:
+*   This function gets the required physical memory for
+*   symetric operations.
+******************************************************************************/
+int alloc_req_phys(Cpa32U meta_size, unsigned int req_len, 
+		   unsigned int iv_len, unsigned int digest_len,
+		   AGG_REQ_PHYS* req_phys, unsigned int first_blk_size)
+{
+    unsigned int total_alloc_size = 0;
+    unsigned char *mem_blk = NULL;
+    
+    if (0 == meta_size || NULL == req_phys)
+    {
+        WARN("%s: Input parameters INVALID.\n");
+ 	return 0;
+    }
+
+    if (isZeroCopy())
+    {
+        /* Calculate the entire size required
+         * 2*meta_size == src/dst private meta data
+         * 2*64 bytes in chaining case, 0 in cipher == src/dst data
+         * iv_len
+         * digest_len
+         * 5*64 - space for alignment
+         * In zero copy chaining case we allocate 64 byte buffers to place TLS header at the
+         * end them. Due PCI performance reasons it is better to have the TLS header at the end of a
+         * 64 byte buffer than 13byte buffer
+         * */
+        total_alloc_size = (2 * meta_size) + (first_blk_size? 2 * QAT_BYTE_ALIGNMENT: 0) + iv_len + digest_len
+                + 5 * QAT_BYTE_ALIGNMENT;
+    }
+    else
+    {
+        /* Calculate the entire size required
+         * 2*meta_size == src/dst private meta data
+         * 2*req_len + 2*first_blk_size== src/dst data
+         * iv_len
+         * digest_len
+         * 5*64 - space for alignment
+         * */
+        total_alloc_size = (2 * meta_size) + (2 * req_len)
+                + (2 * first_blk_size) + iv_len + digest_len + 5 * QAT_BYTE_ALIGNMENT;
+    }
+
+    mem_blk = qaeCryptoMemAlloc(total_alloc_size, __FILE__, __LINE__);
+    if (!mem_blk)
+    {
+        WARN("%s: Unable to allocate request physical memory.\n",
+             __func__);
+        return 0;
+    }
+
+    //TODO need to handle a meta_size of 0
+    req_phys->base_addr = mem_blk;
+    req_phys->src_priv_meta = mem_blk;
+    req_phys->dst_priv_meta = QAT_MEM_ALIGN(mem_blk + meta_size);
+
+    req_phys->src_data = QAT_MEM_ALIGN(req_phys->dst_priv_meta + meta_size);
+    if (isZeroCopy())
+    {
+        /* in zero copy mode 64 byte buffer is used to store the header located at the end of
+         * that buffer */
+        req_phys->dst_data = QAT_MEM_ALIGN(req_phys->src_data + (first_blk_size?QAT_BYTE_ALIGNMENT:0));
+        req_phys->iv = QAT_MEM_ALIGN(req_phys->dst_data + (first_blk_size?QAT_BYTE_ALIGNMENT:0));
+    }
+    else
+    {
+        req_phys->dst_data = QAT_MEM_ALIGN(req_phys->src_data + (req_len + first_blk_size));
+        req_phys->iv = QAT_MEM_ALIGN(req_phys->dst_data + (req_len + first_blk_size));
+    }
+    req_phys->digest_res = QAT_MEM_ALIGN(req_phys->iv + iv_len);
+
+
+    return 1;
+}
+#endif
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*         free_req_phys( AGG_REQ_PHYS* req_phys )
+*
+* @param req_phys   [IN/OUT] - Pointer to the required physical structure
+*
+* description:
+*   This function frees the required physical memory for
+*   symetric operations allocated in the alloc_req_phys function.
+******************************************************************************/
+void free_req_phys(AGG_REQ_PHYS *req_phys)
+{
+    if (NULL != req_phys)
+	{
+        if (NULL != req_phys->base_addr)
+            qaeCryptoMemFree(req_phys->base_addr);
+	}
+}
+#endif
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*         populate_op_data( CpaCySymOpData *op_data,
+*                           CpaCySymSessionCtx sess_ctx,
+*                           EVP_CIPHER_CTX *evp_ctx
+*                           size_t inl,
+*                           AGG_REQ_PHYS* req_phys )
+*
+* @param op_data  [IN] - The op_data structure to populate
+* @param sess_ctx [IN] - The session context to assign
+* @param evp_ctx  [IN] - The evp context used to get the iv info from
+* @param inl      [IN] - length of the message to cipher
+* @param req_phys [IN] - Pointer to the required physical structure
+*                            containing iv data.
+* @param header_size [IN] - Size of the header. To distinguish between cipher and chaining
+* @retval int - Return 1 on success. 
+*               Return 0 on failure.
+*
+* description:
+*   This function populates the op_data structure with the required
+*   data to make a request.
+******************************************************************************/
+int populate_op_data(CpaCySymOpData *op_data, CpaCySymSessionCtx sess_ctx,
+	EVP_CIPHER_CTX *evp_ctx, size_t inl, AGG_REQ_PHYS *req_phys, int header_size)
+{
+    if (NULL == op_data ||
+		NULL == evp_ctx)
+	{
+	    WARN("[%s] Invalid parameters for request\n", __func__);
+        return 0;
+    }
+	
+    op_data->sessionCtx = sess_ctx;
+    if (NID_rc4 != EVP_CIPHER_CTX_nid(evp_ctx) &&
+        EVP_CIPHER_CTX_test_flags(evp_ctx, EVP_CIPH_CTX_FLAG_CAN_IGNORE_IV))
+        op_data->packetType = CPA_CY_SYM_PACKET_TYPE_FULL;
+    else //TODO this may be incorrect for chained requests. Test
+        op_data->packetType = CPA_CY_SYM_PACKET_TYPE_PARTIAL;
+
+    if (NID_rc4 == EVP_CIPHER_CTX_nid(evp_ctx))
+    {
+        op_data->pIv = NULL;
+    } 
+	else
+    {
+	    if (NULL == req_phys)
+	    {
+	        WARN("[%s] Invalid parameter for request\n", __func__);
+            return 0;
+        }
+        op_data->pIv = req_phys->iv;
+    }
+ 
+    if (EVP_CIPHER_CTX_test_flags(evp_ctx, EVP_CIPH_CTX_FLAG_CAN_IGNORE_IV))
+    {
+        // In the case where the CAN_IGNORE_FLAG is set the IV for this request
+        // is the first block of the request and is not dependent on any other requests
+		if (op_data->pIv)
+            memset(op_data->pIv, 0, EVP_CIPHER_CTX_iv_length(evp_ctx));
+    } 
+	else
+    {
+ 	// This is done to ensure IV is in 64 byte aligned buffer
+        if(op_data->pIv) 
+            memcpy(op_data->pIv, evp_ctx->iv, EVP_CIPHER_CTX_iv_length(evp_ctx));
+    }
+
+    if (isZeroCopy() && header_size){
+        op_data->cryptoStartSrcOffsetInBytes = QAT_BYTE_ALIGNMENT - header_size;
+        op_data->hashStartSrcOffsetInBytes = QAT_BYTE_ALIGNMENT - header_size;
+    }
+    else
+    {
+        /* Starting point for cipher processing - given as number of bytes from
+         * start of data in the source buffer. The result of the cipher operation
+         * will be written back into the output buffer starting at this location. */
+        op_data->cryptoStartSrcOffsetInBytes = 0;
+        /* Starting point for hash processing - given as number of bytes from start
+         * of packet in source buffer. */
+        op_data->hashStartSrcOffsetInBytes = 0;
+    }
+    /* The message length, in bytes, of the source buffer that the hash will be
+     * computed on.  */
+    op_data->messageLenToHashInBytes = 0;
+    /* Pointer to the location where the digest result either exists or will be
+     * inserted. */
+    op_data->pDigestResult = NULL;
+    /* Pointer to Additional Authenticated Data (AAD) needed for authenticated
+     * cipher mechanisms - CCM and GCM. For other authentication mechanisms
+     * this pointer is ignored. */
+    op_data->pAdditionalAuthData = NULL;
+    /* The message length, in bytes, of the source buffer that the crypto
+     * operation will be computed on. This must be a multiple to the block size
+     * if a block cipher is being used. */
+    op_data->messageLenToCipherInBytes = inl;
+    /* Cipher IV length in bytes.  Determines the amount of valid IV data
+     * pointed to by the pIv parameter. */
+    op_data->ivLenInBytes = (Cpa32U) EVP_CIPHER_CTX_iv_length(evp_ctx);
+	
+	return 1;
+
+}
+#endif
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*         link_buffers( AGG_REQ_VIRT* req_virt,
+*                       AGG_REQ_PHYS* req_phys,
+*                       unsigned int req_len,
+*                       unsigned int hdr_size )
+*
+* @param req_virt [IN] - Pointer to the required virtual structure
+* @param req_phys [IN] - Pointer to the required physical structure
+* @param req_len  [IN] - The length of the request in bytes
+* @param hdr_size [IN] - The size of the header in bytes
+*
+* @retval int - Return 1 on success. 
+*               Return 0 on failure.
+*
+* description:
+*   This function populates the virtual data structure from the
+*   physical structure.
+******************************************************************************/
+int link_buffers(AGG_REQ_VIRT* req_virt, AGG_REQ_PHYS* req_phys,
+		      unsigned int req_len, unsigned int hdr_size)
+{
+    if (NULL == req_virt ||
+	    NULL == req_phys)
+    {
+	    WARN("[%s] Invalid parameters for request\n", __func__);
+        return 0;
+    }	
+	/* TODO: Can we populate this structure with one SIMD operation */
+    /* Src Buffer */
+
+    req_virt->src_buf_list.pPrivateMetaData = req_phys->src_priv_meta;
+
+    /* Dst Buffer */
+    req_virt->dst_buf_list.pPrivateMetaData = req_phys->dst_priv_meta;
+
+    if (0 != hdr_size)
+    {
+        req_virt->src_buf_list.pBuffers = (req_virt->src_buf.chained);
+    	req_virt->src_buf_list.numBuffers = 2;
+        req_virt->dst_buf_list.pBuffers = (req_virt->dst_buf.chained);
+        req_virt->dst_buf_list.numBuffers = 2;
+        if (isZeroCopy())
+            req_virt->src_buf.chained[0].dataLenInBytes = QAT_BYTE_ALIGNMENT;
+        else
+            req_virt->src_buf.chained[0].dataLenInBytes = (Cpa32U)hdr_size;
+        req_virt->src_buf.chained[0].pData = req_phys->src_data;
+        req_virt->src_buf.chained[1].dataLenInBytes = (Cpa32U)req_len;
+        req_virt->src_buf.chained[1].pData = req_phys->src_data + hdr_size;
+
+        if (isZeroCopy())
+            req_virt->dst_buf.chained[0].dataLenInBytes = QAT_BYTE_ALIGNMENT;
+        else
+            req_virt->dst_buf.chained[0].dataLenInBytes = (Cpa32U)hdr_size;
+        req_virt->dst_buf.chained[0].pData = req_phys->dst_data;
+        req_virt->dst_buf.chained[1].dataLenInBytes = (Cpa32U)req_len;
+        req_virt->dst_buf.chained[1].pData = req_phys->dst_data + hdr_size;
+    } 
+	else
+    {
+        req_virt->src_buf_list.pBuffers = &(req_virt->src_buf.single);
+    	req_virt->src_buf_list.numBuffers = 1;
+    	req_virt->src_buf.single.dataLenInBytes = (Cpa32U)req_len; 
+    	req_virt->src_buf.single.pData = req_phys->src_data;
+
+        req_virt->dst_buf_list.pBuffers = &(req_virt->dst_buf.single);
+    	req_virt->dst_buf_list.numBuffers = 1;
+    	req_virt->dst_buf.single.dataLenInBytes = (Cpa32U)req_len; 
+    	req_virt->dst_buf.single.pData = req_phys->dst_data;
+    }
+	
+	return 1;
+}
+#endif
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*         set_buf_data( AGG_REQ *agg_req,
+*                       EVP_CIPHER_CTX *evp_ctx,
+*                       unsigned char *out,
+*                       const unsigned char *in,
+*                       size_t inl,
+*                       const unsigned char *header )
+*
+* @param agg_req [IN] - Pointer to the request
+* @param evp_ctx [IN] - Pointer to the evp context
+* @param out     [OUT] - The output buffer to populate
+* @param in      [IN] - The input buffer we copy from 
+* @param inl     [IN] - Length of the input buffer
+* @param header  [IN] - The header data if any
+*
+* @retval int - Return 1 on success. 
+*               Return 0 on failure.
+*
+* description:
+*   This function populates the output buffer from the input
+*   buffer and assignes it into the request
+******************************************************************************/
+int set_buf_data(AGG_REQ *agg_req, EVP_CIPHER_CTX *evp_ctx, unsigned char *out,
+	const unsigned char *in, size_t inl,
+	const unsigned char *header)
+{
+    /* TODO: Remove these decisions from the sata path as they are static across the
+     * session */
+    if (NULL == agg_req ||
+	    NULL == evp_ctx ||
+		NULL == in ||
+		NULL == out )
+	{
+        WARN("[%s] Invalid parameters for request\n", __func__);
+        return 0;
+    }	
+	 
+    if (isZeroCopy())
+    { 
+        if (NID_rc4 == EVP_CIPHER_CTX_nid(evp_ctx) ||
+            !EVP_CIPHER_CTX_test_flags(evp_ctx, EVP_CIPH_CTX_FLAG_CAN_IGNORE_IV))
+        { /* Partial Packet processing */
+            /* TODO : investigate if this can be avoided in the zero copy mode */
+            if(in != out)
+                memcpy(out, in, inl);
+	
+            if (NULL == header)
+                agg_req->req_virt.src_buf.single.pData = (Cpa8U*)out;
+            else
+                agg_req->req_virt.src_buf.chained[1].pData = out;
+            agg_req->p_src_buf_list = &(agg_req->req_virt.src_buf_list);
+            agg_req->p_dst_buf_list = agg_req->p_src_buf_list;
+        } 
+        else
+        {
+            if (NULL == header)
+            {
+                agg_req->req_virt.src_buf.single.pData = (Cpa8U*)in;
+                agg_req->req_virt.dst_buf.single.pData = (Cpa8U*)out;
+            } 
+			else
+            {
+                agg_req->req_virt.src_buf.chained[1].pData = (Cpa8U*)in;
+                agg_req->req_virt.dst_buf.chained[1].pData = (Cpa8U*)out;
+            }
+            agg_req->p_src_buf_list = &(agg_req->req_virt.src_buf_list);
+            if (in != out)
+                agg_req->p_dst_buf_list = &(agg_req->req_virt.dst_buf_list);
+            else
+                agg_req->p_dst_buf_list = agg_req->p_src_buf_list;
+        }
+    } 
+    else
+    {
+        if (NULL == header)
+            memcpy(agg_req->req_virt.src_buf.single.pData, in, inl);
+        else
+            memcpy(agg_req->req_virt.src_buf.chained[1].pData, in, inl);
+
+        agg_req->p_src_buf_list = &(agg_req->req_virt.src_buf_list);
+        agg_req->p_dst_buf_list = agg_req->p_src_buf_list;
+    }
+
+    if (NULL != header)
+    {
+        if (isZeroCopy()){
+			memcpy(agg_req->req_virt.src_buf.chained[0].pData + (QAT_BYTE_ALIGNMENT - TLS_VIRT_HDR_SIZE), header,
+				agg_req->req_virt.src_buf.chained[0].dataLenInBytes - (QAT_BYTE_ALIGNMENT - TLS_VIRT_HDR_SIZE));
+        }
+        else
+        {
+        	memcpy(agg_req->req_virt.src_buf.chained[0].pData, header,
+        		agg_req->req_virt.src_buf.chained[0].dataLenInBytes);
+        }
+    }
+	
+	return 1;
+}
+#endif
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*         create_chained_request( EVP_CIPHER_CTX *evp_ctx,
+*                                 unsigned char* out,
+*                                 const unsigned char *in,
+*                                 size_t inl,
+*                                 CpaCySymSessionCtx sess_ctx,
+*                                 Cpa32U meta_size,
+*                                 unsigned int digest_len,
+*                                 const unsigned char* header,
+*                                 unsigned int hdr_size )
+*
+* @param evp_ctx    [IN] - Pointer to the evp context
+* @param out        [OUT] - The output buffer to populate
+* @param in         [IN] - The input buffer we copy from 
+* @param inl        [IN] - Length of the input buffer
+* @param sess_ctx   [IN] - The QAT Session Context
+* @param meta_size  [IN] - The size of the meta data
+* @param digest_len [IN] - The length of the digest in bytes
+* @param header     [IN] - The header data if any
+* @param hdr_size   [IN] - The header size in bytes
+*
+* @retval AGG_REQ - Return pointer to request. 
+*                   Return NULL on failure.
+*
+* description:
+*   This function creates a chained request from the
+*   parameters passed in.
+******************************************************************************/
+AGG_REQ* create_chained_request(EVP_CIPHER_CTX *evp_ctx, unsigned char* out,
+        const unsigned char *in, size_t inl,
+        CpaCySymSessionCtx sess_ctx, Cpa32U meta_size, 
+        unsigned int digest_len, const unsigned char* header, unsigned int hdr_size)
+{
+    AGG_REQ *agg_req = NULL;
+
+    if (NULL == (agg_req = OPENSSL_malloc(sizeof(AGG_REQ))))
+    {
+        WARN("[%s] Unable to malloc space for request\n", __func__);
+        goto end;
+    }
+
+    memset(agg_req, 0, sizeof(AGG_REQ));
+
+    if (0 == alloc_req_phys(meta_size, (unsigned int) inl, EVP_CIPHER_CTX_iv_length(evp_ctx),
+                digest_len, &(agg_req->req_phys), hdr_size))
+        goto end;
+
+    if (0 == link_buffers(&(agg_req->req_virt), &(agg_req->req_phys), (unsigned int) inl, hdr_size))
+        goto end;
+		
+    if (0 == set_buf_data(agg_req, evp_ctx, out, in, inl, header))
+        goto end;
+		
+    if (0 == populate_op_data(&(agg_req->req_virt.op_data), sess_ctx, evp_ctx, inl,
+		     &(agg_req->req_phys),hdr_size))
+        goto end; 
+
+    return agg_req;
+	
+    end:
+        if(NULL != agg_req)
+            OPENSSL_free(agg_req);
+        return NULL;        
+}
+#endif
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*         create_request( EVP_CIPHER_CTX *evp_ctx,
+*                         unsigned char* out,
+*                         const unsigned char *in,
+*                         size_t inl,
+*                         CpaCySymSessionCtx sess_ctx,
+*                         Cpa32U meta_size)
+*
+* @param evp_ctx    [IN] - Pointer to the evp context
+* @param out        [OUT] - The output buffer to populate
+* @param in         [IN] - The input buffer we copy from 
+* @param inl        [IN] - Length of the input buffer
+* @param sess_ctx   [IN] - The QAT Session Context
+* @param meta_size  [IN] - The size of the meta data
+*
+* @retval AGG_REQ - Return pointer to request. 
+*                   Return NULL on failure.
+*
+* description:
+*   This function creates a request from the
+*   parameters passed in.
+******************************************************************************/
+AGG_REQ* create_request(EVP_CIPHER_CTX *evp_ctx, unsigned char* out,
+        const unsigned char *in, size_t inl,
+        CpaCySymSessionCtx sess_ctx, Cpa32U meta_size)
+{
+    AGG_REQ *agg_req = NULL;
+
+    if (NULL == (agg_req = OPENSSL_malloc(sizeof(AGG_REQ))))
+    {
+        WARN("[%s] Unable to malloc space for request\n", __func__);
+        goto end;
+    }
+    
+    memset(agg_req, 0, sizeof(AGG_REQ));
+
+    if (0 == alloc_req_phys(meta_size, (unsigned int) inl, EVP_CIPHER_CTX_iv_length(evp_ctx), 
+		0, &(agg_req->req_phys), 0))
+        goto end;
+
+    link_buffers(&(agg_req->req_virt), &(agg_req->req_phys), (unsigned int) inl, 0);
+    set_buf_data(agg_req, evp_ctx, out, in, inl, NULL);
+    populate_op_data(&(agg_req->req_virt.op_data), sess_ctx, evp_ctx, inl,
+		&(agg_req->req_phys), 0);
+
+    return agg_req;
+
+    end:
+	if(NULL != agg_req)
+	    OPENSSL_free(agg_req);
+        return NULL;
+}
+#endif
+
+#ifdef OPENSSL_QAT_ASYNCH
+/******************************************************************************
+* function:
+*         destroy_request( AGG_REQ* agg_req )
+*
+* @param agg_req    [IN] - The request
+*
+* description:
+*   This function cleans up memory
+*   associated with a request.
+******************************************************************************/
+void destroy_request(AGG_REQ* agg_req)
+{
+    free_req_phys(&(agg_req->req_phys));
+    OPENSSL_free(agg_req);
+    agg_req = NULL;    
+}
+#endif
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_sym_common.h ./engines/qat_engine/qat_sym_common.h
--- ../openssl-async/engines/qat_engine/qat_sym_common.h	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_sym_common.h	2015-03-05 12:43:44.287956000 +0000
@@ -0,0 +1,128 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+  */
+
+/*****************************************************************************
+ * @file qat_sym_common.h
+ *
+ * This file provides an interface to Common Symmetric functions
+ *
+ *****************************************************************************/
+
+#ifndef QAT_SYM_COMMON_H
+#define QAT_SYM_COMMON_H
+
+#include <openssl/ossl_typ.h>
+
+#include "cpa.h"
+#include "cpa_cy_sym.h"
+
+typedef struct agg_req_virt_st AGG_REQ_VIRT;
+
+struct agg_req_virt_st
+{
+    CpaBufferList src_buf_list;
+    CpaBufferList dst_buf_list;
+    union
+    {
+        CpaFlatBuffer single;
+        CpaFlatBuffer chained[2];
+    } src_buf;
+    union
+    {
+        CpaFlatBuffer single;
+        CpaFlatBuffer chained[2];
+    } dst_buf;
+
+    CpaCySymOpData op_data;
+};
+
+typedef struct agg_req_phys_st AGG_REQ_PHYS;
+struct agg_req_phys_st
+{
+    void *base_addr;
+
+    void *src_priv_meta;
+    void *dst_priv_meta;
+
+    Cpa8U *src_data;
+    Cpa8U *dst_data;
+
+    Cpa8U *iv;	
+    Cpa8U *digest_res;
+};
+
+typedef struct agg_req_st AGG_REQ;
+struct agg_req_st
+{
+    AGG_REQ_VIRT req_virt;
+    AGG_REQ_PHYS req_phys;
+    /* These are pointers to the CpaBufferLists in req_virt
+     * and are needed to support partial packets */
+    CpaBufferList *p_src_buf_list;
+    CpaBufferList *p_dst_buf_list;
+};
+
+#define SRC_BUFFER_LIST(agg_req) (agg_req->p_src_buf_list)
+#define SRC_BUFFER_DATA(agg_req) (agg_req->p_src_buf_list->pBuffers)
+#define DST_BUFFER_LIST(agg_req) (agg_req->p_dst_buf_list)
+#define DST_BUFFER_DATA(agg_req) (agg_req->p_dst_buf_list->pBuffers)
+#define OPDATA_PTR(agg_req) (&(agg_req->req_virt.op_data))
+
+AGG_REQ* create_request(EVP_CIPHER_CTX *evp_ctx, unsigned char* out, 
+	const unsigned char *in, size_t inl, 
+	CpaCySymSessionCtx sess_ctx, Cpa32U meta_size);
+
+AGG_REQ* create_chained_request(EVP_CIPHER_CTX *evp_ctx, unsigned char* out,
+        const unsigned char *in, size_t inl,
+        CpaCySymSessionCtx sess_ctx, Cpa32U meta_size,
+        unsigned int digest_len, const unsigned char* header, unsigned int hdr_size);
+
+void destroy_request(AGG_REQ* agg_req);
+
+#endif //QAT_SYM_COMMON_H
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_utils.c ./engines/qat_engine/qat_utils.c
--- ../openssl-async/engines/qat_engine/qat_utils.c	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_utils.c	2015-03-05 12:43:44.288956000 +0000
@@ -0,0 +1,184 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qat_utils.c
+ *
+ * This file provides an implementation of utilities for an OpenSSL engine
+ *
+ *****************************************************************************/
+
+#include <stdio.h>
+#include <pthread.h>
+#include "cpa.h"
+#include "qat_utils.h"
+#include "e_qat.h"
+
+#ifdef QAT_TESTS_LOG
+
+FILE *cryptoQatLogger = NULL;
+pthread_mutex_t debug_file_mutex = PTHREAD_MUTEX_INITIALIZER;
+int debug_file_ref_count = 0;
+
+void crypto_qat_debug_init_log()
+{
+    pthread_mutex_lock(&debug_file_mutex);
+    if (!debug_file_ref_count) {
+        cryptoQatLogger = fopen(CRYPTO_QAT_LOG_FILE, "w"); 
+
+        if (NULL == cryptoQatLogger) {
+            sprintf(stderr, "ERROR, unable to open %s \n", CRYPTO_QAT_LOG_FILE);
+			pthread_mutex_unlock(&debug_file_mutex);
+            exit(1); 
+        }
+
+    }
+    debug_file_ref_count++;
+    pthread_mutex_unlock(&debug_file_mutex);
+}
+
+void crypto_qat_debug_close_log()
+{
+    pthread_mutex_lock(&debug_file_mutex);
+    debug_file_ref_count--;
+    if (!debug_file_ref_count) {
+        if (cryptoQatLogger != NULL) {
+            fclose(cryptoQatLogger);
+        }
+    }
+    pthread_mutex_unlock(&debug_file_mutex);
+}
+#endif /*QAT_TESTS_LOG*/
+
+#ifdef QAT_DEBUG
+void hexDump(const char *func, const char *var, const unsigned char p[],
+                    int l)
+{
+    int i;
+ 
+    fprintf(stderr, "%s: %s", func, var);
+    if(NULL != p && l != 0)
+    {
+        for (i = 0; i < l; i++)
+        {
+            if (i % 16 == 0)
+	        fputc('\n', stderr);
+            else if (i % 8 == 0)
+            	fputs("- ", stderr);
+	    fprintf(stderr, "%02x ", p[i]);
+    	}
+    }
+    fputc('\n', stderr);
+}
+ 
+void dumpRequest(const CpaInstanceHandle instanceHandle,
+                        void *pCallbackTag,
+                        const CpaCySymOpData * pOpData,
+                        const CpaCySymSessionSetupData * sessionData,
+                        const CpaBufferList * pSrcBuffer,
+                        CpaBufferList * pDstBuffer)
+{
+    unsigned int index = 0;
+    struct op_done_asynch *opDoneCB = (struct op_done_asynch*)pCallbackTag;
+ 
+    fprintf(stderr, "\nInstance Handle:    %p\n", instanceHandle);
+    fprintf(stderr, "Callback Ptr:       %p\n", opDoneCB);
+    fprintf(stderr, "OpData->packetType:        %s\n", 
+	(pOpData->packetType==CPA_CY_SYM_PACKET_TYPE_FULL?"FULL":"PARTIAL"));
+    hexDump(__func__, "Cipher Key:      ",
+            sessionData->cipherSetupData.pCipherKey,
+            sessionData->cipherSetupData.cipherKeyLenInBytes);
+    fprintf(stderr, "Cipher Key Len:     %u\n",
+            sessionData->cipherSetupData.cipherKeyLenInBytes);
+    hexDump(__func__, "Cipher IV:               ",
+            pOpData->pIv, pOpData->ivLenInBytes);
+    if(sessionData->symOperation != CPA_CY_SYM_OP_CIPHER)
+    {
+       hexDump(__func__, "MAC Key:                 ",
+            sessionData->hashSetupData.authModeSetupData.authKey,
+            sessionData->hashSetupData.authModeSetupData.authKeyLenInBytes);
+    }
+    for(index = 0; index < pSrcBuffer->numBuffers; index++)
+    {
+        fprintf(stderr, "pSrcBuffer->pBuffers[%u].pData:                   %p\n", index, pSrcBuffer->pBuffers[index].pData);
+        hexDump(__func__, " ",
+            pSrcBuffer->pBuffers[index].pData,
+            pSrcBuffer->pBuffers[index].dataLenInBytes);
+        fprintf(stderr, "pSrcBuffer->pBuffers[%u].dataLenInBytes:          %u\n\n",
+           index, pSrcBuffer->pBuffers[index].dataLenInBytes);
+    }
+ 
+    for(index = 0; index < pDstBuffer->numBuffers; index++)
+    {
+        fprintf(stderr, "pDstBuffer->pBuffers[%u].pData:                  %p\n", index, pDstBuffer->pBuffers[index].pData);
+        hexDump(__func__, " ",
+            pDstBuffer->pBuffers[index].pData,
+            pDstBuffer->pBuffers[index].dataLenInBytes);
+        fprintf(stderr, "pDstBuffer->pBuffers[%u].dataLenInBytes:         %u\n\n",
+            index, pDstBuffer->pBuffers[index].dataLenInBytes);
+    }
+ 
+    fprintf(stderr, "sessionData->cipherSetupData.cipherAlgorithm:       %u\n", sessionData->cipherSetupData.cipherAlgorithm);
+    fprintf(stderr, "sessionData->cipherSetupData.cipherDirection:       %u\n", sessionData->cipherSetupData.cipherDirection);
+    fprintf(stderr, "sessionData->algChainOrder:                         %u\n", sessionData->algChainOrder);
+    fprintf(stderr, "pOpData->cryptoStartSrcOffsetInBytes:               %u\n", pOpData->cryptoStartSrcOffsetInBytes);
+    fprintf(stderr, "pOpData->messageLenToCipherInBytes:                 %u\n", pOpData->messageLenToCipherInBytes);
+    fprintf(stderr, "sessionData->hashSetupData.hashAlgorithm:           %u\n", sessionData->hashSetupData.hashAlgorithm);
+    fprintf(stderr, "sessionData->hashSetupData.hashMode:                %u\n", sessionData->hashSetupData.hashMode);
+    fprintf(stderr, "pOpData->hashStartSrcOffsetInBytes:                 %u\n", pOpData->hashStartSrcOffsetInBytes);
+    fprintf(stderr, "sessionData->hashSetupData.digestResultLenInBytes:  %u\n", sessionData->hashSetupData.digestResultLenInBytes);
+    fprintf(stderr, "pOpData->messageLenToHashInBytes:                   %u\n", pOpData->messageLenToHashInBytes);
+    fprintf(stderr, "pOpData->pDigestResult:                             %p\n", pOpData->pDigestResult);
+    fprintf(stderr, "sessionData->verifyDigest:                          %s\n", (sessionData->verifyDigest==CPA_TRUE?"CPA_TRUE":"CPA_FALSE"));
+    fprintf(stderr, "sessionData->digestIsAppended:			 %s\n", (sessionData->digestIsAppended==CPA_TRUE?"CPA_TRUE":"CPA_FALSE"));
+    //fprintf(stderr, "*pVerifyResult:                                   %u\n", *pVerifyResult);
+    fprintf(stderr, "opDoneCB->verifyResult:                             %u\n", opDoneCB->verifyResult);
+}
+#endif
+
diff -uBbw -Nr ../openssl-async/engines/qat_engine/qat_utils.h ./engines/qat_engine/qat_utils.h
--- ../openssl-async/engines/qat_engine/qat_utils.h	1970-01-01 01:00:00.000000000 +0100
+++ ./engines/qat_engine/qat_utils.h	2015-03-05 12:43:44.289958000 +0000
@@ -0,0 +1,134 @@
+/* ====================================================================
+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*****************************************************************************
+ * @file qat_utils.h
+ *
+ * This file provides an interface to utilities for the QAT engine in OpenSSL
+ *
+ *****************************************************************************/
+
+#ifndef QAT_UTILS_H
+#define QAT_UTILS_H
+
+#include <stdio.h>
+#include <pthread.h>
+#include "cpa.h"
+#include "cpa_cy_sym.h"
+
+#define QAT_BYTE_ALIGNMENT 64
+/* For best performance data buffers should be 64-byte aligned */
+#define QAT_MEM_ALIGN(x) (void *)(((uintptr_t)(x) + QAT_BYTE_ALIGNMENT - 1) & (~(uintptr_t)(QAT_BYTE_ALIGNMENT-1)))
+
+/* Add -DQAT_TESTS_LOG to ./config to enable
+   debug logging to the CRYPTO_QAT_LOG_FILE */
+
+#ifdef QAT_TESTS_LOG
+
+#define CRYPTO_QAT_LOG_FILE "/opt/qat-crypto.log"
+
+extern FILE *cryptoQatLogger;
+extern pthread_mutex_t debug_file_mutex;
+extern int debug_file_ref_count; 
+
+void crypto_qat_debug_init_log();
+void crypto_qat_debug_close_log();
+
+#define CRYPTO_INIT_QAT_LOG() crypto_qat_debug_init_log()
+
+#define CRYPTO_CLOSE_QAT_LOG() crypto_qat_debug_close_log()
+
+#define CRYPTO_QAT_LOG(...)                         \
+do {                                                \
+    pthread_mutex_lock(&debug_file_mutex);          \
+	if (debug_file_ref_count) {                     \
+	    if (cryptoQatLogger != NULL) {              \
+		    fprintf (cryptoQatLogger, __VA_ARGS__); \
+            fflush(cryptoQatLogger);                \
+        }                                           \
+    }                                               \
+	pthread_mutex_unlock(&debug_file_mutex);        \
+} while(0)
+
+#else
+
+#define CRYPTO_QAT_LOG(...)
+#define CRYPTO_CLOSE_QAT_LOG()
+#define CRYPTO_INIT_QAT_LOG()
+
+#endif
+
+/*#define QAT_DEBUG*/
+/*#define QAT_WARN*/
+
+#ifdef QAT_DEBUG
+void hexDump(const char *func, const char *var, const unsigned char p[], int l);
+void dumpRequest(const CpaInstanceHandle instanceHandle,
+                        void *pCallbackTag,
+                        const CpaCySymOpData * pOpData,
+                        const CpaCySymSessionSetupData * sessionData,
+                        const CpaBufferList * pSrcBuffer,
+                        CpaBufferList * pDstBuffer);
+#define DEBUG(...) fprintf(stderr, __VA_ARGS__)
+#define DUMPL(var,p,l) hexDump(__func__,var,p,l);
+#define DUMPREQ(inst, cb, opD, sess, src, dst) dumpRequest(inst, cb, opD, sess, src, dst);
+#else
+#define DEBUG(...)
+#define DUMPL(...)
+#define DUMPREQ(...)
+#endif
+ 
+/* warning message for qat engine and cpa function */
+#ifdef QAT_WARN
+#define WARN(...) fprintf (stderr, __VA_ARGS__)
+#else
+#define WARN(...)
+#endif
+
+#endif /*QAT_UTILS_H*/
diff -uBbw -Nr ../openssl-async/ssl/s3_pkt.c ./ssl/s3_pkt.c
--- ../openssl-async/ssl/s3_pkt.c	2015-03-05 12:44:10.207308000 +0000
+++ ./ssl/s3_pkt.c	2015-03-05 12:43:44.355957000 +0000
@@ -146,6 +146,12 @@
 	left  = rb->left;
 #if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0
 	align = (long)rb->buf + SSL3_RT_HEADER_LENGTH;
+ #ifndef OPENSSL_NO_HW_QAT
+                if (s->enc_read_ctx && s->version >= TLS1_1_VERSION)
+                {
+                        align += EVP_CIPHER_CTX_block_size(s->enc_read_ctx);
+                }
+ #endif
 	align = (-align)&(SSL3_ALIGN_PAYLOAD-1);
 #endif
 
@@ -1158,6 +1164,12 @@
 		{
 #if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0
 		align = (long)wb->buf + SSL3_RT_HEADER_LENGTH;
+ #ifndef OPENSSL_NO_HW_QAT
+                if (s->enc_write_ctx && s->version >= TLS1_1_VERSION)
+                        {
+                        align += EVP_CIPHER_CTX_block_size(s->enc_write_ctx);
+                        }
+ #endif
 		align = (-align)&(SSL3_ALIGN_PAYLOAD-1);
 #endif
 		p = wb->buf + align;
diff -uBbw -Nr ../openssl-async/ssl/ssl3.h ./ssl/ssl3.h
--- ../openssl-async/ssl/ssl3.h	2015-03-05 12:44:10.219311000 +0000
+++ ./ssl/ssl3.h	2015-03-05 12:43:44.366962000 +0000
@@ -262,6 +263,9 @@
   * 3 bytes in either case. Suggested pre-gaping simply moves these
   * wasted bytes from the end of allocated region to its front,
   * but makes data payload aligned, which improves performance:-) */
+ #ifndef OPENSSL_NO_HW_QAT
+  #define SSL3_ALIGN_PAYLOAD        64
+ #endif
  #ifdef OPENSSL_NO_HW_QAT
 # define SSL3_ALIGN_PAYLOAD			8
  #endif
diff -uBbw -Nr ../openssl-async/test/Makefile ./test/Makefile
--- ../openssl-async/test/Makefile	2015-03-05 12:43:37.466867000 +0000
+++ ./test/Makefile	2015-03-05 12:44:09.870302000 +0000
@@ -30,6 +30,49 @@
 LIBPTHREAD=-lpthread
 LIBRARIES=$(LIBSSL) $(LIBKRB5) $(LIBCRYPTO) $(LIBPTHREAD) 
 
+ifndef CMN_ROOT
+CRYPTO_MEMORY_DRIVER=qat_mem
+else
+CRYPTO_MEMORY_DRIVER=qae_mem
+endif
+
+ifeq ($(CRYPTO_MEMORY_DRIVER),qat_mem)
+CFLAGS+=-D USE_QAT_MEM -I$(OPENSSL_ROOT)/engines/qat_engine/
+DLIB_QAE_MEM= -L../engines/qat_engine -lqae_mem_utils
+SLIB_QAE_MEM= 
+endif
+ifeq ($(CRYPTO_MEMORY_DRIVER),qae_mem)
+CFLAGS+=-D USE_QAE_MEM -I$(OPENSSL_ROOT)/engines/qat_engine/
+DLIB_QAE_MEM = -Wl,-rpath,$(CMN_ROOT) -L$(CMN_ROOT) -lqae_mem_s
+DLIB_QAE_MEM += -L$(OPENSSL_ROOT)/engines/qat_engine/ -lqat_mem_drv_inf
+SLIB_QAE_MEM+= $(CMN_ROOT)/libqae_mem.a
+endif
+
+LIBQATDL=-ldl
+LIBRARIES += $(LIBQATDL)
+LIBQATZ=-lz
+LIBQATRT=-lrt
+DRIVER=icp_qa_al
+ifdef WITH_CPA_MUX
+DRIVER=qat_mux
+BUILD_PATH=-L$(ICP_ROOT)/../cpa_mux/src/build/linux_2.6/user_space
+endif
+
+ifdef ICP_BUILD_OUTPUT
+LIBQATDRIVER=
+DLIBQATDRIVER= -L$(ICP_BUILD_OUTPUT) $(BUILD_PATH) -l$(DRIVER) -ladf_proxy -losal
+else
+LIBQATDRIVER=
+DLIBQATDRIVER= -l$(DRIVER) -ladf_proxy -losal
+endif
+
+ifneq ($(shell test -n "$(SHARED_LIBS)" && echo 1),1) #STATIC
+LIBRARIES += $(SLIB_QAE_MEM) $(DLIBQATDRIVER) 
+else #SHARED
+LIBRARIES += $(DLIB_QAE_MEM)
+endif 
+LIBRARIES += $(LIBQATZ) $(LIBQATRT)
+
 BNTEST=		bntest
 ECTEST=		ectest
 ECDSATEST=	ecdsatest
